###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        29/Sep/2020  10:09:19
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\modules\Source\FLOW_Sensirion.c
#    Command line =  
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\modules\Source\FLOW_Sensirion.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F40XX -lC
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Debug\List\" -o
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\board\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\app\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\modules\Header\" -On --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\CMSIS\Include\" --relaxed_fp
#    List file    =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Debug\List\FLOW_Sensirion.lst
#    Object file  =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13
#        (990707) Sensirion\Debug\Obj\FLOW_Sensirion.o
#
###############################################################################

E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\MAIN Version\SVC2_8_13 (990707) Sensirion\modules\Source\FLOW_Sensirion.c
      1          //-----------------------------------------------------------------------------|
      2          // SAADAT Co 
      3          // VENTILATOR 
      4          // DEVELOPER : MOJTABA REZAEI ASHTIYANI
      5          // VER 1.0
      6          // This File contains the Set up the flow sensor TSI company which contains :
      7          // __the coefficients read from memory with I2C communication.
      8          // __reading the analog value is output.
      9          //-----------------------------------------------------------------------------|
     10          
     11          #include "FLOW_Sensirion.h"
     12          #include "Flow_TSI_1.h"
     13          
     14          extern  void init_I2C(I2C_TypeDef* I2Cx);
     15          //--------------------------------------
     16          extern          STRUCT_DATA_A2DSENSORS          DATA_Sensors;
     17          //--------------------------------------------------
     18          

   \                                 In section .bss, align 4
     19          u32                         I2C_Timeout;
   \                     I2C_Timeout:
   \   00000000                      DS8 4
     20          //--------------------------------------------------
     21          

   \                                 In section .bss, align 4
     22          UNION_PACKET_U32_BYTE   Sensirion_SN;
   \                     Sensirion_SN:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     23          UNION_PACKET_U16_BYTE   Sensirion_OFFset, Sensirion_SCALE;
   \                     Sensirion_OFFset:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     Sensirion_SCALE:
   \   00000000                      DS8 4
     24          
     25          //--------------------------------------------------
     26          

   \                                 In section .data, align 4
     27          u8 EXH_DATACMD_Buffer[] = {0x10,0x00 ,0x30,0xDE, 0x30,0xDF,0x31,0xAE,0x20,0x00};
   \                     EXH_DATACMD_Buffer:
   \   00000000   0x10 0x00          DC8 16, 0, 48, 222, 48, 223, 49, 174, 32, 0, 0, 0
   \              0x30 0xDE    
   \              0x30 0xDF    
   \              0x31 0xAE    
   \              0x20 0x00    
   \              0x00 0x00    
     28          //                           datda      scale      offset      SN      Reset                

   \                                 In section .bss, align 2
     29          u8 EXH_DMARCV_Buffer_Data[2];
   \                     EXH_DMARCV_Buffer_Data:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     30          float EXHData;
   \                     EXHData:
   \   00000000                      DS8 4
     31          
     32          
     33          #define     DISCONNET_EXH_CNTV        100
     34          #define     CONNET_EXH_CNTV           20
     35          

   \                                 In section .bss, align 1
     36          u8      TimeDel , delaycnt;
   \                     TimeDel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     delaycnt:
   \   00000000                      DS8 1
     37          //---------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     38          void Flow_SENSIRION_EXH_ReadDATA(void)
     39          {
   \                     Flow_SENSIRION_EXH_ReadDATA: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xED2D 0x8B02      VPUSH    {D8}
   \   00000006   0xB082             SUB      SP,SP,#+8
     40            static    u8  StateExhSensi = READ_DATA, CNT_ERR_Disconnect = 0, CNT_ERR_Connect = 0;
     41            u8        EXH_DATACMD_Buffer_scaleoffset[2] = {0};
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     42            float     Ksn;  
     43            
     44            //----.......
     45            switch(StateExhSensi)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable4
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD012             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_0
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xF000 0x8173      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_1
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xF000 0x81A1      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_2
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xF000 0x8159      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_3
   \   0000002A   0x2806             CMP      R0,#+6
   \   0000002C   0xF000 0x8187      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_4
   \   00000030   0x2808             CMP      R0,#+8
   \   00000032   0xF000 0x81B5      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_5
   \   00000036   0x280A             CMP      R0,#+10
   \   00000038   0xF000 0x8103      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_6
   \   0000003C   0xE1C3             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
     46            {
     47            case READ_DATA:   /*  01  */
     48              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DMARCV_Buffer_Data ,2))!= I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_0: (+1)
   \   0000003E   0x2302             MOVS     R3,#+2
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   00000044   0x2181             MOVS     R1,#+129
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   0000004A   0x.... 0x....      BL       I2C_Receive
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD025             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_8
     49              {
     50                CNT_ERR_Disconnect++;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
     51                if(CNT_ERR_Disconnect >= DISCONNET_EXH_CNTV)//100
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x2864             CMP      R0,#+100
   \   00000068   0xF2C0 0x80EA      BLT.W    ??Flow_SENSIRION_EXH_ReadDATA_9
     52                {
     53                  DATA_Sensors.HWErr.EXHSENSOR = 1;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000070   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000072   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   0000007A   0x87C8             STRH     R0,[R1, #+62]
     54                  DATA_Sensors.Flow_EXH = 0; // Reset data
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000082   0x8188             STRH     R0,[R1, #+12]
     55                  StateExhSensi = SENSOR_DETECT; //Go to CMD SCALE / Error Disconnection
   \   00000084   0x200A             MOVS     R0,#+10
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
     56                  CNT_ERR_Disconnect = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   00000092   0x7008             STRB     R0,[R1, #+0]
     57                  CNT_ERR_Connect = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
   \   0000009C   0xE0D0             B.N      ??Flow_SENSIRION_EXH_ReadDATA_9
     58                }
     59              }
     60              else
     61              {
     62                EXHData = (float)(EXH_DMARCV_Buffer_Data[0] *256 + EXH_DMARCV_Buffer_Data[1]);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_8: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0xF44F 0x7180      MOV      R1,#+256
   \   000000A8   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   000000AC   0x7852             LDRB     R2,[R2, #+1]
   \   000000AE   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000B2   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B6   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000BE   0xED80 0x0A00      VSTR     S0,[R0, #0]
     63                EXHData = (EXHData - Sensirion_OFFset.ALLBYTE)/Sensirion_SCALE.ALLBYTE;
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   000000C6   0x8800             LDRH     R0,[R0, #+0]
   \   000000C8   0xEE00 0x0A10      VMOV     S0,R0
   \   000000CC   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000D4   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000000D8   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000E0   0x8800             LDRH     R0,[R0, #+0]
   \   000000E2   0xEE00 0x0A90      VMOV     S1,R0
   \   000000E6   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   000000EA   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000F2   0xED80 0x0A00      VSTR     S0,[R0, #0]
     64                // Convert to BTPS
     65                Ksn = ((float)DATA_Sensors.A2D_AmbientPressure / 10) + ((float)DATA_Sensors.Press_INH / 100 );
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   000000FA   0x8B40             LDRH     R0,[R0, #+26]
   \   000000FC   0xEE00 0x0A10      VMOV     S0,R0
   \   00000100   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000104   0xEEF2 0x0A04      VMOV.F32 S1,#10.0
   \   00000108   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000110   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000114   0xEE00 0x0A90      VMOV     S1,R0
   \   00000118   0xEEF8 0x0AE0      VCVT.F32.S32 S1,S1
   \   0000011C   0xED9F 0x....      VLDR.W   S2,??DataTable0  ;; 0x42c80000
   \   00000120   0xEEC0 0x0A81      VDIV.F32 S1,S1,S2
   \   00000124   0xEE30 0x0A20      VADD.F32 S0,S0,S1
   \   00000128   0xEEB0 0x8A40      VMOV.F32 S16,S0
     66                Ksn = ( PFixCOEFFICIENT1 / (Ksn - 64.0) ) * PFixCOEFFICIENT2;    
   \   0000012C   0xEE18 0x0A10      VMOV     R0,S16
   \   00000130   0x.... 0x....      BL       __aeabi_f2d
   \   00000134   0x2200             MOVS     R2,#+0
   \   00000136   0x.... 0x....      LDR.W    R3,??DataTable4_9  ;; 0xc0500000
   \   0000013A   0x.... 0x....      BL       __aeabi_dadd
   \   0000013E   0x0002             MOVS     R2,R0
   \   00000140   0x000B             MOVS     R3,R1
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable4_10  ;; 0x78d4fdf4
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable4_11  ;; 0x409024e9
   \   0000014A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000014E   0x.... 0x....      LDR.W    R2,??DataTable4_12  ;; 0x3f141206
   \   00000152   0x.... 0x....      LDR.W    R3,??DataTable4_13  ;; 0x3ff0dcc6
   \   00000156   0x.... 0x....      BL       __aeabi_dmul
   \   0000015A   0x.... 0x....      BL       __aeabi_d2f
   \   0000015E   0xEE08 0x0A10      VMOV     S16,R0
     67                EXHData *= Ksn;
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000166   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000016A   0xEE20 0x0A08      VMUL.F32 S0,S0,S16
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000172   0xED80 0x0A00      VSTR     S0,[R0, #0]
     68                if(EXHData < 0)
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   0000017A   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000017E   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   00000182   0xEEF1 0xFA10      FMSTAT   
   \   00000186   0xD50E             BPL.N    ??Flow_SENSIRION_EXH_ReadDATA_10
     69                {
     70                  if(EXHData < -50)
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   0000018C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000190   0xEDDF 0x....      VLDR.W   S1,??DataTable0_1  ;; 0xc2480000
   \   00000194   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000198   0xEEF1 0xFA10      FMSTAT   
   \   0000019C   0xD503             BPL.N    ??Flow_SENSIRION_EXH_ReadDATA_10
     71                    StateExhSensi = SENDCMD_DATA;
   \   0000019E   0x2008             MOVS     R0,#+8
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000001A4   0x7008             STRB     R0,[R1, #+0]
     72                }
     73                
     74                EXHData = EXHData <= 0 ? 0:EXHData;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_10: (+1)
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000001AA   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000001AE   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000001B2   0xEEF1 0xFA10      FMSTAT   
   \   000001B6   0xD804             BHI.N    ??Flow_SENSIRION_EXH_ReadDATA_11
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000001BC   0x2100             MOVS     R1,#+0
   \   000001BE   0x6001             STR      R1,[R0, #+0]
   \   000001C0   0xE005             B.N      ??Flow_SENSIRION_EXH_ReadDATA_12
   \                     ??Flow_SENSIRION_EXH_ReadDATA_11: (+1)
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000001C6   0x.... 0x....      LDR.W    R1,??DataTable4_6
   \   000001CA   0x6809             LDR      R1,[R1, #+0]
   \   000001CC   0x6001             STR      R1,[R0, #+0]
     75                DATA_Sensors.Flow_EXH = (u16) (EXHData*100);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_12: (+1)
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000001D2   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000001D6   0xEDDF 0x....      VLDR.W   S1,??DataTable0  ;; 0x42c80000
   \   000001DA   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   000001DE   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000001E2   0xEE10 0x0A10      VMOV     R0,S0
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   000001EA   0x8188             STRH     R0,[R1, #+12]
     76                
     77                if(DATA_Sensors.HWErr.EXHSENSOR == 1)
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   000001F0   0x8FC0             LDRH     R0,[R0, #+62]
   \   000001F2   0xF3C0 0x20C0      UBFX     R0,R0,#+11,#+1
   \   000001F6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001F8   0x2800             CMP      R0,#+0
   \   000001FA   0xD021             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_9
     78                {
     79                  if(++CNT_ERR_Connect >= CONNET_EXH_CNTV)
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   00000200   0x7800             LDRB     R0,[R0, #+0]
   \   00000202   0x1C40             ADDS     R0,R0,#+1
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   00000208   0x7008             STRB     R0,[R1, #+0]
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   0000020E   0x7800             LDRB     R0,[R0, #+0]
   \   00000210   0x2814             CMP      R0,#+20
   \   00000212   0xDB15             BLT.N    ??Flow_SENSIRION_EXH_ReadDATA_9
     80                  {
     81                    DATA_Sensors.HWErr.EXHSENSOR = 0;
   \   00000214   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000218   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000021A   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000021E   0x4008             ANDS     R0,R1,R0
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000224   0x87C8             STRH     R0,[R1, #+62]
     82                    DATA_Sensors.HWErr.EXHHARDWARE = 0;
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   0000022A   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000022C   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000230   0x4008             ANDS     R0,R1,R0
   \   00000232   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000236   0x87C8             STRH     R0,[R1, #+62]
     83                    CNT_ERR_Connect = 0;
   \   00000238   0x2000             MOVS     R0,#+0
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   0000023E   0x7008             STRB     R0,[R1, #+0]
     84                  }
     85                }
     86              }
     87              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_9: (+1)
   \   00000240   0xE0C1             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
     88              //----------------------
     89            case SENSOR_DETECT:   /*  0A  */
     90              TimeDel++;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_6: (+1)
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x1C40             ADDS     R0,R0,#+1
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable4_14
   \   0000024E   0x7008             STRB     R0,[R1, #+0]
     91              DATA_Sensors.HWErr.EXHSENSOR = 1;
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000254   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000256   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   0000025A   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   0000025E   0x87C8             STRH     R0,[R1, #+62]
     92              if(TimeDel == 10)
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   00000264   0x7800             LDRB     R0,[R0, #+0]
   \   00000266   0x280A             CMP      R0,#+10
   \   00000268   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_13
     93              {
     94                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1,ENABLE);
   \   0000026A   0x2101             MOVS     R1,#+1
   \   0000026C   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000270   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000274   0xE031             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
     95              }
     96              else if(TimeDel == 11)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_13: (+1)
   \   00000276   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   0000027A   0x7800             LDRB     R0,[R0, #+0]
   \   0000027C   0x280B             CMP      R0,#+11
   \   0000027E   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_15
     97              {
     98                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1,DISABLE);
   \   00000280   0x2100             MOVS     R1,#+0
   \   00000282   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000286   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000028A   0xE026             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
     99              }
    100              else if(TimeDel == 200)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_15: (+1)
   \   0000028C   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   00000290   0x7800             LDRB     R0,[R0, #+0]
   \   00000292   0x28C8             CMP      R0,#+200
   \   00000294   0xD104             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_16
    101              {       
    102                init_I2C(SENSIRION_EXH);
   \   00000296   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   0000029A   0x.... 0x....      BL       init_I2C
   \   0000029E   0xE01C             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
    103              }
    104              else if(TimeDel >= 250)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_16: (+1)
   \   000002A0   0x.... 0x....      LDR.W    R0,??DataTable4_14
   \   000002A4   0x7800             LDRB     R0,[R0, #+0]
   \   000002A6   0x28FA             CMP      R0,#+250
   \   000002A8   0xDB17             BLT.N    ??Flow_SENSIRION_EXH_ReadDATA_14
    105              {
    106                TimeDel=0;
   \   000002AA   0x2000             MOVS     R0,#+0
   \   000002AC   0x.... 0x....      LDR.W    R1,??DataTable4_14
   \   000002B0   0x7008             STRB     R0,[R1, #+0]
    107                if(Check_Connect(SENSIRION_EXH, 0x80) == CONNECTOK50)
   \   000002B2   0x2180             MOVS     R1,#+128
   \   000002B4   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000002B8   0x.... 0x....      BL       Check_Connect
   \   000002BC   0x2832             CMP      R0,#+50
   \   000002BE   0xD104             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_17
    108                  StateExhSensi = SENDCMD_SCALE; //Go to CMD SCALE 
   \   000002C0   0x2005             MOVS     R0,#+5
   \   000002C2   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002C6   0x7008             STRB     R0,[R1, #+0]
   \   000002C8   0xE007             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
    109                else
    110                {
    111                  I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[8], 2);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_17: (+1)
   \   000002CA   0x2302             MOVS     R3,#+2
   \   000002CC   0x.... 0x....      LDR.W    R2,??DataTable4_15
   \   000002D0   0x2180             MOVS     R1,#+128
   \   000002D2   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000002D6   0x.... 0x....      BL       I2C_Transmit
    112                }
    113              }    
    114              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_14: (+1)
   \   000002DA   0xE074             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    115              //----------------------
    116            case SENDCMD_SCALE: /*  5  */
    117              if((I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[2], 2)) != I2C_OK) // Scale
   \                     ??Flow_SENSIRION_EXH_ReadDATA_3: (+1)
   \   000002DC   0x2302             MOVS     R3,#+2
   \   000002DE   0x.... 0x....      LDR.W    R2,??DataTable4_16
   \   000002E2   0x2180             MOVS     R1,#+128
   \   000002E4   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000002E8   0x.... 0x....      BL       I2C_Transmit
   \   000002EC   0x2800             CMP      R0,#+0
   \   000002EE   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_18
    118              {
    119                //Error  DISConnection / go to timer
    120                StateExhSensi = SENSOR_DETECT; // Back to DETECT 
   \   000002F0   0x200A             MOVS     R0,#+10
   \   000002F2   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002F6   0x7008             STRB     R0,[R1, #+0]
   \   000002F8   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_19
    121              }
    122              else
    123              {
    124                StateExhSensi = READ_SCALE; //Go to Read SCALE
   \                     ??Flow_SENSIRION_EXH_ReadDATA_18: (+1)
   \   000002FA   0x2002             MOVS     R0,#+2
   \   000002FC   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000300   0x7008             STRB     R0,[R1, #+0]
    125              }
    126              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_19: (+1)
   \   00000302   0xE060             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    127              //----------------------
    128            case READ_SCALE:  /*  02  */
    129              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DATACMD_Buffer_scaleoffset ,2)) != I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_1: (+1)
   \   00000304   0x2302             MOVS     R3,#+2
   \   00000306   0xAA00             ADD      R2,SP,#+0
   \   00000308   0x2181             MOVS     R1,#+129
   \   0000030A   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   0000030E   0x.... 0x....      BL       I2C_Receive
   \   00000312   0x2800             CMP      R0,#+0
   \   00000314   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_20
    130              {
    131                StateExhSensi = SENSOR_DETECT; //Back to DETECT  
   \   00000316   0x200A             MOVS     R0,#+10
   \   00000318   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000031C   0x7008             STRB     R0,[R1, #+0]
   \   0000031E   0xE00D             B.N      ??Flow_SENSIRION_EXH_ReadDATA_21
    132              }
    133              else
    134              {
    135                Sensirion_SCALE.Data.HIGHBYT = EXH_DATACMD_Buffer_scaleoffset[0];
   \                     ??Flow_SENSIRION_EXH_ReadDATA_20: (+1)
   \   00000320   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000324   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   00000328   0x7048             STRB     R0,[R1, #+1]
    136                Sensirion_SCALE.Data.LOWBYT = EXH_DATACMD_Buffer_scaleoffset[1];
   \   0000032A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000032E   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   00000332   0x7008             STRB     R0,[R1, #+0]
    137                StateExhSensi = SENDCMD_OFFSET; //Go to CMD OFFSET
   \   00000334   0x2006             MOVS     R0,#+6
   \   00000336   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000033A   0x7008             STRB     R0,[R1, #+0]
    138              }
    139              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_21: (+1)
   \   0000033C   0xE043             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    140              //----------------------
    141            case SENDCMD_OFFSET:  /*  06  */
    142              if((I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[4], 2)) != I2C_OK) // OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_4: (+1)
   \   0000033E   0x2302             MOVS     R3,#+2
   \   00000340   0x.... 0x....      LDR.W    R2,??DataTable4_17
   \   00000344   0x2180             MOVS     R1,#+128
   \   00000346   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   0000034A   0x.... 0x....      BL       I2C_Transmit
   \   0000034E   0x2800             CMP      R0,#+0
   \   00000350   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_22
    143              {
    144                //Error / go to timer
    145                StateExhSensi = SENSOR_DETECT; //Back to DETECT  
   \   00000352   0x200A             MOVS     R0,#+10
   \   00000354   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000358   0x7008             STRB     R0,[R1, #+0]
   \   0000035A   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_23
    146              }
    147              else
    148              {
    149                StateExhSensi = READ_OFFSET; //Go to Read OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_22: (+1)
   \   0000035C   0x2003             MOVS     R0,#+3
   \   0000035E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000362   0x7008             STRB     R0,[R1, #+0]
    150              }
    151              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_23: (+1)
   \   00000364   0xE02F             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    152              //----------------------
    153            case READ_OFFSET: /*  03  */
    154              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DATACMD_Buffer_scaleoffset ,2)) != I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_2: (+1)
   \   00000366   0x2302             MOVS     R3,#+2
   \   00000368   0xAA00             ADD      R2,SP,#+0
   \   0000036A   0x2181             MOVS     R1,#+129
   \   0000036C   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   00000370   0x.... 0x....      BL       I2C_Receive
   \   00000374   0x2800             CMP      R0,#+0
   \   00000376   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_24
    155              {
    156                StateExhSensi = SENSOR_DETECT; //Back to DETECT 
   \   00000378   0x200A             MOVS     R0,#+10
   \   0000037A   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000037E   0x7008             STRB     R0,[R1, #+0]
   \   00000380   0xE00D             B.N      ??Flow_SENSIRION_EXH_ReadDATA_25
    157              }
    158              else
    159              {
    160                Sensirion_OFFset.Data.HIGHBYT = EXH_DATACMD_Buffer_scaleoffset[0];
   \                     ??Flow_SENSIRION_EXH_ReadDATA_24: (+1)
   \   00000382   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000386   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   0000038A   0x7048             STRB     R0,[R1, #+1]
    161                Sensirion_OFFset.Data.LOWBYT = EXH_DATACMD_Buffer_scaleoffset[1];
   \   0000038C   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000390   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000394   0x7008             STRB     R0,[R1, #+0]
    162                StateExhSensi = SENDCMD_DATA; //Go to CMD DATA
   \   00000396   0x2008             MOVS     R0,#+8
   \   00000398   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000039C   0x7008             STRB     R0,[R1, #+0]
    163              }
    164              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_25: (+1)
   \   0000039E   0xE012             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    165              //----------------------
    166              //SN
    167              //----------------------
    168              //----------------------
    169            case SENDCMD_DATA:    /*  08  */
    170              if((I2C_Transmit(SENSIRION_EXH, 0x80, EXH_DATACMD_Buffer, 2)) != I2C_OK) // Request Data - 0x1000) 
   \                     ??Flow_SENSIRION_EXH_ReadDATA_5: (+1)
   \   000003A0   0x2302             MOVS     R3,#+2
   \   000003A2   0x.... 0x....      LDR.W    R2,??DataTable4_18
   \   000003A6   0x2180             MOVS     R1,#+128
   \   000003A8   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000003AC   0x.... 0x....      BL       I2C_Transmit
   \   000003B0   0x2800             CMP      R0,#+0
   \   000003B2   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_26
    171              {
    172                //Error / go to timer
    173                StateExhSensi = SENSOR_DETECT; //Back to DETECT 
   \   000003B4   0x200A             MOVS     R0,#+10
   \   000003B6   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000003BA   0x7008             STRB     R0,[R1, #+0]
   \   000003BC   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_27
    174              }
    175              else
    176              {
    177                StateExhSensi = READ_DATA; //Go to Read OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_26: (+1)
   \   000003BE   0x2001             MOVS     R0,#+1
   \   000003C0   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000003C4   0x7008             STRB     R0,[R1, #+0]
    178              }
    179              break;  
    180            }//switch
    181            //----- 
    182            
    183            //DATA_Sensors.Flow_EXH =  150;
    184          }
   \                     ??Flow_SENSIRION_EXH_ReadDATA_27: (+1)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_7: (+1)
   \   000003C6   0xB002             ADD      SP,SP,#+8
   \   000003C8   0xECBD 0x8B02      VPOP     {D8}
   \   000003CC   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 1
   \                     ??StateExhSensi:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
   \                     ??CNT_ERR_Disconnect:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??CNT_ERR_Connect:
   \   00000000                      DS8 1
    185          //---------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    186          void Flow_SENSIRION_EXH_ReadSN(void)
    187          {
   \                     Flow_SENSIRION_EXH_ReadSN: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    188            u8 EXH_DATACMD_Buffer_scale[2] = {0};
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    189            u8 EXH_DATACMD_Buffer_offset[2] = {0};
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    190            u8 EXH_DATACMD_Buffer_SN[6] = {0};
   \   00000010   0xA801             ADD      R0,SP,#+4
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xC006             STM      R0!,{R1,R2}
   \   00000018   0x3808             SUBS     R0,R0,#+8
    191            
    192            u8    ReRead = 0, i=0;
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0x2400             MOVS     R4,#+0
    193            u8    CheckData=0;
   \   0000001E   0x2500             MOVS     R5,#+0
    194            for(ReRead=0;ReRead<10;ReRead++)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0006             MOVS     R6,R0
   \                     ??Flow_SENSIRION_EXH_ReadSN_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E0A             CMP      R6,#+10
   \   00000028   0xDA13             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_1
    195            {
    196              for(u8 wa=0;wa<250;wa++){}; // delay for WarmUp Time
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x28FA             CMP      R0,#+250
   \   00000030   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_3
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_2
    197              if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[2], 2)) == I2C_OK) // Scale
   \                     ??Flow_SENSIRION_EXH_ReadSN_3: (+1)
   \   00000036   0x2302             MOVS     R3,#+2
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable4_16
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   00000042   0x.... 0x....      BL       I2C_Transmit
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD101             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_4
    198              {
    199                ReRead = 20;
   \   0000004A   0x2014             MOVS     R0,#+20
   \   0000004C   0x0006             MOVS     R6,R0
    200              }
    201              
    202            }
   \                     ??Flow_SENSIRION_EXH_ReadSN_4: (+1)
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \   00000050   0xE7E8             B.N      ??Flow_SENSIRION_EXH_ReadSN_0
    203            DATA_Sensors.HWErr.EXHHARDWARE = FALSE;
   \                     ??Flow_SENSIRION_EXH_ReadSN_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000056   0x8FC0             LDRH     R0,[R0, #+62]
   \   00000058   0xF64F 0x61FF      MOVW     R1,#+65279
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000062   0x87C8             STRH     R0,[R1, #+62]
    204            DATA_Sensors.HWErr.EXHSENSOR = FALSE;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000068   0x8FC0             LDRH     R0,[R0, #+62]
   \   0000006A   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000006E   0x4008             ANDS     R0,R1,R0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000074   0x87C8             STRH     R0,[R1, #+62]
    205            if(ReRead >= 20)//OK
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E14             CMP      R6,#+20
   \   0000007A   0xF2C0 0x80A7      BLT.W    ??Flow_SENSIRION_EXH_ReadSN_5
    206            {
    207              CheckData=0;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x0005             MOVS     R5,R0
    208              while(CheckData < 30)
   \                     ??Flow_SENSIRION_EXH_ReadSN_6: (+1)
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x2D1E             CMP      R5,#+30
   \   00000086   0xF280 0x8098      BGE.W    ??Flow_SENSIRION_EXH_ReadSN_7
    209              {
    210                //........1      
    211                if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[2], 2)) == I2C_OK) // Scale
   \   0000008A   0x2302             MOVS     R3,#+2
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable4_16
   \   00000090   0x2180             MOVS     R1,#+128
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   00000096   0x.... 0x....      BL       I2C_Transmit
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xF040 0x8085      BNE.W    ??Flow_SENSIRION_EXH_ReadSN_8
    212                {
    213                  if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_scale ,2)) == I2C_OK)
   \   000000A0   0x2302             MOVS     R3,#+2
   \   000000A2   0xF10D 0x0202      ADD      R2,SP,#+2
   \   000000A6   0x2181             MOVS     R1,#+129
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000000AC   0x.... 0x....      BL       I2C_Receive
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD17A             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    214                  {
    215                    Sensirion_SCALE.Data.HIGHBYT = EXH_DATACMD_Buffer_scale[0];
   \   000000B4   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   000000BC   0x7048             STRB     R0,[R1, #+1]
    216                    Sensirion_SCALE.Data.LOWBYT = EXH_DATACMD_Buffer_scale[1];
   \   000000BE   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    217                    if(Sensirion_SCALE.ALLBYTE > 10 && Sensirion_SCALE.ALLBYTE < 1000)
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000CC   0x8800             LDRH     R0,[R0, #+0]
   \   000000CE   0x280B             CMP      R0,#+11
   \   000000D0   0xDB6B             BLT.N    ??Flow_SENSIRION_EXH_ReadSN_8
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000D6   0x8800             LDRH     R0,[R0, #+0]
   \   000000D8   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000DC   0xDA65             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    218                    {
    219                      if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[4], 2)) == I2C_OK) // Offset
   \   000000DE   0x2302             MOVS     R3,#+2
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable4_17
   \   000000E4   0x2180             MOVS     R1,#+128
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000000EA   0x.... 0x....      BL       I2C_Transmit
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD15B             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    220                      {
    221                        if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_offset ,2)) == I2C_OK)
   \   000000F2   0x2302             MOVS     R3,#+2
   \   000000F4   0xAA00             ADD      R2,SP,#+0
   \   000000F6   0x2181             MOVS     R1,#+129
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   000000FC   0x.... 0x....      BL       I2C_Receive
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD152             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    222                        {
    223                          Sensirion_OFFset.Data.HIGHBYT = EXH_DATACMD_Buffer_offset[0];
   \   00000104   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   0000010C   0x7048             STRB     R0,[R1, #+1]
    224                          Sensirion_OFFset.Data.LOWBYT = EXH_DATACMD_Buffer_offset[1];
   \   0000010E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000116   0x7008             STRB     R0,[R1, #+0]
    225                          if(Sensirion_OFFset.ALLBYTE > 25000 && Sensirion_OFFset.ALLBYTE < 45000)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   0000011C   0x8800             LDRH     R0,[R0, #+0]
   \   0000011E   0xF246 0x11A9      MOVW     R1,#+25001
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xDB41             BLT.N    ??Flow_SENSIRION_EXH_ReadSN_8
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   0000012A   0x8800             LDRH     R0,[R0, #+0]
   \   0000012C   0xF64A 0x71C8      MOVW     R1,#+45000
   \   00000130   0x4288             CMP      R0,R1
   \   00000132   0xDA3A             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    226                          {
    227                            if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[6], 2)) == I2C_OK) // SN
   \   00000134   0x2302             MOVS     R3,#+2
   \   00000136   0x.... 0x....      LDR.W    R2,??DataTable4_19
   \   0000013A   0x2180             MOVS     R1,#+128
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005400
   \   00000140   0x.... 0x....      BL       I2C_Transmit
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD130             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    228                            {
    229                              if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_SN ,6)) == I2C_OK)
   \   00000148   0x2306             MOVS     R3,#+6
   \   0000014A   0xAA01             ADD      R2,SP,#+4
   \   0000014C   0x2181             MOVS     R1,#+129
   \   0000014E   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40005400
   \   00000150   0x.... 0x....      BL       I2C_Receive
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD128             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    230                              {
    231                                Sensirion_SN.Data.BYTE_H = EXH_DATACMD_Buffer_SN[0];
   \   00000158   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable4_20
   \   00000160   0x70C8             STRB     R0,[R1, #+3]
    232                                Sensirion_SN.Data.BYTE_3 = EXH_DATACMD_Buffer_SN[1];
   \   00000162   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable4_20
   \   0000016A   0x7088             STRB     R0,[R1, #+2]
    233                                Sensirion_SN.Data.BYTE_2 = EXH_DATACMD_Buffer_SN[3];
   \   0000016C   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable4_20
   \   00000174   0x7048             STRB     R0,[R1, #+1]
    234                                Sensirion_SN.Data.BYTE_L = EXH_DATACMD_Buffer_SN[4];
   \   00000176   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable4_20
   \   0000017E   0x7008             STRB     R0,[R1, #+0]
    235                                for(i=0;i<5;i++)
   \   00000180   0x2000             MOVS     R0,#+0
   \   00000182   0x0004             MOVS     R4,R0
   \                     ??Flow_SENSIRION_EXH_ReadSN_9: (+1)
   \   00000184   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000186   0x2C05             CMP      R4,#+5
   \   00000188   0xDA0D             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_10
    236                                {
    237                                  I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, EXH_DATACMD_Buffer, 2);// Request Data - 0x1000
   \   0000018A   0x2302             MOVS     R3,#+2
   \   0000018C   0x....             LDR.N    R2,??DataTable4_18
   \   0000018E   0x2180             MOVS     R1,#+128
   \   00000190   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40005400
   \   00000192   0x.... 0x....      BL       I2C_Transmit
    238                                  for(u8 ag=0;ag<250;ag++){};//For Delay
   \   00000196   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_11: (+1)
   \   00000198   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019A   0x28FA             CMP      R0,#+250
   \   0000019C   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_12
   \   0000019E   0x1C40             ADDS     R0,R0,#+1
   \   000001A0   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_11
    239                                }
   \                     ??Flow_SENSIRION_EXH_ReadSN_12: (+1)
   \   000001A2   0x1C64             ADDS     R4,R4,#+1
   \   000001A4   0xE7EE             B.N      ??Flow_SENSIRION_EXH_ReadSN_9
    240                                CheckData = 100;
   \                     ??Flow_SENSIRION_EXH_ReadSN_10: (+1)
   \   000001A6   0x2064             MOVS     R0,#+100
   \   000001A8   0x0005             MOVS     R5,R0
    241                              }
    242                            }
    243                          }
    244                        }
    245                      }
    246                    }
    247                  }
    248                }
    249                for(u8 ag=0;ag<250;ag++){};//For Delay
   \                     ??Flow_SENSIRION_EXH_ReadSN_8: (+1)
   \   000001AA   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_13: (+1)
   \   000001AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AE   0x28FA             CMP      R0,#+250
   \   000001B0   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_14
   \   000001B2   0x1C40             ADDS     R0,R0,#+1
   \   000001B4   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_13
    250                CheckData++;
   \                     ??Flow_SENSIRION_EXH_ReadSN_14: (+1)
   \   000001B6   0x1C6D             ADDS     R5,R5,#+1
   \   000001B8   0xE763             B.N      ??Flow_SENSIRION_EXH_ReadSN_6
    251              }//while 
    252              if(CheckData == 30)
   \                     ??Flow_SENSIRION_EXH_ReadSN_7: (+1)
   \   000001BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001BC   0x2D1E             CMP      R5,#+30
   \   000001BE   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_5
    253                DATA_Sensors.HWErr.EXHHARDWARE = TRUE;//Error
   \   000001C0   0x....             LDR.N    R0,??DataTable4_4
   \   000001C2   0x8FC0             LDRH     R0,[R0, #+62]
   \   000001C4   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   000001C8   0x....             LDR.N    R1,??DataTable4_4
   \   000001CA   0x87C8             STRH     R0,[R1, #+62]
    254            }
    255            DATA_Sensors.Detect_EXH_Sensor = SENSIRIONBOARD_EXH;// Sensirion OK = 0xF1
   \                     ??Flow_SENSIRION_EXH_ReadSN_5: (+1)
   \   000001CC   0x20F1             MOVS     R0,#+241
   \   000001CE   0x....             LDR.N    R1,??DataTable4_4
   \   000001D0   0xF881 0x0054      STRB     R0,[R1, #+84]
    256          }
   \   000001D4   0xBD7F             POP      {R0-R6,PC}       ;; return
    257          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    258          I2C_StatusTypeDef    I2C_Receive(I2C_TypeDef* I2Cx, u8 address,u8* data, u16 count) 
    259          {
   \                     I2C_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    260            I2C_Timeout = I2C_TIMEOUT;
   \   0000000A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000000E   0x....             LDR.N    R1,??DataTable4_21
   \   00000010   0x6008             STR      R0,[R1, #+0]
    261            /* Wait until BUSY flag is reset */
    262            while(I2Cx->SR2 & I2C_SR2_BUSY)
   \                     ??I2C_Receive_0: (+1)
   \   00000012   0x8B20             LDRH     R0,[R4, #+24]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD50E             BPL.N    ??I2C_Receive_1
    263            {
    264              if(--I2C_Timeout == 0x00)
   \   00000018   0x....             LDR.N    R0,??DataTable4_21
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable4_21
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x....             LDR.N    R0,??DataTable4_21
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F3             BNE.N    ??I2C_Receive_0
    265              {
    266                /* Generate Stop */
    267                I2Cx->CR1 |= I2C_CR1_STOP;
   \   0000002A   0x8820             LDRH     R0,[R4, #+0]
   \   0000002C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000030   0x8020             STRH     R0,[R4, #+0]
    268                return I2C_TIMEout;  
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE063             B.N      ??I2C_Receive_2
    269              }
    270            }
    271            //--------------------
    272            /* Enable Acknowledge */
    273            I2Cx->CR1 |= I2C_CR1_ACK;   
   \                     ??I2C_Receive_1: (+1)
   \   00000036   0x8820             LDRH     R0,[R4, #+0]
   \   00000038   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
    274            //------------
    275            /* Generate Start */
    276            I2Cx->CR1 |= I2C_CR1_START; 
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000044   0x8020             STRH     R0,[R4, #+0]
    277            /* Wait until SB flag is set */
    278            I2C_Timeout = I2C_TIMEOUT;
   \   00000046   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000004A   0x....             LDR.N    R1,??DataTable4_21
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    279            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??I2C_Receive_3: (+1)
   \   0000004E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000050   0x07C0             LSLS     R0,R0,#+31
   \   00000052   0xD40E             BMI.N    ??I2C_Receive_4
    280            {
    281              if (--I2C_Timeout == 0x00) 
   \   00000054   0x....             LDR.N    R0,??DataTable4_21
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable4_21
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0x....             LDR.N    R0,??DataTable4_21
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1F3             BNE.N    ??I2C_Receive_3
    282              {
    283                /* Generate Stop */
    284                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000066   0x8820             LDRH     R0,[R4, #+0]
   \   00000068   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    285                return I2C_TIMEout;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE045             B.N      ??I2C_Receive_2
    286              }      
    287            }
    288            ///-------- 
    289            /* Send address with zero last bit */
    290            I2Cx->DR = address;   
   \                     ??I2C_Receive_4: (+1)
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x8225             STRH     R5,[R4, #+16]
    291            /* Wait till finished */
    292            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??I2C_Receive_5: (+1)
   \   00000076   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD40E             BMI.N    ??I2C_Receive_6
    293            {
    294              if (--I2C_Timeout == 0x00) 
   \   0000007C   0x....             LDR.N    R0,??DataTable4_21
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x1E40             SUBS     R0,R0,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable4_21
   \   00000084   0x6008             STR      R0,[R1, #+0]
   \   00000086   0x....             LDR.N    R0,??DataTable4_21
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD1F3             BNE.N    ??I2C_Receive_5
    295              {
    296                /* Generate Stop */
    297                I2Cx->CR1 |= I2C_CR1_STOP;
   \   0000008E   0x8820             LDRH     R0,[R4, #+0]
   \   00000090   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000094   0x8020             STRH     R0,[R4, #+0]
    298                return I2C_TIMEout;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE031             B.N      ??I2C_Receive_2
    299              } 
    300            }
    301            /* Read status register to clear ADDR flag */
    302            I2Cx->SR1;
   \                     ??I2C_Receive_6: (+1)
   \   0000009A   0x8AA0             LDRH     R0,[R4, #+20]
    303            I2Cx->SR2;
   \   0000009C   0x8B20             LDRH     R0,[R4, #+24]
    304            //----------------------
    305            
    306            
    307            for(;count>0;count--)
   \                     ??I2C_Receive_7: (+1)
   \   0000009E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A0   0x2F00             CMP      R7,#+0
   \   000000A2   0xD025             BEQ.N    ??I2C_Receive_8
    308            {
    309              if(count == 1)//end data
   \   000000A4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A6   0x2F01             CMP      R7,#+1
   \   000000A8   0xD104             BNE.N    ??I2C_Receive_9
    310              {
    311                I2Cx->CR1 &= ~I2C_CR1_ACK;
   \   000000AA   0x8820             LDRH     R0,[R4, #+0]
   \   000000AC   0xF64F 0x31FF      MOVW     R1,#+64511
   \   000000B0   0x4008             ANDS     R0,R1,R0
   \   000000B2   0x8020             STRH     R0,[R4, #+0]
    312              }
    313              
    314              /* Wait till not received */
    315              I2C_Timeout = I2C_TIMEOUT;
   \                     ??I2C_Receive_9: (+1)
   \   000000B4   0xF640 0x30B8      MOVW     R0,#+3000
   \   000000B8   0x....             LDR.N    R1,??DataTable4_21
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    316              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)) 
   \                     ??I2C_Receive_10: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable4_22  ;; 0x30040
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       I2C_CheckEvent
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD10E             BNE.N    ??I2C_Receive_11
    317              {
    318                if (--I2C_Timeout == 0x00) 
   \   000000C8   0x....             LDR.N    R0,??DataTable4_21
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable4_21
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0x....             LDR.N    R0,??DataTable4_21
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1F0             BNE.N    ??I2C_Receive_10
    319                {
    320                  /* Generate Stop */
    321                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000DA   0x8820             LDRH     R0,[R4, #+0]
   \   000000DC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000E0   0x8020             STRH     R0,[R4, #+0]
    322                  return I2C_TIMEout;
   \   000000E2   0x2003             MOVS     R0,#+3
   \   000000E4   0xE00B             B.N      ??I2C_Receive_2
    323                }
    324              }    
    325              /* Read data */
    326              *data = I2Cx->DR;  
   \                     ??I2C_Receive_11: (+1)
   \   000000E6   0x8A20             LDRH     R0,[R4, #+16]
   \   000000E8   0x7030             STRB     R0,[R6, #+0]
    327              data++;
   \   000000EA   0x1C76             ADDS     R6,R6,#+1
    328            }
   \   000000EC   0x1E7F             SUBS     R7,R7,#+1
   \   000000EE   0xE7D6             B.N      ??I2C_Receive_7
    329            /* Generate Stop */
    330            I2Cx->CR1 |= I2C_CR1_STOP;
   \                     ??I2C_Receive_8: (+1)
   \   000000F0   0x8820             LDRH     R0,[R4, #+0]
   \   000000F2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000F6   0x8020             STRH     R0,[R4, #+0]
    331            /* Read status register to clear ADDR flag */
    332            I2Cx->SR1;
   \   000000F8   0x8AA0             LDRH     R0,[R4, #+20]
    333            I2Cx->SR2;
   \   000000FA   0x8B20             LDRH     R0,[R4, #+24]
    334            //-----------------
    335            return I2C_OK;  
   \   000000FC   0x2000             MOVS     R0,#+0
   \                     ??I2C_Receive_2: (+1)
   \   000000FE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    336          }
    337          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    338          I2C_StatusTypeDef    I2C_Transmit(I2C_TypeDef* I2Cx, u8 address,u8* data, u16 count) 
    339          {
   \                     I2C_Transmit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    340            I2C_Timeout = I2C_TIMEOUT;
   \   00000004   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000008   0x....             LDR.N    R5,??DataTable4_21
   \   0000000A   0x6028             STR      R0,[R5, #+0]
    341            /* Wait until BUSY flag is reset */
    342            while(I2Cx->SR2 & I2C_SR2_BUSY)
   \                     ??I2C_Transmit_0: (+1)
   \   0000000C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD50E             BPL.N    ??I2C_Transmit_1
    343            {
    344              if(--I2C_Timeout == 0x00)
   \   00000012   0x....             LDR.N    R0,??DataTable4_21
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R5,??DataTable4_21
   \   0000001A   0x6028             STR      R0,[R5, #+0]
   \   0000001C   0x....             LDR.N    R0,??DataTable4_21
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F3             BNE.N    ??I2C_Transmit_0
    345              {
    346                /* Generate Stop */
    347                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002A   0x8020             STRH     R0,[R4, #+0]
    348                return I2C_TIMEout;  
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xE06E             B.N      ??I2C_Transmit_2
    349              }
    350            }
    351            //--------------------
    352            /* Generate Start */
    353            I2Cx->CR1 |= I2C_CR1_START; 
   \                     ??I2C_Transmit_1: (+1)
   \   00000030   0x8820             LDRH     R0,[R4, #+0]
   \   00000032   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    354            /* Wait until SB flag is set */
    355            I2C_Timeout = I2C_TIMEOUT;
   \   00000038   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000003C   0x....             LDR.N    R5,??DataTable4_21
   \   0000003E   0x6028             STR      R0,[R5, #+0]
    356            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??I2C_Transmit_3: (+1)
   \   00000040   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000042   0x07C0             LSLS     R0,R0,#+31
   \   00000044   0xD40E             BMI.N    ??I2C_Transmit_4
    357            {
    358              if (--I2C_Timeout == 0x00) 
   \   00000046   0x....             LDR.N    R0,??DataTable4_21
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R5,??DataTable4_21
   \   0000004E   0x6028             STR      R0,[R5, #+0]
   \   00000050   0x....             LDR.N    R0,??DataTable4_21
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD1F3             BNE.N    ??I2C_Transmit_3
    359              {
    360                /* Generate Stop */
    361                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000058   0x8820             LDRH     R0,[R4, #+0]
   \   0000005A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000005E   0x8020             STRH     R0,[R4, #+0]
    362                return I2C_TIMEout;
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xE054             B.N      ??I2C_Transmit_2
    363              }      
    364            }
    365            //--------------------
    366            I2C_Timeout = I2C_TIMEOUT;
   \                     ??I2C_Transmit_4: (+1)
   \   00000064   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000068   0x....             LDR.N    R5,??DataTable4_21
   \   0000006A   0x6028             STR      R0,[R5, #+0]
    367            /* Send address with zero last bit */
    368            I2Cx->DR = address;   // address & write Bit
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x8221             STRH     R1,[R4, #+16]
    369            /* Wait till finished */
    370            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??I2C_Transmit_5: (+1)
   \   00000070   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000072   0x0780             LSLS     R0,R0,#+30
   \   00000074   0xD40E             BMI.N    ??I2C_Transmit_6
    371            {
    372              if (--I2C_Timeout == 0x00) 
   \   00000076   0x....             LDR.N    R0,??DataTable4_21
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x....             LDR.N    R5,??DataTable4_21
   \   0000007E   0x6028             STR      R0,[R5, #+0]
   \   00000080   0x....             LDR.N    R0,??DataTable4_21
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD1F3             BNE.N    ??I2C_Transmit_5
    373              {
    374                /* Generate Stop */
    375                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000088   0x8820             LDRH     R0,[R4, #+0]
   \   0000008A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000008E   0x8020             STRH     R0,[R4, #+0]
    376                return I2C_TIMEout;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE03C             B.N      ??I2C_Transmit_2
    377              } 
    378            }
    379            /* Read status register to clear ADDR flag */
    380            I2Cx->SR1;
   \                     ??I2C_Transmit_6: (+1)
   \   00000094   0x8AA0             LDRH     R0,[R4, #+20]
    381            I2Cx->SR2;
   \   00000096   0x8B20             LDRH     R0,[R4, #+24]
    382            //----------------------
    383            /* Send data */
    384            for(u16 i=0;i<count;i++)
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??I2C_Transmit_7: (+1)
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000009E   0x4298             CMP      R0,R3
   \   000000A0   0xD230             BCS.N    ??I2C_Transmit_8
    385            {
    386              /* Wait until TXE flag is set */
    387              I2C_Timeout = I2C_TIMEOUT;
   \   000000A2   0xF640 0x35B8      MOVW     R5,#+3000
   \   000000A6   0x....             LDR.N    R6,??DataTable4_21
   \   000000A8   0x6035             STR      R5,[R6, #+0]
    388              while (!(I2Cx->SR1 & I2C_SR1_TXE)) 
   \                     ??I2C_Transmit_9: (+1)
   \   000000AA   0x8AA5             LDRH     R5,[R4, #+20]
   \   000000AC   0x062D             LSLS     R5,R5,#+24
   \   000000AE   0xD40E             BMI.N    ??I2C_Transmit_10
    389              {
    390                if (--I2C_Timeout == 0x00) 
   \   000000B0   0x....             LDR.N    R5,??DataTable4_21
   \   000000B2   0x682D             LDR      R5,[R5, #+0]
   \   000000B4   0x1E6D             SUBS     R5,R5,#+1
   \   000000B6   0x....             LDR.N    R6,??DataTable4_21
   \   000000B8   0x6035             STR      R5,[R6, #+0]
   \   000000BA   0x....             LDR.N    R5,??DataTable4_21
   \   000000BC   0x682D             LDR      R5,[R5, #+0]
   \   000000BE   0x2D00             CMP      R5,#+0
   \   000000C0   0xD1F3             BNE.N    ??I2C_Transmit_9
    391                {
    392                  /* Generate Stop */
    393                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000C2   0x8820             LDRH     R0,[R4, #+0]
   \   000000C4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000C8   0x8020             STRH     R0,[R4, #+0]
    394                  return I2C_TIMEout;
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xE01F             B.N      ??I2C_Transmit_2
    395                }
    396              }    
    397              /* Send I2C data */
    398              I2Cx->DR = *data;
   \                     ??I2C_Transmit_10: (+1)
   \   000000CE   0x7815             LDRB     R5,[R2, #+0]
   \   000000D0   0x8225             STRH     R5,[R4, #+16]
    399              data++;
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
    400              /* Wait until BTF flag is set */
    401              I2C_Timeout = I2C_TIMEOUT;
   \   000000D4   0xF640 0x35B8      MOVW     R5,#+3000
   \   000000D8   0x....             LDR.N    R6,??DataTable4_21
   \   000000DA   0x6035             STR      R5,[R6, #+0]
    402              while (!(I2Cx->SR1 & I2C_SR1_BTF)) 
   \                     ??I2C_Transmit_11: (+1)
   \   000000DC   0x8AA5             LDRH     R5,[R4, #+20]
   \   000000DE   0x076D             LSLS     R5,R5,#+29
   \   000000E0   0xD40E             BMI.N    ??I2C_Transmit_12
    403              {
    404                if (--I2C_Timeout == 0x00) 
   \   000000E2   0x....             LDR.N    R5,??DataTable4_21
   \   000000E4   0x682D             LDR      R5,[R5, #+0]
   \   000000E6   0x1E6D             SUBS     R5,R5,#+1
   \   000000E8   0x....             LDR.N    R6,??DataTable4_21
   \   000000EA   0x6035             STR      R5,[R6, #+0]
   \   000000EC   0x....             LDR.N    R5,??DataTable4_21
   \   000000EE   0x682D             LDR      R5,[R5, #+0]
   \   000000F0   0x2D00             CMP      R5,#+0
   \   000000F2   0xD1F3             BNE.N    ??I2C_Transmit_11
    405                {
    406                  /* Generate Stop */
    407                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000F4   0x8820             LDRH     R0,[R4, #+0]
   \   000000F6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000FA   0x8020             STRH     R0,[R4, #+0]
    408                  return I2C_TIMEout;
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0xE006             B.N      ??I2C_Transmit_2
    409                }
    410              }    
    411            }
   \                     ??I2C_Transmit_12: (+1)
   \   00000100   0x1C40             ADDS     R0,R0,#+1
   \   00000102   0xE7CA             B.N      ??I2C_Transmit_7
    412            //-------------- 
    413            /* Generate Stop */
    414            I2Cx->CR1 |= I2C_CR1_STOP;
   \                     ??I2C_Transmit_8: (+1)
   \   00000104   0x8820             LDRH     R0,[R4, #+0]
   \   00000106   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000010A   0x8020             STRH     R0,[R4, #+0]
    415            return I2C_OK;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??I2C_Transmit_2: (+1)
   \   0000010E   0xBC70             POP      {R4-R6}
   \   00000110   0x4770             BX       LR               ;; return
    416          }
    417          
    418          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    419          u8    Check_Connect (I2C_TypeDef* I2Cx , u8 address)
    420          {
   \                     Check_Connect: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    421            I2C_Timeout = I2C_TIMEOUT;
   \   00000002   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000006   0x....             LDR.N    R3,??DataTable4_21
   \   00000008   0x6018             STR      R0,[R3, #+0]
    422            //--------------------
    423            /* Generate Start */
    424            I2Cx->CR1 |= I2C_CR1_START; 
   \   0000000A   0x8810             LDRH     R0,[R2, #+0]
   \   0000000C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000010   0x8010             STRH     R0,[R2, #+0]
    425            /* Wait until SB flag is set */
    426            I2C_Timeout = I2C_TIMEOUT;
   \   00000012   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000016   0x....             LDR.N    R3,??DataTable4_21
   \   00000018   0x6018             STR      R0,[R3, #+0]
    427            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??Check_Connect_0: (+1)
   \   0000001A   0x8A90             LDRH     R0,[R2, #+20]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD40E             BMI.N    ??Check_Connect_1
    428            {
    429              if (--I2C_Timeout == 0x00) 
   \   00000020   0x....             LDR.N    R0,??DataTable4_21
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R3,??DataTable4_21
   \   00000028   0x6018             STR      R0,[R3, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable4_21
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??Check_Connect_0
    430              {
    431                /* Generate Stop */
    432                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000032   0x8810             LDRH     R0,[R2, #+0]
   \   00000034   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000038   0x8010             STRH     R0,[R2, #+0]
    433                return ERROR10;
   \   0000003A   0x200A             MOVS     R0,#+10
   \   0000003C   0xE01E             B.N      ??Check_Connect_2
    434              }      
    435            }
    436            //--------------------
    437            I2C_Timeout = I2C_TIMEOUT;
   \                     ??Check_Connect_1: (+1)
   \   0000003E   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000042   0x....             LDR.N    R3,??DataTable4_21
   \   00000044   0x6018             STR      R0,[R3, #+0]
    438            /* Send address with zero last bit */
    439            I2Cx->DR = address;   // address & write Bit
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x8211             STRH     R1,[R2, #+16]
    440            /* Wait till finished */
    441            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??Check_Connect_3: (+1)
   \   0000004A   0x8A90             LDRH     R0,[R2, #+20]
   \   0000004C   0x0780             LSLS     R0,R0,#+30
   \   0000004E   0xD40E             BMI.N    ??Check_Connect_4
    442            {
    443              if (--I2C_Timeout == 0x00) 
   \   00000050   0x....             LDR.N    R0,??DataTable4_21
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x....             LDR.N    R3,??DataTable4_21
   \   00000058   0x6018             STR      R0,[R3, #+0]
   \   0000005A   0x....             LDR.N    R0,??DataTable4_21
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1F3             BNE.N    ??Check_Connect_3
    444              {
    445                /* Generate Stop */
    446                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000062   0x8810             LDRH     R0,[R2, #+0]
   \   00000064   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000068   0x8010             STRH     R0,[R2, #+0]
    447                //data_timeout = 0xE1;
    448                return ERROR20;
   \   0000006A   0x2014             MOVS     R0,#+20
   \   0000006C   0xE006             B.N      ??Check_Connect_2
    449              } 
    450            }
    451            /* Read status register to clear ADDR flag */
    452            I2Cx->SR1;
   \                     ??Check_Connect_4: (+1)
   \   0000006E   0x8A90             LDRH     R0,[R2, #+20]
    453            I2Cx->SR2;
   \   00000070   0x8B10             LDRH     R0,[R2, #+24]
    454            
    455            /* Generate Stop */
    456            I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000072   0x8810             LDRH     R0,[R2, #+0]
   \   00000074   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000078   0x8010             STRH     R0,[R2, #+0]
    457            //----------------------
    458            return CONNECTOK50;
   \   0000007A   0x2032             MOVS     R0,#+50
   \                     ??Check_Connect_2: (+1)
   \   0000007C   0x4770             BX       LR               ;; return
    459          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0xC2480000         DC32     0xc2480000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     ??StateExhSensi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     EXH_DMARCV_Buffer_Data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ??CNT_ERR_Disconnect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     DATA_Sensors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     ??CNT_ERR_Connect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     EXHData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     Sensirion_OFFset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     Sensirion_SCALE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0xC0500000         DC32     0xc0500000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x78D4FDF4         DC32     0x78d4fdf4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x409024E9         DC32     0x409024e9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x3F141206         DC32     0x3f141206

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x3FF0DCC6         DC32     0x3ff0dcc6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x........         DC32     TimeDel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_18:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_19:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_20:
   \   00000000   0x........         DC32     Sensirion_SN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_21:
   \   00000000   0x........         DC32     I2C_Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_22:
   \   00000000   0x00030040         DC32     0x30040

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    460          ////----------------------------------------------------
    461          //
    462          //
    463          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Check_Connect
      24   Flow_SENSIRION_EXH_ReadDATA
        24   -> Check_Connect
        24   -> I2C_Receive
        24   -> I2C_Transmit
        24   -> RCC_APB1PeriphResetCmd
        24   -> __aeabi_d2f
        24   -> __aeabi_dadd
        24   -> __aeabi_ddiv
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> init_I2C
      32   Flow_SENSIRION_EXH_ReadSN
        32   -> I2C_Receive
        32   -> I2C_Transmit
      24   I2C_Receive
        24   -> I2C_CheckEvent
      12   I2C_Transmit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_20
       4  ??DataTable4_21
       4  ??DataTable4_22
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
       2  ?_1
       2  ?_2
       8  ?_3
       1  CNT_ERR_Connect
       1  CNT_ERR_Disconnect
     126  Check_Connect
       4  EXHData
      12  EXH_DATACMD_Buffer
       2  EXH_DMARCV_Buffer_Data
     974  Flow_SENSIRION_EXH_ReadDATA
     470  Flow_SENSIRION_EXH_ReadSN
     256  I2C_Receive
       4  I2C_Timeout
     274  I2C_Transmit
       4  Sensirion_OFFset
       4  Sensirion_SCALE
       4  Sensirion_SN
       1  StateExhSensi
       1  TimeDel
       1  delaycnt

 
    26 bytes in section .bss
    13 bytes in section .data
    14 bytes in section .rodata
 2 200 bytes in section .text
 
 2 200 bytes of CODE  memory
    14 bytes of CONST memory
    39 bytes of DATA  memory

Errors: none
Warnings: none
