###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        17/Nov/2025  09:33:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\modules\Source\main.c
#    Command line =  
#        "D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\modules\Source\main.c"
#        -D USE_STDPERIPH_DRIVER -D STM32F40XX -lC "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\List\" -o "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\board\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\app\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2 added\modules\Header\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\" --relaxed_fp
#    List file    =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\Debug\List\main.lst
#    Object file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\Debug\Obj\main.o
#
###############################################################################

D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\modules\Source\main.c
      1          //--------------------------------------------------------------------------|
      2          // SAADAT Co 
      3          // VENTILATOR 
      4          // DEVELOPER : MOJTABA REZAEI 
      5          // 
      6          //--------------------------------------------------------------------------|
      7          #include "main.h" 
      8          
      9          extern  STRUCT_PACKET_PWM           PWM;
     10          
     11          extern  Staruct_TIMER  Timer;
     12          extern          UNION_PACKET_FRQ        SpeedMotor;
     13          extern UNION_PACKET_COM2_SERIAL COM1;
     14          extern  u8  Press_ISR_FLG,Valve_CMD_FLG;
     15          extern UNION_PACKET_COM2_SERIAL COM1;
     16          extern  Struct_ADC_Data             ADC_Data;
     17          extern UNION_PACKET_RCVPWM          RcvPWM;

   \                                 In section .bss, align 4
     18          STRUCT_DATA_A2DSENSORS          DATA_Sensors;
   \                     DATA_Sensors:
   \   00000000                      DS8 12

   \                                 In section .bss, align 2
     19          u16 cntest = 0;
   \                     cntest:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     20          u16 SpeedSet=0;
   \                     SpeedSet:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     21          u16 Flowset=0;
   \                     Flowset:
   \   00000000                      DS8 2

   \                                 In section .data, align 4
     22          float KP=0.1;
   \                     KP:
   \   00000000   0x3DCCCCCD         DC32 3DCCCCCDH

   \                                 In section .data, align 4
     23          float KI=0.3;
   \                     KI:
   \   00000000   0x3E99999A         DC32 3E99999AH

   \                                 In section .data, align 4
     24          float KP_Flow =8;
   \                     KP_Flow:
   \   00000000   0x41000000         DC32 41000000H

   \                                 In section .data, align 4
     25          float KI_Flow =250;
   \                     KI_Flow:
   \   00000000   0x437A0000         DC32 437A0000H

   \                                 In section .bss, align 4
     26          float speedtemp;
   \                     speedtemp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     27          u8 control_mode=0;
   \                     control_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     28          u8 control_valve_mode = 0;
   \                     control_valve_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     29          static int PWM_ind=0;
   \                     PWM_ind:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     30          u8 iteration = 0;
   \                     iteration:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     31          static int cnt_valve = 0;
   \                     cnt_valve:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
     32          int Sample_arr[] = {809,798,677,785,842,865,746,734,994,595,951,963,914,621,689,720,865,637,882,624,854,787,907,880,959,954,720,873,663,592,892,790,781,959,836,839,940};
   \                     Sample_arr:
   \   00000000   0x00000329         DC32 809, 798, 677, 785, 842, 865, 746, 734, 994, 595, 951, 963, 914
   \              0x0000031E   
   \              0x000002A5   
   \              0x00000311   
   \              0x0000034A   
   \              0x00000361   
   \              0x000002EA   
   \              0x000002DE   
   \              0x000003E2   
   \              0x00000253   
   \              0x000003B7   
   \              0x000003C3   
   \              0x00000392   
   \   00000034   0x0000026D         DC32 621, 689, 720, 865, 637, 882, 624, 854, 787, 907, 880, 959, 954
   \              0x000002B1   
   \              0x000002D0   
   \              0x00000361   
   \              0x0000027D   
   \              0x00000372   
   \              0x00000270   
   \              0x00000356   
   \              0x00000313   
   \              0x0000038B   
   \              0x00000370   
   \              0x000003BF   
   \              0x000003BA   
   \   00000068   0x000002D0         DC32 720, 873, 663, 592, 892, 790, 781, 959, 836, 839, 940
   \              0x00000369   
   \              0x00000297   
   \              0x00000250   
   \              0x0000037C   
   \              0x00000316   
   \              0x0000030D   
   \              0x000003BF   
   \              0x00000344   
   \              0x00000347   
   \              0x000003AC   

   \                                 In section .data, align 4
     33          int PWM_arr[] = {2000,3000,4000,5000,6000,7000,8000,2000,3000,4000,5000,6000,7000,8000,2000,3000,4000,5000,6000,
   \                     PWM_arr:
   \   00000000   0x000007D0         DC32 2000, 3000, 4000, 5000, 6000, 7000, 8000, 2000, 3000, 4000, 5000
   \              0x00000BB8   
   \              0x00000FA0   
   \              0x00001388   
   \              0x00001770   
   \              0x00001B58   
   \              0x00001F40   
   \              0x000007D0   
   \              0x00000BB8   
   \              0x00000FA0   
   \              0x00001388   
   \   0000002C   0x00001770         DC32 6000, 7000, 8000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 2000
   \              0x00001B58   
   \              0x00001F40   
   \              0x000007D0   
   \              0x00000BB8   
   \              0x00000FA0   
   \              0x00001388   
   \              0x00001770   
   \              0x00001B58   
   \              0x00001F40   
   \              0x000007D0   
   \   00000058   0x00000BB8         DC32 3000, 4000, 5000, 6000, 7000, 8000, 2000, 3000, 4000, 5000, 6000
   \              0x00000FA0   
   \              0x00001388   
   \              0x00001770   
   \              0x00001B58   
   \              0x00001F40   
   \              0x000007D0   
   \              0x00000BB8   
   \              0x00000FA0   
   \              0x00001388   
   \              0x00001770   
   \   00000084   0x00001B58         DC32 7000, 8000, 2000, 3000
   \              0x00001F40   
   \              0x000007D0   
   \              0x00000BB8   
     34           7000,8000,2000,3000,4000,5000,6000,7000,8000,2000,3000,4000,5000,6000,7000,8000,2000,3000};
     35          

   \                                 In section .data, align 4
     36          float PWM_Array[] = {0,175,827,3340,85,409,600,408,0};
   \                     PWM_Array:
   \   00000000   0x00000000         DC32 0H, 432F0000H, 444EC000H, 4550C000H, 42AA0000H, 43CC8000H
   \              0x432F0000   
   \              0x444EC000   
   \              0x4550C000   
   \              0x42AA0000   
   \              0x43CC8000   
   \   00000018   0x44160000         DC32 44160000H, 43CC0000H, 0H
   \              0x43CC0000   
   \              0x00000000   

   \                                 In section .data, align 4
     37          STRUCT_PACKET_PWM           PWMS = {
   \                     PWMS:
   \   00000000   0x0000 0x0000      DC16 0, 0, 2, 0
   \              0x0002 0x0000
   \   00000008   0x14 0x00          DC8 20, 0, 0, 0
   \              0x00 0x00    
     38            .DELAY = 2,
     39            .STEP = 20
     40              
     41          };
     42          //--------------------------------------------------------------------------|

   \                                 In section .text, align 4, keep-with-next
     43          int main(void)
     44          {
   \                     main: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     45            u8      PWM_zero=0;
   \   00000002   0x2400             MOVS     R4,#+0
     46            Init();
   \   00000004   0x.... 0x....      BL       Init
     47            
     48            while(1)
     49            {  
     50              
     51              
     52              IWDG->KR = KR_KEY_RELOAD;                 /* Reset Watchdog */
   \                     ??main_0: (+1)
   \   00000008   0xF64A 0x20AA      MOVW     R0,#+43690
   \   0000000C   0xF8DF 0x1454      LDR.W    R1,??main_1+0x4  ;; 0x40003000
   \   00000010   0x6008             STR      R0,[R1, #+0]
     53              //--------------------
     54              
     55              if(PWMS.TARGET > 0)
   \   00000012   0xF8DF 0x0454      LDR.W    R0,??main_1+0x8
   \   00000016   0x8800             LDRH     R0,[R0, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??main_2
     56              {
     57                if(PWM_zero == 0)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD127             BNE.N    ??main_3
     58                {
     59                  PWM_zero = 1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x0004             MOVS     R4,R0
     60                  HallSensor_Service();
   \   00000026   0x.... 0x....      BL       HallSensor_Service
   \   0000002A   0xE022             B.N      ??main_3
     61                }
     62              }
     63              else
     64              {
     65                PWM_zero = 0;
   \                     ??main_2: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0004             MOVS     R4,R0
     66                PWM_Timer1(M1_CH1,STOP);
   \   00000030   0x2114             MOVS     R1,#+20
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       PWM_Timer1
     67                PWM_Timer1(M2_CH2,STOP);
   \   00000038   0x2114             MOVS     R1,#+20
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x.... 0x....      BL       PWM_Timer1
     68                PWM_Timer1(M3_CH3,STOP);
   \   00000040   0x2114             MOVS     R1,#+20
   \   00000042   0x2003             MOVS     R0,#+3
   \   00000044   0x.... 0x....      BL       PWM_Timer1
     69                GPIO_WriteBit(M1_L_PORT,M1_L_PIN,Bit_RESET);
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xF44F 0x7180      MOV      R1,#+256
   \   0000004E   0xF8DF 0x041C      LDR.W    R0,??main_1+0xC  ;; 0x40021000
   \   00000052   0x.... 0x....      BL       GPIO_WriteBit
     70                GPIO_WriteBit(M2_L_PORT,M2_L_PIN,Bit_RESET);
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0xF44F 0x6180      MOV      R1,#+1024
   \   0000005C   0xF8DF 0x040C      LDR.W    R0,??main_1+0xC  ;; 0x40021000
   \   00000060   0x.... 0x....      BL       GPIO_WriteBit
     71                GPIO_WriteBit(M3_L_PORT,M3_L_PIN,Bit_RESET);
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0xF44F 0x5180      MOV      R1,#+4096
   \   0000006A   0xF8DF 0x0400      LDR.W    R0,??main_1+0xC  ;; 0x40021000
   \   0000006E   0x.... 0x....      BL       GPIO_WriteBit
     72              }
     73              //--------------------
     74              if(Timer.Flg_2ms5Sensor == TRUE)
   \                     ??main_3: (+1)
   \   00000072   0xF8DF 0x03FC      LDR.W    R0,??main_1+0x10
   \   00000076   0x7D80             LDRB     R0,[R0, #+22]
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD161             BNE.N    ??main_4
     75              {
     76                if ( cntest < 60000)
   \   0000007C   0xF8DF 0x03F4      LDR.W    R0,??main_1+0x14
   \   00000080   0x8800             LDRH     R0,[R0, #+0]
   \   00000082   0xF64E 0x2160      MOVW     R1,#+60000
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDA07             BGE.N    ??main_5
     77                { cntest++;
   \   0000008A   0xF8DF 0x03E8      LDR.W    R0,??main_1+0x14
   \   0000008E   0x8800             LDRH     R0,[R0, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0xF8DF 0x13E0      LDR.W    R1,??main_1+0x14
   \   00000096   0x8008             STRH     R0,[R1, #+0]
   \   00000098   0xE003             B.N      ??main_6
     78                }
     79                else
     80                {
     81                  cntest = 0;
   \                     ??main_5: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF8DF 0x13D4      LDR.W    R1,??main_1+0x14
   \   000000A0   0x8008             STRH     R0,[R1, #+0]
     82                }
     83                COM1.Data.P01 = (u16) cntest;
   \                     ??main_6: (+1)
   \   000000A2   0xF8DF 0x03D0      LDR.W    R0,??main_1+0x14
   \   000000A6   0x8800             LDRH     R0,[R0, #+0]
   \   000000A8   0xF8DF 0x13CC      LDR.W    R1,??main_1+0x18
   \   000000AC   0xF8A1 0x0003      STRH     R0,[R1, #+3]
     84                COM1.Data.P02 = (u16) DATA_Sensors.Flow_EXH;
   \   000000B0   0xF8DF 0x03C8      LDR.W    R0,??main_1+0x1C
   \   000000B4   0x8840             LDRH     R0,[R0, #+2]
   \   000000B6   0xF8DF 0x13C0      LDR.W    R1,??main_1+0x18
   \   000000BA   0xF8A1 0x0005      STRH     R0,[R1, #+5]
     85                COM1.Data.P03 = (u16) DATA_Sensors.Valve_CMD;
   \   000000BE   0xF8DF 0x03BC      LDR.W    R0,??main_1+0x1C
   \   000000C2   0x8880             LDRH     R0,[R0, #+4]
   \   000000C4   0xF8DF 0x13B0      LDR.W    R1,??main_1+0x18
   \   000000C8   0xF8A1 0x0007      STRH     R0,[R1, #+7]
     86                COM1.Data.P04 = (u16) speedtemp;
   \   000000CC   0xF8DF 0x03B0      LDR.W    R0,??main_1+0x20
   \   000000D0   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000D4   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   000000D8   0xEE10 0x0A10      VMOV     R0,S0
   \   000000DC   0xF8DF 0x1398      LDR.W    R1,??main_1+0x18
   \   000000E0   0xF8A1 0x0009      STRH     R0,[R1, #+9]
     87                COM1.Data.P05 = (u16) DATA_Sensors.Press_INH;
   \   000000E4   0xF8DF 0x0394      LDR.W    R0,??main_1+0x1C
   \   000000E8   0x8800             LDRH     R0,[R0, #+0]
   \   000000EA   0xF8DF 0x138C      LDR.W    R1,??main_1+0x18
   \   000000EE   0xF8A1 0x000B      STRH     R0,[R1, #+11]
     88                COM1.Data.P06 = (u16) 0x0000;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF8DF 0x1380      LDR.W    R1,??main_1+0x18
   \   000000F8   0xF8A1 0x000D      STRH     R0,[R1, #+13]
     89                COM1.Data.P07 = (u16) 0x0000;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF8DF 0x1378      LDR.W    R1,??main_1+0x18
   \   00000102   0xF8A1 0x000F      STRH     R0,[R1, #+15]
     90                COM1.Data.P08 = (u16) 0x0000;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0xF8DF 0x136C      LDR.W    R1,??main_1+0x18
   \   0000010C   0xF8A1 0x0011      STRH     R0,[R1, #+17]
     91                //GPIO_ToggleBits(LED2_PORT, LED2_PIN);
     92                //SendCOM2(0);
     93                
     94                Timer.Flg_2ms5Sensor = FALSE;
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF8DF 0x135C      LDR.W    R1,??main_1+0x10
   \   00000116   0x7588             STRB     R0,[R1, #+22]
     95                //      //	  Read_Press_INH_EXH();
     96                GPIO_ResetBits(PRESSINHCS_PORT , PRESSINHCS_PIN);       // CS LOW
   \   00000118   0xF44F 0x5180      MOV      R1,#+4096
   \   0000011C   0xF8DF 0x0364      LDR.W    R0,??main_1+0x24  ;; 0x40020400
   \   00000120   0x.... 0x....      BL       GPIO_ResetBits
     97                SPI_I2S_SendData(PRESS_INH,0xAA55);      // 0XAA55 is temporary data for read from SPI
   \   00000124   0xF64A 0x2155      MOVW     R1,#+43605
   \   00000128   0xF8DF 0x035C      LDR.W    R0,??main_1+0x28  ;; 0x40003800
   \   0000012C   0x.... 0x....      BL       SPI_I2S_SendData
     98                SPI_I2S_ITConfig(PRESS_INH , SPI_IT_RXNE , ENABLE );
   \   00000130   0x2201             MOVS     R2,#+1
   \   00000132   0x2160             MOVS     R1,#+96
   \   00000134   0xF8DF 0x0350      LDR.W    R0,??main_1+0x28  ;; 0x40003800
   \   00000138   0x.... 0x....      BL       SPI_I2S_ITConfig
     99                //      //------
    100                Flow_SENSIRION_EXH_ReadDATA();
   \   0000013C   0x.... 0x....      BL       Flow_SENSIRION_EXH_ReadDATA
    101                //SendCOM2(0);
    102          
    103                
    104              }
    105              //---------------------
    106              if(Press_ISR_FLG == TRUE)
   \                     ??main_4: (+1)
   \   00000140   0xF8DF 0x0348      LDR.W    R0,??main_1+0x2C
   \   00000144   0x7800             LDRB     R0,[R0, #+0]
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD105             BNE.N    ??main_7
    107              {
    108                Press_ISR_FLG = FALSE;
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF8DF 0x133C      LDR.W    R1,??main_1+0x2C
   \   00000150   0x7008             STRB     R0,[R1, #+0]
    109                Read_Press_INH_EXH(); 
   \   00000152   0x.... 0x....      BL       Read_Press_INH_EXH
    110              }
    111              //---------------------
    112              if(Valve_CMD_FLG == TRUE)
   \                     ??main_7: (+1)
   \   00000156   0xF8DF 0x0338      LDR.W    R0,??main_1+0x30
   \   0000015A   0x7800             LDRB     R0,[R0, #+0]
   \   0000015C   0x2801             CMP      R0,#+1
   \   0000015E   0xD10D             BNE.N    ??main_8
    113              {
    114                SetPWM_EXH(DATA_Sensors.Valve_CMD);
   \   00000160   0xF8DF 0x0318      LDR.W    R0,??main_1+0x1C
   \   00000164   0x8880             LDRH     R0,[R0, #+4]
   \   00000166   0x.... 0x....      BL       SetPWM_EXH
    115                SetPWM_EXH2(DATA_Sensors.Valve2_CMD);
   \   0000016A   0xF8DF 0x0310      LDR.W    R0,??main_1+0x1C
   \   0000016E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000170   0x.... 0x....      BL       SetPWM_EXH2
    116          
    117                Valve_CMD_FLG = FALSE;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF8DF 0x1318      LDR.W    R1,??main_1+0x30
   \   0000017A   0x7008             STRB     R0,[R1, #+0]
    118              }
    119              //---------------------
    120              if(Timer.Flg_50ms)
   \                     ??main_8: (+1)
   \   0000017C   0xF8DF 0x02F0      LDR.W    R0,??main_1+0x10
   \   00000180   0x7C00             LDRB     R0,[R0, #+16]
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD002             BEQ.N    ??main_9
    121              {
    122                Timer.Flg_50ms = FALSE;
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x49B9             LDR.N    R1,??main_1+0x10
   \   0000018A   0x7408             STRB     R0,[R1, #+16]
    123                //SendCOM2(0);
    124                // Algorithm_50ms();
    125                //ReachToTarget();
    126              }
    127              if(Timer.Flg_2ms5)
   \                     ??main_9: (+1)
   \   0000018C   0x48B8             LDR.N    R0,??main_1+0x10
   \   0000018E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000190   0x2800             CMP      R0,#+0
   \   00000192   0xF000 0x8106      BEQ.W    ??main_10
    128              {
    129                //SendCOM2(0);
    130                Timer.Flg_2ms5 = FALSE;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x49B5             LDR.N    R1,??main_1+0x10
   \   0000019A   0x7348             STRB     R0,[R1, #+13]
    131                if(SpeedMotor.TIMER_CNT>1000)
   \   0000019C   0xF8DF 0x02F4      LDR.W    R0,??main_1+0x34
   \   000001A0   0x6800             LDR      R0,[R0, #+0]
   \   000001A2   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000001A6   0xD916             BLS.N    ??main_11
    132                  speedtemp = 60/(SpeedMotor.TIMER_CNT*11.904*0.000000001);
   \   000001A8   0x48BA             LDR.N    R0,??main_1+0x34
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0x.... 0x....      BL       __aeabi_ui2d
   \   000001B0   0x4AB9             LDR.N    R2,??main_1+0x38  ;; 0x16872b02
   \   000001B2   0x4BBA             LDR.N    R3,??main_1+0x3C  ;; 0x4027ced9
   \   000001B4   0x.... 0x....      BL       __aeabi_dmul
   \   000001B8   0x4AB9             LDR.N    R2,??main_1+0x40  ;; 0xe826d695
   \   000001BA   0x4BBA             LDR.N    R3,??main_1+0x44  ;; 0x3e112e0b
   \   000001BC   0x.... 0x....      BL       __aeabi_dmul
   \   000001C0   0x0002             MOVS     R2,R0
   \   000001C2   0x000B             MOVS     R3,R1
   \   000001C4   0x2000             MOVS     R0,#+0
   \   000001C6   0x49B8             LDR.N    R1,??main_1+0x48  ;; 0x404e0000
   \   000001C8   0x.... 0x....      BL       __aeabi_ddiv
   \   000001CC   0x.... 0x....      BL       __aeabi_d2f
   \   000001D0   0x49AB             LDR.N    R1,??main_1+0x20
   \   000001D2   0x6008             STR      R0,[R1, #+0]
   \   000001D4   0xE002             B.N      ??main_12
    133                else
    134                  speedtemp =0;
   \                     ??main_11: (+1)
   \   000001D6   0x48AA             LDR.N    R0,??main_1+0x20
   \   000001D8   0x2100             MOVS     R1,#+0
   \   000001DA   0x6001             STR      R1,[R0, #+0]
    135                //COM1.Data.P01 = (u16) (PWMS.CURRENT);
    136                //COM1.Data.P02 = (u16) (speedtemp);
    137                if (RcvPWM.DATA.Control_mode==0)
   \                     ??main_12: (+1)
   \   000001DC   0x48B3             LDR.N    R0,??main_1+0x4C
   \   000001DE   0x7B00             LDRB     R0,[R0, #+12]
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD131             BNE.N    ??main_13
    138                {
    139                  PWMS.TARGET = Control(RcvPWM.DATA.Speed_Setpoint, SpeedMotor.TIMER_CNT, (float)(RcvPWM.DATA.KP_Speed)/100 ,(float)(RcvPWM.DATA.KI_Speed)/100);
   \   000001E4   0x48B1             LDR.N    R0,??main_1+0x4C
   \   000001E6   0x8840             LDRH     R0,[R0, #+2]
   \   000001E8   0xEE00 0x0A10      VMOV     S0,R0
   \   000001EC   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000001F0   0xEDDF 0x0A9B      VLDR.W   S1,??main_1      ;; 0x42c80000
   \   000001F4   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   000001F8   0x48AC             LDR.N    R0,??main_1+0x4C
   \   000001FA   0x8800             LDRH     R0,[R0, #+0]
   \   000001FC   0xEE00 0x0A10      VMOV     S0,R0
   \   00000200   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000204   0xED9F 0x1A96      VLDR.W   S2,??main_1      ;; 0x42c80000
   \   00000208   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \   0000020C   0x48A1             LDR.N    R0,??main_1+0x34
   \   0000020E   0x6801             LDR      R1,[R0, #+0]
   \   00000210   0x48A6             LDR.N    R0,??main_1+0x4C
   \   00000212   0x8880             LDRH     R0,[R0, #+4]
   \   00000214   0x.... 0x....      BL       Control
   \   00000218   0x4993             LDR.N    R1,??main_1+0x8
   \   0000021A   0x8008             STRH     R0,[R1, #+0]
    140                  DATA_Sensors.Valve_CMD = Control_Flow( RcvPWM.DATA.Flow_Setpoint , ((float) (DATA_Sensors.Flow_EXH)/100) ,KP_Flow, KI_Flow);
   \   0000021C   0x48A4             LDR.N    R0,??main_1+0x50
   \   0000021E   0xED90 0x1A00      VLDR     S2,[R0, #0]
   \   00000222   0x48A4             LDR.N    R0,??main_1+0x54
   \   00000224   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   00000228   0x4894             LDR.N    R0,??main_1+0x1C
   \   0000022A   0x8840             LDRH     R0,[R0, #+2]
   \   0000022C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000230   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000234   0xEDDF 0x1A8A      VLDR.W   S3,??main_1      ;; 0x42c80000
   \   00000238   0xEE80 0x0A21      VDIV.F32 S0,S0,S3
   \   0000023C   0x489B             LDR.N    R0,??main_1+0x4C
   \   0000023E   0x8940             LDRH     R0,[R0, #+10]
   \   00000240   0x.... 0x....      BL       Control_Flow
   \   00000244   0x498D             LDR.N    R1,??main_1+0x1C
   \   00000246   0x8088             STRH     R0,[R1, #+4]
    141                    
    142                }
    143                
    144                if (RcvPWM.DATA.Control_mode==1)
   \                     ??main_13: (+1)
   \   00000248   0x4898             LDR.N    R0,??main_1+0x4C
   \   0000024A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000024C   0x2801             CMP      R0,#+1
   \   0000024E   0xD11F             BNE.N    ??main_14
    145                {
    146                 PWMS.TARGET = Control(RcvPWM.DATA.Speed_Setpoint,SpeedMotor.TIMER_CNT,(float)(RcvPWM.DATA.KP_Speed)/100,(float)(RcvPWM.DATA.KI_Speed)/100); 
   \   00000250   0x4896             LDR.N    R0,??main_1+0x4C
   \   00000252   0x8840             LDRH     R0,[R0, #+2]
   \   00000254   0xEE00 0x0A10      VMOV     S0,R0
   \   00000258   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   0000025C   0xEDDF 0x0A80      VLDR.W   S1,??main_1      ;; 0x42c80000
   \   00000260   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   00000264   0x4891             LDR.N    R0,??main_1+0x4C
   \   00000266   0x8800             LDRH     R0,[R0, #+0]
   \   00000268   0xEE00 0x0A10      VMOV     S0,R0
   \   0000026C   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000270   0xED9F 0x1A7B      VLDR.W   S2,??main_1      ;; 0x42c80000
   \   00000274   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \   00000278   0x4886             LDR.N    R0,??main_1+0x34
   \   0000027A   0x6801             LDR      R1,[R0, #+0]
   \   0000027C   0x488B             LDR.N    R0,??main_1+0x4C
   \   0000027E   0x8880             LDRH     R0,[R0, #+4]
   \   00000280   0x.... 0x....      BL       Control
   \   00000284   0x4978             LDR.N    R1,??main_1+0x8
   \   00000286   0x8008             STRH     R0,[R1, #+0]
    147                 DATA_Sensors.Valve_CMD =  RcvPWM.DATA.Flow_Setpoint;
   \   00000288   0x4888             LDR.N    R0,??main_1+0x4C
   \   0000028A   0x8940             LDRH     R0,[R0, #+10]
   \   0000028C   0x497B             LDR.N    R1,??main_1+0x1C
   \   0000028E   0x8088             STRH     R0,[R1, #+4]
    148                }
    149                if (RcvPWM.DATA.Control_mode==3)
   \                     ??main_14: (+1)
   \   00000290   0x4886             LDR.N    R0,??main_1+0x4C
   \   00000292   0x7B00             LDRB     R0,[R0, #+12]
   \   00000294   0x2803             CMP      R0,#+3
   \   00000296   0xD111             BNE.N    ??main_15
    150                {
    151                 PWMS.TARGET = Control(SpeedSet,SpeedMotor.TIMER_CNT,(float)(KP),(float)(KI)); 
   \   00000298   0x4887             LDR.N    R0,??main_1+0x58
   \   0000029A   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   0000029E   0x4887             LDR.N    R0,??main_1+0x5C
   \   000002A0   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000002A4   0x487B             LDR.N    R0,??main_1+0x34
   \   000002A6   0x6801             LDR      R1,[R0, #+0]
   \   000002A8   0x4885             LDR.N    R0,??main_1+0x60
   \   000002AA   0x8800             LDRH     R0,[R0, #+0]
   \   000002AC   0x.... 0x....      BL       Control
   \   000002B0   0x496D             LDR.N    R1,??main_1+0x8
   \   000002B2   0x8008             STRH     R0,[R1, #+0]
    152                 DATA_Sensors.Valve_CMD =  Flowset;
   \   000002B4   0x4883             LDR.N    R0,??main_1+0x64
   \   000002B6   0x8800             LDRH     R0,[R0, #+0]
   \   000002B8   0x4970             LDR.N    R1,??main_1+0x1C
   \   000002BA   0x8088             STRH     R0,[R1, #+4]
    153                }
    154                // Algorithm_50ms();
    155                //ReachToTarget();
    156                
    157                
    158                if (control_mode == 3)
   \                     ??main_15: (+1)
   \   000002BC   0x4882             LDR.N    R0,??main_1+0x68
   \   000002BE   0x7800             LDRB     R0,[R0, #+0]
   \   000002C0   0x2803             CMP      R0,#+3
   \   000002C2   0xD125             BNE.N    ??main_16
    159                {
    160                  if (iteration == 36)
   \   000002C4   0x4881             LDR.N    R0,??main_1+0x6C
   \   000002C6   0x7800             LDRB     R0,[R0, #+0]
   \   000002C8   0x2824             CMP      R0,#+36
   \   000002CA   0xD103             BNE.N    ??main_17
    161                  {
    162                    PWMS.TARGET = 0; 
   \   000002CC   0x2000             MOVS     R0,#+0
   \   000002CE   0x4966             LDR.N    R1,??main_1+0x8
   \   000002D0   0x8008             STRH     R0,[R1, #+0]
   \   000002D2   0xE01D             B.N      ??main_16
    163                  }
    164                  
    165                  else
    166                    
    167                  {
    168                    if (PWM_ind <Sample_arr[iteration])
   \                     ??main_17: (+1)
   \   000002D4   0x487E             LDR.N    R0,??main_1+0x70
   \   000002D6   0x6800             LDR      R0,[R0, #+0]
   \   000002D8   0x497E             LDR.N    R1,??main_1+0x74
   \   000002DA   0x4A7C             LDR.N    R2,??main_1+0x6C
   \   000002DC   0x7812             LDRB     R2,[R2, #+0]
   \   000002DE   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   000002E2   0x4288             CMP      R0,R1
   \   000002E4   0xDA0C             BGE.N    ??main_18
    169                    {
    170                      PWMS.TARGET = PWM_arr[iteration];
   \   000002E6   0x487C             LDR.N    R0,??main_1+0x78
   \   000002E8   0x4978             LDR.N    R1,??main_1+0x6C
   \   000002EA   0x7809             LDRB     R1,[R1, #+0]
   \   000002EC   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   000002F0   0x495D             LDR.N    R1,??main_1+0x8
   \   000002F2   0x8008             STRH     R0,[R1, #+0]
    171                      PWM_ind++;
   \   000002F4   0x4876             LDR.N    R0,??main_1+0x70
   \   000002F6   0x6800             LDR      R0,[R0, #+0]
   \   000002F8   0x1C40             ADDS     R0,R0,#+1
   \   000002FA   0x4975             LDR.N    R1,??main_1+0x70
   \   000002FC   0x6008             STR      R0,[R1, #+0]
   \   000002FE   0xE007             B.N      ??main_16
    172                    }
    173                    else
    174                    {
    175                      PWM_ind = 0 ;
   \                     ??main_18: (+1)
   \   00000300   0x2000             MOVS     R0,#+0
   \   00000302   0x4973             LDR.N    R1,??main_1+0x70
   \   00000304   0x6008             STR      R0,[R1, #+0]
    176                      iteration++;
   \   00000306   0x4871             LDR.N    R0,??main_1+0x6C
   \   00000308   0x7800             LDRB     R0,[R0, #+0]
   \   0000030A   0x1C40             ADDS     R0,R0,#+1
   \   0000030C   0x496F             LDR.N    R1,??main_1+0x6C
   \   0000030E   0x7008             STRB     R0,[R1, #+0]
    177                      
    178                    }
    179                  }
    180                  
    181                  
    182                  
    183                }
    184                if(RcvPWM.DATA.Control_mode== 4)
   \                     ??main_16: (+1)
   \   00000310   0x4866             LDR.N    R0,??main_1+0x4C
   \   00000312   0x7B00             LDRB     R0,[R0, #+12]
   \   00000314   0x2804             CMP      R0,#+4
   \   00000316   0xD144             BNE.N    ??main_10
    185                {
    186                  PWMS.TARGET = Control(RcvPWM.DATA.Speed_Setpoint,SpeedMotor.TIMER_CNT,(float)(RcvPWM.DATA.KP_Speed)/100,(float)(RcvPWM.DATA.KI_Speed)/100); 
   \   00000318   0x4864             LDR.N    R0,??main_1+0x4C
   \   0000031A   0x8840             LDRH     R0,[R0, #+2]
   \   0000031C   0xEE00 0x0A10      VMOV     S0,R0
   \   00000320   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000324   0xEDDF 0x0A4E      VLDR.W   S1,??main_1      ;; 0x42c80000
   \   00000328   0xEEC0 0x0A20      VDIV.F32 S1,S0,S1
   \   0000032C   0x485F             LDR.N    R0,??main_1+0x4C
   \   0000032E   0x8800             LDRH     R0,[R0, #+0]
   \   00000330   0xEE00 0x0A10      VMOV     S0,R0
   \   00000334   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   00000338   0xED9F 0x1A49      VLDR.W   S2,??main_1      ;; 0x42c80000
   \   0000033C   0xEE80 0x0A01      VDIV.F32 S0,S0,S2
   \   00000340   0x4854             LDR.N    R0,??main_1+0x34
   \   00000342   0x6801             LDR      R1,[R0, #+0]
   \   00000344   0x4859             LDR.N    R0,??main_1+0x4C
   \   00000346   0x8880             LDRH     R0,[R0, #+4]
   \   00000348   0x.... 0x....      BL       Control
   \   0000034C   0x4946             LDR.N    R1,??main_1+0x8
   \   0000034E   0x8008             STRH     R0,[R1, #+0]
    187                  if (cnt_valve==12000)
   \   00000350   0x4862             LDR.N    R0,??main_1+0x7C
   \   00000352   0x6800             LDR      R0,[R0, #+0]
   \   00000354   0xF642 0x61E0      MOVW     R1,#+12000
   \   00000358   0x4288             CMP      R0,R1
   \   0000035A   0xD102             BNE.N    ??main_19
    188                  {cnt_valve = 0;}
   \   0000035C   0x2000             MOVS     R0,#+0
   \   0000035E   0x495F             LDR.N    R1,??main_1+0x7C
   \   00000360   0x6008             STR      R0,[R1, #+0]
    189                  if (cnt_valve<12001)
   \                     ??main_19: (+1)
   \   00000362   0x485E             LDR.N    R0,??main_1+0x7C
   \   00000364   0x6800             LDR      R0,[R0, #+0]
   \   00000366   0xF642 0x61E1      MOVW     R1,#+12001
   \   0000036A   0x4288             CMP      R0,R1
   \   0000036C   0xDA19             BGE.N    ??main_10
    190                  {
    191                   cnt_valve++; 
   \   0000036E   0x485B             LDR.N    R0,??main_1+0x7C
   \   00000370   0x6800             LDR      R0,[R0, #+0]
   \   00000372   0x1C40             ADDS     R0,R0,#+1
   \   00000374   0x4959             LDR.N    R1,??main_1+0x7C
   \   00000376   0x6008             STR      R0,[R1, #+0]
    192                  if (cnt_valve<5001)
   \   00000378   0x4858             LDR.N    R0,??main_1+0x7C
   \   0000037A   0x6800             LDR      R0,[R0, #+0]
   \   0000037C   0xF241 0x3189      MOVW     R1,#+5001
   \   00000380   0x4288             CMP      R0,R1
   \   00000382   0xDA05             BGE.N    ??main_20
    193                  {
    194               
    195                 DATA_Sensors.Valve_CMD++;
   \   00000384   0x483D             LDR.N    R0,??main_1+0x1C
   \   00000386   0x8880             LDRH     R0,[R0, #+4]
   \   00000388   0x1C40             ADDS     R0,R0,#+1
   \   0000038A   0x493C             LDR.N    R1,??main_1+0x1C
   \   0000038C   0x8088             STRH     R0,[R1, #+4]
   \   0000038E   0xE008             B.N      ??main_10
    196                  }
    197                  else
    198                  {
    199                    if (DATA_Sensors.Valve_CMD > 0 )
   \                     ??main_20: (+1)
   \   00000390   0x483A             LDR.N    R0,??main_1+0x1C
   \   00000392   0x8880             LDRH     R0,[R0, #+4]
   \   00000394   0x2800             CMP      R0,#+0
   \   00000396   0xD004             BEQ.N    ??main_10
    200                    {DATA_Sensors.Valve_CMD--; }
   \   00000398   0x4838             LDR.N    R0,??main_1+0x1C
   \   0000039A   0x8880             LDRH     R0,[R0, #+4]
   \   0000039C   0x1E40             SUBS     R0,R0,#+1
   \   0000039E   0x4937             LDR.N    R1,??main_1+0x1C
   \   000003A0   0x8088             STRH     R0,[R1, #+4]
    201                  }
    202                  }
    203                }
    204              }
    205              
    206              //-----------
    207              if(Timer.Flg_1sec)
   \                     ??main_10: (+1)
   \   000003A2   0x4833             LDR.N    R0,??main_1+0x10
   \   000003A4   0x7D00             LDRB     R0,[R0, #+20]
   \   000003A6   0x2800             CMP      R0,#+0
   \   000003A8   0xD006             BEQ.N    ??main_21
    208              {
    209                Timer.Flg_1sec = FALSE;
   \   000003AA   0x2000             MOVS     R0,#+0
   \   000003AC   0x4930             LDR.N    R1,??main_1+0x10
   \   000003AE   0x7508             STRB     R0,[R1, #+20]
    210                GPIO_ToggleBits(LED1_PORT, LED1_PIN);
   \   000003B0   0x2104             MOVS     R1,#+4
   \   000003B2   0x482E             LDR.N    R0,??main_1+0xC  ;; 0x40021000
   \   000003B4   0x.... 0x....      BL       GPIO_ToggleBits
    211                
    212              } 
    213              if(Timer.Flg_2sec)
   \                     ??main_21: (+1)
   \   000003B8   0x482D             LDR.N    R0,??main_1+0x10
   \   000003BA   0x7D40             LDRB     R0,[R0, #+21]
   \   000003BC   0x2800             CMP      R0,#+0
   \   000003BE   0xF43F 0xAE23      BEQ.W    ??main_0
    214              {
    215                if (control_mode==2)
   \   000003C2   0x4841             LDR.N    R0,??main_1+0x68
   \   000003C4   0x7800             LDRB     R0,[R0, #+0]
   \   000003C6   0x2802             CMP      R0,#+2
   \   000003C8   0xD146             BNE.N    ??main_22
    216                {  
    217                  if  (PWMS.TARGET<95)
   \   000003CA   0x4827             LDR.N    R0,??main_1+0x8
   \   000003CC   0x8800             LDRH     R0,[R0, #+0]
   \   000003CE   0x285F             CMP      R0,#+95
   \   000003D0   0xDA05             BGE.N    ??main_23
    218                  {PWMS.TARGET = PWMS.TARGET + 10; }
   \   000003D2   0x4825             LDR.N    R0,??main_1+0x8
   \   000003D4   0x8800             LDRH     R0,[R0, #+0]
   \   000003D6   0x300A             ADDS     R0,R0,#+10
   \   000003D8   0x4923             LDR.N    R1,??main_1+0x8
   \   000003DA   0x8008             STRH     R0,[R1, #+0]
   \   000003DC   0xE03C             B.N      ??main_22
    219                  else if  (PWMS.TARGET<195)
   \                     ??main_23: (+1)
   \   000003DE   0x4822             LDR.N    R0,??main_1+0x8
   \   000003E0   0x8800             LDRH     R0,[R0, #+0]
   \   000003E2   0x28C3             CMP      R0,#+195
   \   000003E4   0xDA05             BGE.N    ??main_24
    220                  {PWMS.TARGET = PWMS.TARGET + 25;} 
   \   000003E6   0x4820             LDR.N    R0,??main_1+0x8
   \   000003E8   0x8800             LDRH     R0,[R0, #+0]
   \   000003EA   0x3019             ADDS     R0,R0,#+25
   \   000003EC   0x491E             LDR.N    R1,??main_1+0x8
   \   000003EE   0x8008             STRH     R0,[R1, #+0]
   \   000003F0   0xE032             B.N      ??main_22
    221                  else if  (PWMS.TARGET<395)
   \                     ??main_24: (+1)
   \   000003F2   0x481D             LDR.N    R0,??main_1+0x8
   \   000003F4   0x8800             LDRH     R0,[R0, #+0]
   \   000003F6   0xF5B0 0x7FC5      CMP      R0,#+394
   \   000003FA   0xDC05             BGT.N    ??main_25
    222                  {PWMS.TARGET = PWMS.TARGET + 50; }
   \   000003FC   0x481A             LDR.N    R0,??main_1+0x8
   \   000003FE   0x8800             LDRH     R0,[R0, #+0]
   \   00000400   0x3032             ADDS     R0,R0,#+50
   \   00000402   0x4919             LDR.N    R1,??main_1+0x8
   \   00000404   0x8008             STRH     R0,[R1, #+0]
   \   00000406   0xE027             B.N      ??main_22
    223                  else if  (PWMS.TARGET<995)
   \                     ??main_25: (+1)
   \   00000408   0x4817             LDR.N    R0,??main_1+0x8
   \   0000040A   0x8800             LDRH     R0,[R0, #+0]
   \   0000040C   0xF240 0x31E3      MOVW     R1,#+995
   \   00000410   0x4288             CMP      R0,R1
   \   00000412   0xDA05             BGE.N    ??main_26
    224                  {PWMS.TARGET = PWMS.TARGET + 100; }
   \   00000414   0x4814             LDR.N    R0,??main_1+0x8
   \   00000416   0x8800             LDRH     R0,[R0, #+0]
   \   00000418   0x3064             ADDS     R0,R0,#+100
   \   0000041A   0x4913             LDR.N    R1,??main_1+0x8
   \   0000041C   0x8008             STRH     R0,[R1, #+0]
   \   0000041E   0xE01B             B.N      ??main_22
    225                  else if  (PWMS.TARGET<1995)
   \                     ??main_26: (+1)
   \   00000420   0x4811             LDR.N    R0,??main_1+0x8
   \   00000422   0x8800             LDRH     R0,[R0, #+0]
   \   00000424   0xF240 0x71CB      MOVW     R1,#+1995
   \   00000428   0x4288             CMP      R0,R1
   \   0000042A   0xDA05             BGE.N    ??main_27
    226                  {PWMS.TARGET = PWMS.TARGET + 250;} 
   \   0000042C   0x480E             LDR.N    R0,??main_1+0x8
   \   0000042E   0x8800             LDRH     R0,[R0, #+0]
   \   00000430   0x30FA             ADDS     R0,R0,#+250
   \   00000432   0x490D             LDR.N    R1,??main_1+0x8
   \   00000434   0x8008             STRH     R0,[R1, #+0]
   \   00000436   0xE00F             B.N      ??main_22
    227                  else if  (PWMS.TARGET<8005)
   \                     ??main_27: (+1)
   \   00000438   0x480B             LDR.N    R0,??main_1+0x8
   \   0000043A   0x8800             LDRH     R0,[R0, #+0]
   \   0000043C   0xF641 0x7145      MOVW     R1,#+8005
   \   00000440   0x4288             CMP      R0,R1
   \   00000442   0xDA06             BGE.N    ??main_28
    228                  {PWMS.TARGET = PWMS.TARGET + 1000; }
   \   00000444   0x4808             LDR.N    R0,??main_1+0x8
   \   00000446   0x8800             LDRH     R0,[R0, #+0]
   \   00000448   0xF510 0x707A      ADDS     R0,R0,#+1000
   \   0000044C   0x4906             LDR.N    R1,??main_1+0x8
   \   0000044E   0x8008             STRH     R0,[R1, #+0]
   \   00000450   0xE002             B.N      ??main_22
    229                  else 
    230                  {PWMS.TARGET = 0; }
   \                     ??main_28: (+1)
   \   00000452   0x2000             MOVS     R0,#+0
   \   00000454   0x4904             LDR.N    R1,??main_1+0x8
   \   00000456   0x8008             STRH     R0,[R1, #+0]
    231                }
    232                
    233          
    234                //COM1.Data.P01 = (u16) (PWMS.CURRENT);
    235                Timer.Flg_2sec = FALSE;
   \                     ??main_22: (+1)
   \   00000458   0x2000             MOVS     R0,#+0
   \   0000045A   0x4905             LDR.N    R1,??main_1+0x10
   \   0000045C   0x7548             STRB     R0,[R1, #+21]
   \   0000045E   0xE5D3             B.N      ??main_0
   \                     ??main_1:
   \   00000460   0x42C80000         DC32     0x42c80000
   \   00000464   0x40003000         DC32     0x40003000
   \   00000468   0x........         DC32     PWMS
   \   0000046C   0x40021000         DC32     0x40021000
   \   00000470   0x........         DC32     Timer
   \   00000474   0x........         DC32     cntest
   \   00000478   0x........         DC32     COM1
   \   0000047C   0x........         DC32     DATA_Sensors
   \   00000480   0x........         DC32     speedtemp
   \   00000484   0x40020400         DC32     0x40020400
   \   00000488   0x40003800         DC32     0x40003800
   \   0000048C   0x........         DC32     Press_ISR_FLG
   \   00000490   0x........         DC32     Valve_CMD_FLG
   \   00000494   0x........         DC32     SpeedMotor
   \   00000498   0x16872B02         DC32     0x16872b02
   \   0000049C   0x4027CED9         DC32     0x4027ced9
   \   000004A0   0xE826D695         DC32     0xe826d695
   \   000004A4   0x3E112E0B         DC32     0x3e112e0b
   \   000004A8   0x404E0000         DC32     0x404e0000
   \   000004AC   0x........         DC32     RcvPWM
   \   000004B0   0x........         DC32     KI_Flow
   \   000004B4   0x........         DC32     KP_Flow
   \   000004B8   0x........         DC32     KI
   \   000004BC   0x........         DC32     KP
   \   000004C0   0x........         DC32     SpeedSet
   \   000004C4   0x........         DC32     Flowset
   \   000004C8   0x........         DC32     control_mode
   \   000004CC   0x........         DC32     iteration
   \   000004D0   0x........         DC32     PWM_ind
   \   000004D4   0x........         DC32     Sample_arr
   \   000004D8   0x........         DC32     PWM_arr
   \   000004DC   0x........         DC32     cnt_valve
    236              }
    237            }
    238          }
    239          //-------------------------------------------------------------------------------
    240          
    241          //--------------------------------------------------------------------------|
    242          
    243          //--------------------------------------------------------------------------|

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   main
         8   -> Control
         8   -> Control_Flow
         8   -> Flow_SENSIRION_EXH_ReadDATA
         8   -> GPIO_ResetBits
         8   -> GPIO_ToggleBits
         8   -> GPIO_WriteBit
         8   -> HallSensor_Service
         8   -> Init
         8   -> PWM_Timer1
         8   -> Read_Press_INH_EXH
         8   -> SPI_I2S_ITConfig
         8   -> SPI_I2S_SendData
         8   -> SetPWM_EXH
         8   -> SetPWM_EXH2
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_ui2d


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  DATA_Sensors
       2  Flowset
       4  KI
       4  KI_Flow
       4  KP
       4  KP_Flow
      12  PWMS
      36  PWM_Array
     148  PWM_arr
       4  PWM_ind
     148  Sample_arr
       2  SpeedSet
       4  cnt_valve
       2  cntest
       1  control_mode
       1  control_valve_mode
       1  iteration
    1248  main
       4  speedtemp

 
    33 bytes in section .bss
   360 bytes in section .data
 1 248 bytes in section .text
 
 1 248 bytes of CODE memory
   393 bytes of DATA memory

Errors: none
Warnings: none
