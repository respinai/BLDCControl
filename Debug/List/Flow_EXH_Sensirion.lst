###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        05/Nov/2025  15:02:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\modules\Source\Flow_EXH_Sensirion.c
#    Command line =  
#        "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\modules\Source\Flow_EXH_Sensirion.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F40XX -lC "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\List\" -o "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\board\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\app\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2 added\modules\Header\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\" --relaxed_fp
#    List file    =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\List\Flow_EXH_Sensirion.lst
#    Object file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\Obj\Flow_EXH_Sensirion.o
#
###############################################################################

D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\modules\Source\Flow_EXH_Sensirion.c
      1          //-----------------------------------------------------------------------------|
      2          // SAADAT Co 
      3          // VENTILATOR 
      4          // DEVELOPER : MOJTABA REZAEI ASHTIYANI
      5          // VER 1.0
      6          // This File contains the Set up the flow sensor TSI company which contains :
      7          // __the coefficients read from memory with I2C communication.
      8          // __reading the analog value is output.
      9          //-----------------------------------------------------------------------------|
     10          
     11          #include "FLOW_Sensirion.h"
     12          #include "Flow_TSI_1.h"
     13          
     14          extern  void init_I2C(I2C_TypeDef* I2Cx);
     15          //--------------------------------------
     16          extern          STRUCT_DATA_A2DSENSORS          DATA_Sensors;
     17          //--------------------------------------------------
     18          

   \                                 In section .bss, align 4
     19          u32                         I2C_Timeout;
   \                     I2C_Timeout:
   \   00000000                      DS8 4
     20          //--------------------------------------------------
     21          

   \                                 In section .bss, align 4
     22          UNION_PACKET_U32_BYTE   Sensirion_SN;
   \                     Sensirion_SN:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     23          UNION_PACKET_U16_BYTE   Sensirion_OFFset, Sensirion_SCALE;
   \                     Sensirion_OFFset:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     Sensirion_SCALE:
   \   00000000                      DS8 4
     24          
     25          //--------------------------------------------------
     26          

   \                                 In section .data, align 4
     27          u8 EXH_DATACMD_Buffer[] = {0x10,0x00 ,0x30,0xDE, 0x30,0xDF,0x31,0xAE,0x20,0x00};
   \                     EXH_DATACMD_Buffer:
   \   00000000   0x10 0x00          DC8 16, 0, 48, 222, 48, 223, 49, 174, 32, 0, 0, 0
   \              0x30 0xDE    
   \              0x30 0xDF    
   \              0x31 0xAE    
   \              0x20 0x00    
   \              0x00 0x00    
     28          //                           datda      scale      offset      SN      Reset                

   \                                 In section .bss, align 2
     29          u8 EXH_DMARCV_Buffer_Data[2];
   \                     EXH_DMARCV_Buffer_Data:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     30          float EXHData;
   \                     EXHData:
   \   00000000                      DS8 4
     31          
     32          
     33          #define     DISCONNET_EXH_CNTV        100
     34          #define     CONNET_EXH_CNTV           20
     35          

   \                                 In section .bss, align 1
     36          u8      TimeDel , delaycnt;
   \                     TimeDel:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     delaycnt:
   \   00000000                      DS8 1
     37          //---------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     38          void Flow_SENSIRION_EXH_ReadDATA(void)
     39          {
   \                     Flow_SENSIRION_EXH_ReadDATA: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     40            static    u8  StateExhSensi = READ_DATA, CNT_ERR_Disconnect = 0, CNT_ERR_Connect = 0;
     41            u8        EXH_DATACMD_Buffer_scaleoffset[2] = {0};
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     42            //float     Ksn;  
     43            
     44            //----.......
     45            switch(StateExhSensi)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable4
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD012             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_0
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xF000 0x8131      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_1
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xF000 0x815F      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_2
   \   0000001E   0x2805             CMP      R0,#+5
   \   00000020   0xF000 0x8117      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_3
   \   00000024   0x2806             CMP      R0,#+6
   \   00000026   0xF000 0x8145      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_4
   \   0000002A   0x2808             CMP      R0,#+8
   \   0000002C   0xF000 0x8173      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_5
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xF000 0x80C1      BEQ.W    ??Flow_SENSIRION_EXH_ReadDATA_6
   \   00000036   0xE181             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
     46            {
     47            case READ_DATA:   /*  01  */
     48              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DMARCV_Buffer_Data ,2))!= I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_0: (+1)
   \   00000038   0x2302             MOVS     R3,#+2
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   0000003E   0x2181             MOVS     R1,#+129
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000044   0x.... 0x....      BL       I2C_Receive
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD025             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_8
     49              {
     50                CNT_ERR_Disconnect++;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x1C40             ADDS     R0,R0,#+1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   00000058   0x7008             STRB     R0,[R1, #+0]
     51                if(CNT_ERR_Disconnect >= DISCONNET_EXH_CNTV)//100
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable4_3
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2864             CMP      R0,#+100
   \   00000062   0xF2C0 0x80A8      BLT.W    ??Flow_SENSIRION_EXH_ReadDATA_9
     52                {
     53                  DATA_Sensors.HWErr.EXHSENSOR = 1;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   0000006A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000006C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000074   0x7208             STRB     R0,[R1, #+8]
     54                  DATA_Sensors.Flow_EXH = 0; // Reset data
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   0000007C   0x8048             STRH     R0,[R1, #+2]
     55                  StateExhSensi = SENSOR_DETECT; //Go to CMD SCALE / Error Disconnection
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000084   0x7008             STRB     R0,[R1, #+0]
     56                  CNT_ERR_Disconnect = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable4_3
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
     57                  CNT_ERR_Connect = 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   00000094   0x7008             STRB     R0,[R1, #+0]
   \   00000096   0xE08E             B.N      ??Flow_SENSIRION_EXH_ReadDATA_9
     58                }
     59              }
     60              else
     61              {
     62                EXHData = (float)(EXH_DMARCV_Buffer_Data[0] *256 + EXH_DMARCV_Buffer_Data[1]);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_8: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable4_1
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0xF44F 0x7180      MOV      R1,#+256
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable4_1
   \   000000A6   0x7852             LDRB     R2,[R2, #+1]
   \   000000A8   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000000AC   0xEE00 0x0A10      VMOV     S0,R0
   \   000000B0   0xEEB8 0x0AC0      VCVT.F32.S32 S0,S0
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000B8   0xED80 0x0A00      VSTR     S0,[R0, #0]
     63                EXHData = (EXHData - Sensirion_OFFset.ALLBYTE)/Sensirion_SCALE.ALLBYTE;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   000000C0   0x8800             LDRH     R0,[R0, #+0]
   \   000000C2   0xEE00 0x0A10      VMOV     S0,R0
   \   000000C6   0xEEB8 0x0A40      VCVT.F32.U32 S0,S0
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000CE   0xEDD0 0x0A00      VLDR     S1,[R0, #0]
   \   000000D2   0xEE30 0x0AC0      VSUB.F32 S0,S1,S0
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000DA   0x8800             LDRH     R0,[R0, #+0]
   \   000000DC   0xEE00 0x0A90      VMOV     S1,R0
   \   000000E0   0xEEF8 0x0A60      VCVT.F32.U32 S1,S1
   \   000000E4   0xEE80 0x0A20      VDIV.F32 S0,S0,S1
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000EC   0xED80 0x0A00      VSTR     S0,[R0, #0]
     64                // Convert to BTPS
     65                //Ksn = ((float)DATA_Sensors.A2D_AmbientPressure / 10) + ((float)DATA_Sensors.Press_INH / 100 );
     66                //Ksn = ( PFixCOEFFICIENT1 / (Ksn - 64.0) ) * PFixCOEFFICIENT2;    
     67                //EXHData *= Ksn;
     68                if(EXHData < 0)
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   000000F4   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   000000F8   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   000000FC   0xEEF1 0xFA10      FMSTAT   
   \   00000100   0xD50E             BPL.N    ??Flow_SENSIRION_EXH_ReadDATA_10
     69                {
     70                  if(EXHData < -50)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000106   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   0000010A   0xEDDF 0x....      VLDR.W   S1,??DataTable0  ;; 0xc2480000
   \   0000010E   0xEEB4 0x0A60      VCMP.F32 S0,S1
   \   00000112   0xEEF1 0xFA10      FMSTAT   
   \   00000116   0xD503             BPL.N    ??Flow_SENSIRION_EXH_ReadDATA_10
     71                    StateExhSensi = SENDCMD_DATA;
   \   00000118   0x2008             MOVS     R0,#+8
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
     72                }
     73                
     74                EXHData = EXHData <= 0 ? 0:EXHData;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_10: (+1)
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000124   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000128   0xEEB5 0x0A40      VCMP.F32 S0,#0.0
   \   0000012C   0xEEF1 0xFA10      FMSTAT   
   \   00000130   0xD804             BHI.N    ??Flow_SENSIRION_EXH_ReadDATA_11
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000136   0x2100             MOVS     R1,#+0
   \   00000138   0x6001             STR      R1,[R0, #+0]
   \   0000013A   0xE005             B.N      ??Flow_SENSIRION_EXH_ReadDATA_12
   \                     ??Flow_SENSIRION_EXH_ReadDATA_11: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable4_6
   \   00000144   0x6809             LDR      R1,[R1, #+0]
   \   00000146   0x6001             STR      R1,[R0, #+0]
     75                DATA_Sensors.Flow_EXH = (u16) (EXHData*100);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_12: (+1)
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable4_6
   \   0000014C   0xED90 0x0A00      VLDR     S0,[R0, #0]
   \   00000150   0xEDDF 0x....      VLDR.W   S1,??DataTable0_1  ;; 0x42c80000
   \   00000154   0xEE20 0x0A20      VMUL.F32 S0,S0,S1
   \   00000158   0xEEBD 0x0AC0      VCVT.S32.F32 S0,S0
   \   0000015C   0xEE10 0x0A10      VMOV     R0,S0
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000164   0x8048             STRH     R0,[R1, #+2]
     76                
     77                if(DATA_Sensors.HWErr.EXHSENSOR == 1)
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   0000016A   0x7A00             LDRB     R0,[R0, #+8]
   \   0000016C   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x2800             CMP      R0,#+0
   \   00000174   0xD01F             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_9
     78                {
     79                  if(++CNT_ERR_Connect >= CONNET_EXH_CNTV)
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0x1C40             ADDS     R0,R0,#+1
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable4_5
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x2814             CMP      R0,#+20
   \   0000018C   0xDB13             BLT.N    ??Flow_SENSIRION_EXH_ReadDATA_9
     80                  {
     81                    DATA_Sensors.HWErr.EXHSENSOR = 0;
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000192   0x7A00             LDRB     R0,[R0, #+8]
   \   00000194   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   0000019C   0x7208             STRB     R0,[R1, #+8]
     82                    DATA_Sensors.HWErr.EXHHARDWARE = 0;
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   000001A2   0x7A00             LDRB     R0,[R0, #+8]
   \   000001A4   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   000001AC   0x7208             STRB     R0,[R1, #+8]
     83                    CNT_ERR_Connect = 0;
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x.... 0x....      LDR.W    R1,??DataTable4_5
   \   000001B4   0x7008             STRB     R0,[R1, #+0]
     84                  }
     85                }
     86              }
     87              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_9: (+1)
   \   000001B6   0xE0C1             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
     88              //----------------------
     89            case SENSOR_DETECT:   /*  0A  */
     90              TimeDel++;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_6: (+1)
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   000001BC   0x7800             LDRB     R0,[R0, #+0]
   \   000001BE   0x1C40             ADDS     R0,R0,#+1
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable4_9
   \   000001C4   0x7008             STRB     R0,[R1, #+0]
     91              DATA_Sensors.HWErr.EXHSENSOR = 1;
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   000001CA   0x7A00             LDRB     R0,[R0, #+8]
   \   000001CC   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   000001D4   0x7208             STRB     R0,[R1, #+8]
     92              if(TimeDel == 10)
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   000001DA   0x7800             LDRB     R0,[R0, #+0]
   \   000001DC   0x280A             CMP      R0,#+10
   \   000001DE   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_13
     93              {
     94                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1,ENABLE);
   \   000001E0   0x2101             MOVS     R1,#+1
   \   000001E2   0xF45F 0x1000      MOVS     R0,#+2097152
   \   000001E6   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   000001EA   0xE031             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
     95              }
     96              else if(TimeDel == 11)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_13: (+1)
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x280B             CMP      R0,#+11
   \   000001F4   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_15
     97              {
     98                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1,DISABLE);
   \   000001F6   0x2100             MOVS     R1,#+0
   \   000001F8   0xF45F 0x1000      MOVS     R0,#+2097152
   \   000001FC   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000200   0xE026             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
     99              }
    100              else if(TimeDel == 200)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_15: (+1)
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   00000206   0x7800             LDRB     R0,[R0, #+0]
   \   00000208   0x28C8             CMP      R0,#+200
   \   0000020A   0xD104             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_16
    101              {       
    102                init_I2C(SENSIRION_EXH);
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000210   0x.... 0x....      BL       init_I2C
   \   00000214   0xE01C             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
    103              }
    104              else if(TimeDel >= 250)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_16: (+1)
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable4_9
   \   0000021A   0x7800             LDRB     R0,[R0, #+0]
   \   0000021C   0x28FA             CMP      R0,#+250
   \   0000021E   0xDB17             BLT.N    ??Flow_SENSIRION_EXH_ReadDATA_14
    105              {
    106                TimeDel=0;
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable4_9
   \   00000226   0x7008             STRB     R0,[R1, #+0]
    107                if(Check_Connect(SENSIRION_EXH, 0x80) == CONNECTOK50)
   \   00000228   0x2180             MOVS     R1,#+128
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   0000022E   0x.... 0x....      BL       Check_Connect
   \   00000232   0x2832             CMP      R0,#+50
   \   00000234   0xD104             BNE.N    ??Flow_SENSIRION_EXH_ReadDATA_17
    108                  StateExhSensi = SENDCMD_SCALE; //Go to CMD SCALE 
   \   00000236   0x2005             MOVS     R0,#+5
   \   00000238   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000023C   0x7008             STRB     R0,[R1, #+0]
   \   0000023E   0xE007             B.N      ??Flow_SENSIRION_EXH_ReadDATA_14
    109                else
    110                {
    111                  I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[8], 2);
   \                     ??Flow_SENSIRION_EXH_ReadDATA_17: (+1)
   \   00000240   0x2302             MOVS     R3,#+2
   \   00000242   0x.... 0x....      LDR.W    R2,??DataTable4_10
   \   00000246   0x2180             MOVS     R1,#+128
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   0000024C   0x.... 0x....      BL       I2C_Transmit
    112                }
    113              }    
    114              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_14: (+1)
   \   00000250   0xE074             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    115              //----------------------
    116            case SENDCMD_SCALE: /*  5  */
    117              if((I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[2], 2)) != I2C_OK) // Scale
   \                     ??Flow_SENSIRION_EXH_ReadDATA_3: (+1)
   \   00000252   0x2302             MOVS     R3,#+2
   \   00000254   0x.... 0x....      LDR.W    R2,??DataTable4_11
   \   00000258   0x2180             MOVS     R1,#+128
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   0000025E   0x.... 0x....      BL       I2C_Transmit
   \   00000262   0x2800             CMP      R0,#+0
   \   00000264   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_18
    118              {
    119                //Error  DISConnection / go to timer
    120                StateExhSensi = SENSOR_DETECT; // Back to DETECT 
   \   00000266   0x200A             MOVS     R0,#+10
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000026C   0x7008             STRB     R0,[R1, #+0]
   \   0000026E   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_19
    121              }
    122              else
    123              {
    124                StateExhSensi = READ_SCALE; //Go to Read SCALE
   \                     ??Flow_SENSIRION_EXH_ReadDATA_18: (+1)
   \   00000270   0x2002             MOVS     R0,#+2
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000276   0x7008             STRB     R0,[R1, #+0]
    125              }
    126              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_19: (+1)
   \   00000278   0xE060             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    127              //----------------------
    128            case READ_SCALE:  /*  02  */
    129              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DATACMD_Buffer_scaleoffset ,2)) != I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_1: (+1)
   \   0000027A   0x2302             MOVS     R3,#+2
   \   0000027C   0xAA00             ADD      R2,SP,#+0
   \   0000027E   0x2181             MOVS     R1,#+129
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000284   0x.... 0x....      BL       I2C_Receive
   \   00000288   0x2800             CMP      R0,#+0
   \   0000028A   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_20
    130              {
    131                StateExhSensi = SENSOR_DETECT; //Back to DETECT  
   \   0000028C   0x200A             MOVS     R0,#+10
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000292   0x7008             STRB     R0,[R1, #+0]
   \   00000294   0xE00D             B.N      ??Flow_SENSIRION_EXH_ReadDATA_21
    132              }
    133              else
    134              {
    135                Sensirion_SCALE.Data.HIGHBYT = EXH_DATACMD_Buffer_scaleoffset[0];
   \                     ??Flow_SENSIRION_EXH_ReadDATA_20: (+1)
   \   00000296   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000029A   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   0000029E   0x7048             STRB     R0,[R1, #+1]
    136                Sensirion_SCALE.Data.LOWBYT = EXH_DATACMD_Buffer_scaleoffset[1];
   \   000002A0   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000002A4   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   000002A8   0x7008             STRB     R0,[R1, #+0]
    137                StateExhSensi = SENDCMD_OFFSET; //Go to CMD OFFSET
   \   000002AA   0x2006             MOVS     R0,#+6
   \   000002AC   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002B0   0x7008             STRB     R0,[R1, #+0]
    138              }
    139              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_21: (+1)
   \   000002B2   0xE043             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    140              //----------------------
    141            case SENDCMD_OFFSET:  /*  06  */
    142              if((I2C_Transmit(SENSIRION_EXH, 0x80, &EXH_DATACMD_Buffer[4], 2)) != I2C_OK) // OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_4: (+1)
   \   000002B4   0x2302             MOVS     R3,#+2
   \   000002B6   0x.... 0x....      LDR.W    R2,??DataTable4_12
   \   000002BA   0x2180             MOVS     R1,#+128
   \   000002BC   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   000002C0   0x.... 0x....      BL       I2C_Transmit
   \   000002C4   0x2800             CMP      R0,#+0
   \   000002C6   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_22
    143              {
    144                //Error / go to timer
    145                StateExhSensi = SENSOR_DETECT; //Back to DETECT  
   \   000002C8   0x200A             MOVS     R0,#+10
   \   000002CA   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002CE   0x7008             STRB     R0,[R1, #+0]
   \   000002D0   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_23
    146              }
    147              else
    148              {
    149                StateExhSensi = READ_OFFSET; //Go to Read OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_22: (+1)
   \   000002D2   0x2003             MOVS     R0,#+3
   \   000002D4   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002D8   0x7008             STRB     R0,[R1, #+0]
    150              }
    151              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_23: (+1)
   \   000002DA   0xE02F             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    152              //----------------------
    153            case READ_OFFSET: /*  03  */
    154              if((I2C_Receive(SENSIRION_EXH,0x81,EXH_DATACMD_Buffer_scaleoffset ,2)) != I2C_OK)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_2: (+1)
   \   000002DC   0x2302             MOVS     R3,#+2
   \   000002DE   0xAA00             ADD      R2,SP,#+0
   \   000002E0   0x2181             MOVS     R1,#+129
   \   000002E2   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   000002E6   0x.... 0x....      BL       I2C_Receive
   \   000002EA   0x2800             CMP      R0,#+0
   \   000002EC   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_24
    155              {
    156                StateExhSensi = SENSOR_DETECT; //Back to DETECT 
   \   000002EE   0x200A             MOVS     R0,#+10
   \   000002F0   0x.... 0x....      LDR.W    R1,??DataTable4
   \   000002F4   0x7008             STRB     R0,[R1, #+0]
   \   000002F6   0xE00D             B.N      ??Flow_SENSIRION_EXH_ReadDATA_25
    157              }
    158              else
    159              {
    160                Sensirion_OFFset.Data.HIGHBYT = EXH_DATACMD_Buffer_scaleoffset[0];
   \                     ??Flow_SENSIRION_EXH_ReadDATA_24: (+1)
   \   000002F8   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000002FC   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000300   0x7048             STRB     R0,[R1, #+1]
    161                Sensirion_OFFset.Data.LOWBYT = EXH_DATACMD_Buffer_scaleoffset[1];
   \   00000302   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000306   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   0000030A   0x7008             STRB     R0,[R1, #+0]
    162                StateExhSensi = SENDCMD_DATA; //Go to CMD DATA
   \   0000030C   0x2008             MOVS     R0,#+8
   \   0000030E   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000312   0x7008             STRB     R0,[R1, #+0]
    163              }
    164              break;
   \                     ??Flow_SENSIRION_EXH_ReadDATA_25: (+1)
   \   00000314   0xE012             B.N      ??Flow_SENSIRION_EXH_ReadDATA_7
    165              //----------------------
    166              //SN
    167              //----------------------
    168              //----------------------
    169            case SENDCMD_DATA:    /*  08  */
    170              if((I2C_Transmit(SENSIRION_EXH, 0x80, EXH_DATACMD_Buffer, 2)) != I2C_OK) // Request Data - 0x1000) 
   \                     ??Flow_SENSIRION_EXH_ReadDATA_5: (+1)
   \   00000316   0x2302             MOVS     R3,#+2
   \   00000318   0x.... 0x....      LDR.W    R2,??DataTable4_13
   \   0000031C   0x2180             MOVS     R1,#+128
   \   0000031E   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000322   0x.... 0x....      BL       I2C_Transmit
   \   00000326   0x2800             CMP      R0,#+0
   \   00000328   0xD004             BEQ.N    ??Flow_SENSIRION_EXH_ReadDATA_26
    171              {
    172                //Error / go to timer
    173                StateExhSensi = SENSOR_DETECT; //Back to DETECT 
   \   0000032A   0x200A             MOVS     R0,#+10
   \   0000032C   0x.... 0x....      LDR.W    R1,??DataTable4
   \   00000330   0x7008             STRB     R0,[R1, #+0]
   \   00000332   0xE003             B.N      ??Flow_SENSIRION_EXH_ReadDATA_27
    174              }
    175              else
    176              {
    177                StateExhSensi = READ_DATA; //Go to Read OFFSET
   \                     ??Flow_SENSIRION_EXH_ReadDATA_26: (+1)
   \   00000334   0x2001             MOVS     R0,#+1
   \   00000336   0x.... 0x....      LDR.W    R1,??DataTable4
   \   0000033A   0x7008             STRB     R0,[R1, #+0]
    178              }
    179              break;  
    180            }//switch
    181            //----- 
    182            
    183            //DATA_Sensors.Flow_EXH =  150;
    184          }
   \                     ??Flow_SENSIRION_EXH_ReadDATA_27: (+1)
   \                     ??Flow_SENSIRION_EXH_ReadDATA_7: (+1)
   \   0000033C   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 1
   \                     ??StateExhSensi:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
   \                     ??CNT_ERR_Disconnect:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??CNT_ERR_Connect:
   \   00000000                      DS8 1
    185          //---------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    186          void Flow_SENSIRION_EXH_ReadSN(void)
    187          {
   \                     Flow_SENSIRION_EXH_ReadSN: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    188            u8 EXH_DATACMD_Buffer_scale[2] = {0};
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    189            u8 EXH_DATACMD_Buffer_offset[2] = {0};
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    190            u8 EXH_DATACMD_Buffer_SN[6] = {0};
   \   00000010   0xA801             ADD      R0,SP,#+4
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xC006             STM      R0!,{R1,R2}
   \   00000018   0x3808             SUBS     R0,R0,#+8
    191            
    192            u8    ReRead = 0, i=0;
   \   0000001A   0x2600             MOVS     R6,#+0
   \   0000001C   0x2400             MOVS     R4,#+0
    193            u8    CheckData=0;
   \   0000001E   0x2500             MOVS     R5,#+0
    194            for(ReRead=0;ReRead<10;ReRead++)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0006             MOVS     R6,R0
   \                     ??Flow_SENSIRION_EXH_ReadSN_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E0A             CMP      R6,#+10
   \   00000028   0xDA13             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_1
    195            {
    196              for(u8 wa=0;wa<250;wa++){}; // delay for WarmUp Time
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_2: (+1)
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x28FA             CMP      R0,#+250
   \   00000030   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_3
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_2
    197              if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[2], 2)) == I2C_OK) // Scale
   \                     ??Flow_SENSIRION_EXH_ReadSN_3: (+1)
   \   00000036   0x2302             MOVS     R3,#+2
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable4_11
   \   0000003C   0x2180             MOVS     R1,#+128
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000042   0x.... 0x....      BL       I2C_Transmit
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD101             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_4
    198              {
    199                ReRead = 20;
   \   0000004A   0x2014             MOVS     R0,#+20
   \   0000004C   0x0006             MOVS     R6,R0
    200              }
    201              
    202            }
   \                     ??Flow_SENSIRION_EXH_ReadSN_4: (+1)
   \   0000004E   0x1C76             ADDS     R6,R6,#+1
   \   00000050   0xE7E8             B.N      ??Flow_SENSIRION_EXH_ReadSN_0
    203            DATA_Sensors.HWErr.EXHHARDWARE = FALSE;
   \                     ??Flow_SENSIRION_EXH_ReadSN_1: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000056   0x7A00             LDRB     R0,[R0, #+8]
   \   00000058   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000060   0x7208             STRB     R0,[R1, #+8]
    204            DATA_Sensors.HWErr.EXHSENSOR = FALSE;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable4_4
   \   00000066   0x7A00             LDRB     R0,[R0, #+8]
   \   00000068   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable4_4
   \   00000070   0x7208             STRB     R0,[R1, #+8]
    205            if(ReRead >= 20)//OK
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0x2E14             CMP      R6,#+20
   \   00000076   0xF2C0 0x80A5      BLT.W    ??Flow_SENSIRION_EXH_ReadSN_5
    206            {
    207              CheckData=0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x0005             MOVS     R5,R0
    208              while(CheckData < 30)
   \                     ??Flow_SENSIRION_EXH_ReadSN_6: (+1)
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x2D1E             CMP      R5,#+30
   \   00000082   0xF280 0x8096      BGE.W    ??Flow_SENSIRION_EXH_ReadSN_7
    209              {
    210                //........1      
    211                if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[2], 2)) == I2C_OK) // Scale
   \   00000086   0x2302             MOVS     R3,#+2
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable4_11
   \   0000008C   0x2180             MOVS     R1,#+128
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   00000092   0x.... 0x....      BL       I2C_Transmit
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xF040 0x8083      BNE.W    ??Flow_SENSIRION_EXH_ReadSN_8
    212                {
    213                  if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_scale ,2)) == I2C_OK)
   \   0000009C   0x2302             MOVS     R3,#+2
   \   0000009E   0xF10D 0x0202      ADD      R2,SP,#+2
   \   000000A2   0x2181             MOVS     R1,#+129
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   000000A8   0x.... 0x....      BL       I2C_Receive
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD178             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    214                  {
    215                    Sensirion_SCALE.Data.HIGHBYT = EXH_DATACMD_Buffer_scale[0];
   \   000000B0   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   000000B8   0x7048             STRB     R0,[R1, #+1]
    216                    Sensirion_SCALE.Data.LOWBYT = EXH_DATACMD_Buffer_scale[1];
   \   000000BA   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable4_8
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    217                    if(Sensirion_SCALE.ALLBYTE > 10 && Sensirion_SCALE.ALLBYTE < 1000)
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000C8   0x8800             LDRH     R0,[R0, #+0]
   \   000000CA   0x280B             CMP      R0,#+11
   \   000000CC   0xDB69             BLT.N    ??Flow_SENSIRION_EXH_ReadSN_8
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable4_8
   \   000000D2   0x8800             LDRH     R0,[R0, #+0]
   \   000000D4   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000D8   0xDA63             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    218                    {
    219                      if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[4], 2)) == I2C_OK) // Offset
   \   000000DA   0x2302             MOVS     R3,#+2
   \   000000DC   0x.... 0x....      LDR.W    R2,??DataTable4_12
   \   000000E0   0x2180             MOVS     R1,#+128
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   000000E6   0x.... 0x....      BL       I2C_Transmit
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD159             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    220                      {
    221                        if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_offset ,2)) == I2C_OK)
   \   000000EE   0x2302             MOVS     R3,#+2
   \   000000F0   0xAA00             ADD      R2,SP,#+0
   \   000000F2   0x2181             MOVS     R1,#+129
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   000000F8   0x.... 0x....      BL       I2C_Receive
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD150             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    222                        {
    223                          Sensirion_OFFset.Data.HIGHBYT = EXH_DATACMD_Buffer_offset[0];
   \   00000100   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000108   0x7048             STRB     R0,[R1, #+1]
    224                          Sensirion_OFFset.Data.LOWBYT = EXH_DATACMD_Buffer_offset[1];
   \   0000010A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable4_7
   \   00000112   0x7008             STRB     R0,[R1, #+0]
    225                          if(Sensirion_OFFset.ALLBYTE > 25000 && Sensirion_OFFset.ALLBYTE < 45000)
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   00000118   0x8800             LDRH     R0,[R0, #+0]
   \   0000011A   0xF246 0x11A9      MOVW     R1,#+25001
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xDB3F             BLT.N    ??Flow_SENSIRION_EXH_ReadSN_8
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable4_7
   \   00000126   0x8800             LDRH     R0,[R0, #+0]
   \   00000128   0xF64A 0x71C8      MOVW     R1,#+45000
   \   0000012C   0x4288             CMP      R0,R1
   \   0000012E   0xDA38             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    226                          {
    227                            if((I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, &EXH_DATACMD_Buffer[6], 2)) == I2C_OK) // SN
   \   00000130   0x2302             MOVS     R3,#+2
   \   00000132   0x.... 0x....      LDR.W    R2,??DataTable4_14
   \   00000136   0x2180             MOVS     R1,#+128
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable4_2  ;; 0x40005800
   \   0000013C   0x.... 0x....      BL       I2C_Transmit
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD12E             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    228                            {
    229                              if((I2C_Receive(SENSIRION_EXH,ADDRES_SENSIRION_READ,EXH_DATACMD_Buffer_SN ,6)) == I2C_OK)
   \   00000144   0x2306             MOVS     R3,#+6
   \   00000146   0xAA01             ADD      R2,SP,#+4
   \   00000148   0x2181             MOVS     R1,#+129
   \   0000014A   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40005800
   \   0000014C   0x.... 0x....      BL       I2C_Receive
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD126             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_8
    230                              {
    231                                Sensirion_SN.Data.BYTE_H = EXH_DATACMD_Buffer_SN[0];
   \   00000154   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable4_15
   \   0000015C   0x70C8             STRB     R0,[R1, #+3]
    232                                Sensirion_SN.Data.BYTE_3 = EXH_DATACMD_Buffer_SN[1];
   \   0000015E   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000162   0x.... 0x....      LDR.W    R1,??DataTable4_15
   \   00000166   0x7088             STRB     R0,[R1, #+2]
    233                                Sensirion_SN.Data.BYTE_2 = EXH_DATACMD_Buffer_SN[3];
   \   00000168   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   0000016C   0x....             LDR.N    R1,??DataTable4_15
   \   0000016E   0x7048             STRB     R0,[R1, #+1]
    234                                Sensirion_SN.Data.BYTE_L = EXH_DATACMD_Buffer_SN[4];
   \   00000170   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000174   0x....             LDR.N    R1,??DataTable4_15
   \   00000176   0x7008             STRB     R0,[R1, #+0]
    235                                for(i=0;i<5;i++)
   \   00000178   0x2000             MOVS     R0,#+0
   \   0000017A   0x0004             MOVS     R4,R0
   \                     ??Flow_SENSIRION_EXH_ReadSN_9: (+1)
   \   0000017C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000017E   0x2C05             CMP      R4,#+5
   \   00000180   0xDA0D             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_10
    236                                {
    237                                  I2C_Transmit(SENSIRION_EXH, ADDRES_SENSIRION_WRITE, EXH_DATACMD_Buffer, 2);// Request Data - 0x1000
   \   00000182   0x2302             MOVS     R3,#+2
   \   00000184   0x....             LDR.N    R2,??DataTable4_13
   \   00000186   0x2180             MOVS     R1,#+128
   \   00000188   0x....             LDR.N    R0,??DataTable4_2  ;; 0x40005800
   \   0000018A   0x.... 0x....      BL       I2C_Transmit
    238                                  for(u8 ag=0;ag<250;ag++){};//For Delay
   \   0000018E   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_11: (+1)
   \   00000190   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000192   0x28FA             CMP      R0,#+250
   \   00000194   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_12
   \   00000196   0x1C40             ADDS     R0,R0,#+1
   \   00000198   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_11
    239                                }
   \                     ??Flow_SENSIRION_EXH_ReadSN_12: (+1)
   \   0000019A   0x1C64             ADDS     R4,R4,#+1
   \   0000019C   0xE7EE             B.N      ??Flow_SENSIRION_EXH_ReadSN_9
    240                                CheckData = 100;
   \                     ??Flow_SENSIRION_EXH_ReadSN_10: (+1)
   \   0000019E   0x2064             MOVS     R0,#+100
   \   000001A0   0x0005             MOVS     R5,R0
    241                              }
    242                            }
    243                          }
    244                        }
    245                      }
    246                    }
    247                  }
    248                }
    249                for(u8 ag=0;ag<250;ag++){};//For Delay
   \                     ??Flow_SENSIRION_EXH_ReadSN_8: (+1)
   \   000001A2   0x2000             MOVS     R0,#+0
   \                     ??Flow_SENSIRION_EXH_ReadSN_13: (+1)
   \   000001A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A6   0x28FA             CMP      R0,#+250
   \   000001A8   0xDA01             BGE.N    ??Flow_SENSIRION_EXH_ReadSN_14
   \   000001AA   0x1C40             ADDS     R0,R0,#+1
   \   000001AC   0xE7FA             B.N      ??Flow_SENSIRION_EXH_ReadSN_13
    250                CheckData++;
   \                     ??Flow_SENSIRION_EXH_ReadSN_14: (+1)
   \   000001AE   0x1C6D             ADDS     R5,R5,#+1
   \   000001B0   0xE765             B.N      ??Flow_SENSIRION_EXH_ReadSN_6
    251              }//while 
    252              if(CheckData == 30)
   \                     ??Flow_SENSIRION_EXH_ReadSN_7: (+1)
   \   000001B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B4   0x2D1E             CMP      R5,#+30
   \   000001B6   0xD105             BNE.N    ??Flow_SENSIRION_EXH_ReadSN_5
    253                DATA_Sensors.HWErr.EXHHARDWARE = TRUE;//Error
   \   000001B8   0x....             LDR.N    R0,??DataTable4_4
   \   000001BA   0x7A00             LDRB     R0,[R0, #+8]
   \   000001BC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000001C0   0x....             LDR.N    R1,??DataTable4_4
   \   000001C2   0x7208             STRB     R0,[R1, #+8]
    254            }
    255          }
   \                     ??Flow_SENSIRION_EXH_ReadSN_5: (+1)
   \   000001C4   0xBD7F             POP      {R0-R6,PC}       ;; return
    256          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    257          I2C_StatusTypeDef    I2C_Receive(I2C_TypeDef* I2Cx, u8 address,u8* data, u16 count) 
    258          {
   \                     I2C_Receive: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    259            I2C_Timeout = I2C_TIMEOUT;
   \   0000000A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000000E   0x....             LDR.N    R1,??DataTable4_16
   \   00000010   0x6008             STR      R0,[R1, #+0]
    260            /* Wait until BUSY flag is reset */
    261            while(I2Cx->SR2 & I2C_SR2_BUSY)
   \                     ??I2C_Receive_0: (+1)
   \   00000012   0x8B20             LDRH     R0,[R4, #+24]
   \   00000014   0x0780             LSLS     R0,R0,#+30
   \   00000016   0xD50E             BPL.N    ??I2C_Receive_1
    262            {
    263              if(--I2C_Timeout == 0x00)
   \   00000018   0x....             LDR.N    R0,??DataTable4_16
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable4_16
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x....             LDR.N    R0,??DataTable4_16
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F3             BNE.N    ??I2C_Receive_0
    264              {
    265                /* Generate Stop */
    266                I2Cx->CR1 |= I2C_CR1_STOP;
   \   0000002A   0x8820             LDRH     R0,[R4, #+0]
   \   0000002C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000030   0x8020             STRH     R0,[R4, #+0]
    267                return I2C_TIMEout;  
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0xE063             B.N      ??I2C_Receive_2
    268              }
    269            }
    270            //--------------------
    271            /* Enable Acknowledge */
    272            I2Cx->CR1 |= I2C_CR1_ACK;   
   \                     ??I2C_Receive_1: (+1)
   \   00000036   0x8820             LDRH     R0,[R4, #+0]
   \   00000038   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
    273            //------------
    274            /* Generate Start */
    275            I2Cx->CR1 |= I2C_CR1_START; 
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000044   0x8020             STRH     R0,[R4, #+0]
    276            /* Wait until SB flag is set */
    277            I2C_Timeout = I2C_TIMEOUT;
   \   00000046   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000004A   0x....             LDR.N    R1,??DataTable4_16
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    278            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??I2C_Receive_3: (+1)
   \   0000004E   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000050   0x07C0             LSLS     R0,R0,#+31
   \   00000052   0xD40E             BMI.N    ??I2C_Receive_4
    279            {
    280              if (--I2C_Timeout == 0x00) 
   \   00000054   0x....             LDR.N    R0,??DataTable4_16
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable4_16
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   \   0000005E   0x....             LDR.N    R0,??DataTable4_16
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1F3             BNE.N    ??I2C_Receive_3
    281              {
    282                /* Generate Stop */
    283                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000066   0x8820             LDRH     R0,[R4, #+0]
   \   00000068   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    284                return I2C_TIMEout;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE045             B.N      ??I2C_Receive_2
    285              }      
    286            }
    287            ///-------- 
    288            /* Send address with zero last bit */
    289            I2Cx->DR = address;   
   \                     ??I2C_Receive_4: (+1)
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x8225             STRH     R5,[R4, #+16]
    290            /* Wait till finished */
    291            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??I2C_Receive_5: (+1)
   \   00000076   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD40E             BMI.N    ??I2C_Receive_6
    292            {
    293              if (--I2C_Timeout == 0x00) 
   \   0000007C   0x....             LDR.N    R0,??DataTable4_16
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x1E40             SUBS     R0,R0,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable4_16
   \   00000084   0x6008             STR      R0,[R1, #+0]
   \   00000086   0x....             LDR.N    R0,??DataTable4_16
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD1F3             BNE.N    ??I2C_Receive_5
    294              {
    295                /* Generate Stop */
    296                I2Cx->CR1 |= I2C_CR1_STOP;
   \   0000008E   0x8820             LDRH     R0,[R4, #+0]
   \   00000090   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000094   0x8020             STRH     R0,[R4, #+0]
    297                return I2C_TIMEout;
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0xE031             B.N      ??I2C_Receive_2
    298              } 
    299            }
    300            /* Read status register to clear ADDR flag */
    301            I2Cx->SR1;
   \                     ??I2C_Receive_6: (+1)
   \   0000009A   0x8AA0             LDRH     R0,[R4, #+20]
    302            I2Cx->SR2;
   \   0000009C   0x8B20             LDRH     R0,[R4, #+24]
    303            //----------------------
    304            
    305            
    306            for(;count>0;count--)
   \                     ??I2C_Receive_7: (+1)
   \   0000009E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A0   0x2F00             CMP      R7,#+0
   \   000000A2   0xD025             BEQ.N    ??I2C_Receive_8
    307            {
    308              if(count == 1)//end data
   \   000000A4   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A6   0x2F01             CMP      R7,#+1
   \   000000A8   0xD104             BNE.N    ??I2C_Receive_9
    309              {
    310                I2Cx->CR1 &= ~I2C_CR1_ACK;
   \   000000AA   0x8820             LDRH     R0,[R4, #+0]
   \   000000AC   0xF64F 0x31FF      MOVW     R1,#+64511
   \   000000B0   0x4008             ANDS     R0,R1,R0
   \   000000B2   0x8020             STRH     R0,[R4, #+0]
    311              }
    312              
    313              /* Wait till not received */
    314              I2C_Timeout = I2C_TIMEOUT;
   \                     ??I2C_Receive_9: (+1)
   \   000000B4   0xF640 0x30B8      MOVW     R0,#+3000
   \   000000B8   0x....             LDR.N    R1,??DataTable4_16
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    315              while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)) 
   \                     ??I2C_Receive_10: (+1)
   \   000000BC   0x....             LDR.N    R1,??DataTable4_17  ;; 0x30040
   \   000000BE   0x0020             MOVS     R0,R4
   \   000000C0   0x.... 0x....      BL       I2C_CheckEvent
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD10E             BNE.N    ??I2C_Receive_11
    316              {
    317                if (--I2C_Timeout == 0x00) 
   \   000000C8   0x....             LDR.N    R0,??DataTable4_16
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable4_16
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0x....             LDR.N    R0,??DataTable4_16
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1F0             BNE.N    ??I2C_Receive_10
    318                {
    319                  /* Generate Stop */
    320                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000DA   0x8820             LDRH     R0,[R4, #+0]
   \   000000DC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000E0   0x8020             STRH     R0,[R4, #+0]
    321                  return I2C_TIMEout;
   \   000000E2   0x2003             MOVS     R0,#+3
   \   000000E4   0xE00B             B.N      ??I2C_Receive_2
    322                }
    323              }    
    324              /* Read data */
    325              *data = I2Cx->DR;  
   \                     ??I2C_Receive_11: (+1)
   \   000000E6   0x8A20             LDRH     R0,[R4, #+16]
   \   000000E8   0x7030             STRB     R0,[R6, #+0]
    326              data++;
   \   000000EA   0x1C76             ADDS     R6,R6,#+1
    327            }
   \   000000EC   0x1E7F             SUBS     R7,R7,#+1
   \   000000EE   0xE7D6             B.N      ??I2C_Receive_7
    328            /* Generate Stop */
    329            I2Cx->CR1 |= I2C_CR1_STOP;
   \                     ??I2C_Receive_8: (+1)
   \   000000F0   0x8820             LDRH     R0,[R4, #+0]
   \   000000F2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000F6   0x8020             STRH     R0,[R4, #+0]
    330            /* Read status register to clear ADDR flag */
    331            I2Cx->SR1;
   \   000000F8   0x8AA0             LDRH     R0,[R4, #+20]
    332            I2Cx->SR2;
   \   000000FA   0x8B20             LDRH     R0,[R4, #+24]
    333            //-----------------
    334            return I2C_OK;  
   \   000000FC   0x2000             MOVS     R0,#+0
   \                     ??I2C_Receive_2: (+1)
   \   000000FE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    335          }
    336          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    337          I2C_StatusTypeDef    I2C_Transmit(I2C_TypeDef* I2Cx, u8 address,u8* data, u16 count) 
    338          {
   \                     I2C_Transmit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0004             MOVS     R4,R0
    339            I2C_Timeout = I2C_TIMEOUT;
   \   00000004   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000008   0x....             LDR.N    R5,??DataTable4_16
   \   0000000A   0x6028             STR      R0,[R5, #+0]
    340            /* Wait until BUSY flag is reset */
    341            while(I2Cx->SR2 & I2C_SR2_BUSY)
   \                     ??I2C_Transmit_0: (+1)
   \   0000000C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD50E             BPL.N    ??I2C_Transmit_1
    342            {
    343              if(--I2C_Timeout == 0x00)
   \   00000012   0x....             LDR.N    R0,??DataTable4_16
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R5,??DataTable4_16
   \   0000001A   0x6028             STR      R0,[R5, #+0]
   \   0000001C   0x....             LDR.N    R0,??DataTable4_16
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F3             BNE.N    ??I2C_Transmit_0
    344              {
    345                /* Generate Stop */
    346                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000002A   0x8020             STRH     R0,[R4, #+0]
    347                return I2C_TIMEout;  
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xE06E             B.N      ??I2C_Transmit_2
    348              }
    349            }
    350            //--------------------
    351            /* Generate Start */
    352            I2Cx->CR1 |= I2C_CR1_START; 
   \                     ??I2C_Transmit_1: (+1)
   \   00000030   0x8820             LDRH     R0,[R4, #+0]
   \   00000032   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    353            /* Wait until SB flag is set */
    354            I2C_Timeout = I2C_TIMEOUT;
   \   00000038   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000003C   0x....             LDR.N    R5,??DataTable4_16
   \   0000003E   0x6028             STR      R0,[R5, #+0]
    355            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??I2C_Transmit_3: (+1)
   \   00000040   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000042   0x07C0             LSLS     R0,R0,#+31
   \   00000044   0xD40E             BMI.N    ??I2C_Transmit_4
    356            {
    357              if (--I2C_Timeout == 0x00) 
   \   00000046   0x....             LDR.N    R0,??DataTable4_16
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R5,??DataTable4_16
   \   0000004E   0x6028             STR      R0,[R5, #+0]
   \   00000050   0x....             LDR.N    R0,??DataTable4_16
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD1F3             BNE.N    ??I2C_Transmit_3
    358              {
    359                /* Generate Stop */
    360                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000058   0x8820             LDRH     R0,[R4, #+0]
   \   0000005A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000005E   0x8020             STRH     R0,[R4, #+0]
    361                return I2C_TIMEout;
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0xE054             B.N      ??I2C_Transmit_2
    362              }      
    363            }
    364            //--------------------
    365            I2C_Timeout = I2C_TIMEOUT;
   \                     ??I2C_Transmit_4: (+1)
   \   00000064   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000068   0x....             LDR.N    R5,??DataTable4_16
   \   0000006A   0x6028             STR      R0,[R5, #+0]
    366            /* Send address with zero last bit */
    367            I2Cx->DR = address;   // address & write Bit
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x8221             STRH     R1,[R4, #+16]
    368            /* Wait till finished */
    369            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??I2C_Transmit_5: (+1)
   \   00000070   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000072   0x0780             LSLS     R0,R0,#+30
   \   00000074   0xD40E             BMI.N    ??I2C_Transmit_6
    370            {
    371              if (--I2C_Timeout == 0x00) 
   \   00000076   0x....             LDR.N    R0,??DataTable4_16
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1E40             SUBS     R0,R0,#+1
   \   0000007C   0x....             LDR.N    R5,??DataTable4_16
   \   0000007E   0x6028             STR      R0,[R5, #+0]
   \   00000080   0x....             LDR.N    R0,??DataTable4_16
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD1F3             BNE.N    ??I2C_Transmit_5
    372              {
    373                /* Generate Stop */
    374                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000088   0x8820             LDRH     R0,[R4, #+0]
   \   0000008A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000008E   0x8020             STRH     R0,[R4, #+0]
    375                return I2C_TIMEout;
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE03C             B.N      ??I2C_Transmit_2
    376              } 
    377            }
    378            /* Read status register to clear ADDR flag */
    379            I2Cx->SR1;
   \                     ??I2C_Transmit_6: (+1)
   \   00000094   0x8AA0             LDRH     R0,[R4, #+20]
    380            I2Cx->SR2;
   \   00000096   0x8B20             LDRH     R0,[R4, #+24]
    381            //----------------------
    382            /* Send data */
    383            for(u16 i=0;i<count;i++)
   \   00000098   0x2000             MOVS     R0,#+0
   \                     ??I2C_Transmit_7: (+1)
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000009E   0x4298             CMP      R0,R3
   \   000000A0   0xD230             BCS.N    ??I2C_Transmit_8
    384            {
    385              /* Wait until TXE flag is set */
    386              I2C_Timeout = I2C_TIMEOUT;
   \   000000A2   0xF640 0x35B8      MOVW     R5,#+3000
   \   000000A6   0x....             LDR.N    R6,??DataTable4_16
   \   000000A8   0x6035             STR      R5,[R6, #+0]
    387              while (!(I2Cx->SR1 & I2C_SR1_TXE)) 
   \                     ??I2C_Transmit_9: (+1)
   \   000000AA   0x8AA5             LDRH     R5,[R4, #+20]
   \   000000AC   0x062D             LSLS     R5,R5,#+24
   \   000000AE   0xD40E             BMI.N    ??I2C_Transmit_10
    388              {
    389                if (--I2C_Timeout == 0x00) 
   \   000000B0   0x....             LDR.N    R5,??DataTable4_16
   \   000000B2   0x682D             LDR      R5,[R5, #+0]
   \   000000B4   0x1E6D             SUBS     R5,R5,#+1
   \   000000B6   0x....             LDR.N    R6,??DataTable4_16
   \   000000B8   0x6035             STR      R5,[R6, #+0]
   \   000000BA   0x....             LDR.N    R5,??DataTable4_16
   \   000000BC   0x682D             LDR      R5,[R5, #+0]
   \   000000BE   0x2D00             CMP      R5,#+0
   \   000000C0   0xD1F3             BNE.N    ??I2C_Transmit_9
    390                {
    391                  /* Generate Stop */
    392                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000C2   0x8820             LDRH     R0,[R4, #+0]
   \   000000C4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000C8   0x8020             STRH     R0,[R4, #+0]
    393                  return I2C_TIMEout;
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xE01F             B.N      ??I2C_Transmit_2
    394                }
    395              }    
    396              /* Send I2C data */
    397              I2Cx->DR = *data;
   \                     ??I2C_Transmit_10: (+1)
   \   000000CE   0x7815             LDRB     R5,[R2, #+0]
   \   000000D0   0x8225             STRH     R5,[R4, #+16]
    398              data++;
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
    399              /* Wait until BTF flag is set */
    400              I2C_Timeout = I2C_TIMEOUT;
   \   000000D4   0xF640 0x35B8      MOVW     R5,#+3000
   \   000000D8   0x....             LDR.N    R6,??DataTable4_16
   \   000000DA   0x6035             STR      R5,[R6, #+0]
    401              while (!(I2Cx->SR1 & I2C_SR1_BTF)) 
   \                     ??I2C_Transmit_11: (+1)
   \   000000DC   0x8AA5             LDRH     R5,[R4, #+20]
   \   000000DE   0x076D             LSLS     R5,R5,#+29
   \   000000E0   0xD40E             BMI.N    ??I2C_Transmit_12
    402              {
    403                if (--I2C_Timeout == 0x00) 
   \   000000E2   0x....             LDR.N    R5,??DataTable4_16
   \   000000E4   0x682D             LDR      R5,[R5, #+0]
   \   000000E6   0x1E6D             SUBS     R5,R5,#+1
   \   000000E8   0x....             LDR.N    R6,??DataTable4_16
   \   000000EA   0x6035             STR      R5,[R6, #+0]
   \   000000EC   0x....             LDR.N    R5,??DataTable4_16
   \   000000EE   0x682D             LDR      R5,[R5, #+0]
   \   000000F0   0x2D00             CMP      R5,#+0
   \   000000F2   0xD1F3             BNE.N    ??I2C_Transmit_11
    404                {
    405                  /* Generate Stop */
    406                  I2Cx->CR1 |= I2C_CR1_STOP;
   \   000000F4   0x8820             LDRH     R0,[R4, #+0]
   \   000000F6   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   000000FA   0x8020             STRH     R0,[R4, #+0]
    407                  return I2C_TIMEout;
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0xE006             B.N      ??I2C_Transmit_2
    408                }
    409              }    
    410            }
   \                     ??I2C_Transmit_12: (+1)
   \   00000100   0x1C40             ADDS     R0,R0,#+1
   \   00000102   0xE7CA             B.N      ??I2C_Transmit_7
    411            //-------------- 
    412            /* Generate Stop */
    413            I2Cx->CR1 |= I2C_CR1_STOP;
   \                     ??I2C_Transmit_8: (+1)
   \   00000104   0x8820             LDRH     R0,[R4, #+0]
   \   00000106   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000010A   0x8020             STRH     R0,[R4, #+0]
    414            return I2C_OK;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??I2C_Transmit_2: (+1)
   \   0000010E   0xBC70             POP      {R4-R6}
   \   00000110   0x4770             BX       LR               ;; return
    415          }
    416          
    417          //-------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    418          u8    Check_Connect (I2C_TypeDef* I2Cx , u8 address)
    419          {
   \                     Check_Connect: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    420            I2C_Timeout = I2C_TIMEOUT;
   \   00000002   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000006   0x....             LDR.N    R3,??DataTable4_16
   \   00000008   0x6018             STR      R0,[R3, #+0]
    421            //--------------------
    422            /* Generate Start */
    423            I2Cx->CR1 |= I2C_CR1_START; 
   \   0000000A   0x8810             LDRH     R0,[R2, #+0]
   \   0000000C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000010   0x8010             STRH     R0,[R2, #+0]
    424            /* Wait until SB flag is set */
    425            I2C_Timeout = I2C_TIMEOUT;
   \   00000012   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000016   0x....             LDR.N    R3,??DataTable4_16
   \   00000018   0x6018             STR      R0,[R3, #+0]
    426            while(!(I2Cx->SR1 & I2C_SR1_SB)) 
   \                     ??Check_Connect_0: (+1)
   \   0000001A   0x8A90             LDRH     R0,[R2, #+20]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD40E             BMI.N    ??Check_Connect_1
    427            {
    428              if (--I2C_Timeout == 0x00) 
   \   00000020   0x....             LDR.N    R0,??DataTable4_16
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R3,??DataTable4_16
   \   00000028   0x6018             STR      R0,[R3, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable4_16
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??Check_Connect_0
    429              {
    430                /* Generate Stop */
    431                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000032   0x8810             LDRH     R0,[R2, #+0]
   \   00000034   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000038   0x8010             STRH     R0,[R2, #+0]
    432                return ERROR10;
   \   0000003A   0x200A             MOVS     R0,#+10
   \   0000003C   0xE01E             B.N      ??Check_Connect_2
    433              }      
    434            }
    435            //--------------------
    436            I2C_Timeout = I2C_TIMEOUT;
   \                     ??Check_Connect_1: (+1)
   \   0000003E   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000042   0x....             LDR.N    R3,??DataTable4_16
   \   00000044   0x6018             STR      R0,[R3, #+0]
    437            /* Send address with zero last bit */
    438            I2Cx->DR = address;   // address & write Bit
   \   00000046   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000048   0x8211             STRH     R1,[R2, #+16]
    439            /* Wait till finished */
    440            while (!(I2Cx->SR1 & I2C_SR1_ADDR)) 
   \                     ??Check_Connect_3: (+1)
   \   0000004A   0x8A90             LDRH     R0,[R2, #+20]
   \   0000004C   0x0780             LSLS     R0,R0,#+30
   \   0000004E   0xD40E             BMI.N    ??Check_Connect_4
    441            {
    442              if (--I2C_Timeout == 0x00) 
   \   00000050   0x....             LDR.N    R0,??DataTable4_16
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x....             LDR.N    R3,??DataTable4_16
   \   00000058   0x6018             STR      R0,[R3, #+0]
   \   0000005A   0x....             LDR.N    R0,??DataTable4_16
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1F3             BNE.N    ??Check_Connect_3
    443              {
    444                /* Generate Stop */
    445                I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000062   0x8810             LDRH     R0,[R2, #+0]
   \   00000064   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000068   0x8010             STRH     R0,[R2, #+0]
    446                //data_timeout = 0xE1;
    447                return ERROR20;
   \   0000006A   0x2014             MOVS     R0,#+20
   \   0000006C   0xE006             B.N      ??Check_Connect_2
    448              } 
    449            }
    450            /* Read status register to clear ADDR flag */
    451            I2Cx->SR1;
   \                     ??Check_Connect_4: (+1)
   \   0000006E   0x8A90             LDRH     R0,[R2, #+20]
    452            I2Cx->SR2;
   \   00000070   0x8B10             LDRH     R0,[R2, #+24]
    453            
    454            /* Generate Stop */
    455            I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000072   0x8810             LDRH     R0,[R2, #+0]
   \   00000074   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000078   0x8010             STRH     R0,[R2, #+0]
    456            //----------------------
    457            return CONNECTOK50;
   \   0000007A   0x2032             MOVS     R0,#+50
   \                     ??Check_Connect_2: (+1)
   \   0000007C   0x4770             BX       LR               ;; return
    458          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xC2480000         DC32     0xc2480000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     ??StateExhSensi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     EXH_DMARCV_Buffer_Data

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     ??CNT_ERR_Disconnect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     DATA_Sensors

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     ??CNT_ERR_Connect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     EXHData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     Sensirion_OFFset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     Sensirion_SCALE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     TimeDel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x........         DC32     EXH_DATACMD_Buffer+0x6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x........         DC32     Sensirion_SN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     I2C_Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x00030040         DC32     0x30040

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2
   \   00000000   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    459          ////----------------------------------------------------
    460          //
    461          //
    462          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Check_Connect
       8   Flow_SENSIRION_EXH_ReadDATA
         8   -> Check_Connect
         8   -> I2C_Receive
         8   -> I2C_Transmit
         8   -> RCC_APB1PeriphResetCmd
         8   -> init_I2C
      32   Flow_SENSIRION_EXH_ReadSN
        32   -> I2C_Receive
        32   -> I2C_Transmit
      24   I2C_Receive
        24   -> I2C_CheckEvent
      12   I2C_Transmit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
       2  ?_1
       2  ?_2
       8  ?_3
       1  CNT_ERR_Connect
       1  CNT_ERR_Disconnect
     126  Check_Connect
       4  EXHData
      12  EXH_DATACMD_Buffer
       2  EXH_DMARCV_Buffer_Data
     830  Flow_SENSIRION_EXH_ReadDATA
     454  Flow_SENSIRION_EXH_ReadSN
     256  I2C_Receive
       4  I2C_Timeout
     274  I2C_Transmit
       4  Sensirion_OFFset
       4  Sensirion_SCALE
       4  Sensirion_SN
       1  StateExhSensi
       1  TimeDel
       1  delaycnt

 
    26 bytes in section .bss
    13 bytes in section .data
    14 bytes in section .rodata
 2 020 bytes in section .text
 
 2 020 bytes of CODE  memory
    14 bytes of CONST memory
    39 bytes of DATA  memory

Errors: none
Warnings: none
