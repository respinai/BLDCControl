###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        05/Nov/2025  15:02:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
#    Command line =  
#        "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F40XX -lC "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\List\" -o "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\board\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\app\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2 added\modules\Header\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\" --relaxed_fp
#    List file    =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\List\stm32f4xx_usart.lst
#    Object file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\Obj\stm32f4xx_usart.o
#
###############################################################################

D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.2
      6            * @date    05-March-2012
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     74            *
     75            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     76            * You may not use this file except in compliance with the License.
     77            * You may obtain a copy of the License at:
     78            *
     79            *        http://www.st.com/software_license_agreement_liberty_v2
     80            *
     81            * Unless required by applicable law or agreed to in writing, software 
     82            * distributed under the License is distributed on an "AS IS" BASIS, 
     83            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     84            * See the License for the specific language governing permissions and
     85            * limitations under the License.
     86            *
     87            ******************************************************************************
     88            */ 
     89          
     90          /* Includes ------------------------------------------------------------------*/
     91          #include "stm32f4xx_usart.h"
     92          #include "stm32f4xx_rcc.h"
     93          
     94          /** @addtogroup STM32F4xx_StdPeriph_Driver
     95            * @{
     96            */
     97          
     98          /** @defgroup USART 
     99            * @brief USART driver modules
    100            * @{
    101            */
    102          
    103          /* Private typedef -----------------------------------------------------------*/
    104          /* Private define ------------------------------------------------------------*/
    105          
    106          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
    107          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
    108                                                        USART_CR1_PS | USART_CR1_TE | \
    109                                                        USART_CR1_RE))
    110          
    111          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    112          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    113                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    114          
    115          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    116          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    117          
    118          /*!< USART Interrupts mask */
    119          #define IT_MASK                   ((uint16_t)0x001F)
    120          
    121          /* Private macro -------------------------------------------------------------*/
    122          /* Private variables ---------------------------------------------------------*/
    123          /* Private function prototypes -----------------------------------------------*/
    124          /* Private functions ---------------------------------------------------------*/
    125          
    126          /** @defgroup USART_Private_Functions
    127            * @{
    128            */
    129          
    130          /** @defgroup USART_Group1 Initialization and Configuration functions
    131           *  @brief   Initialization and Configuration functions 
    132           *
    133          @verbatim   
    134           ===============================================================================
    135                            Initialization and Configuration functions
    136           ===============================================================================  
    137          
    138            This subsection provides a set of functions allowing to initialize the USART 
    139            in asynchronous and in synchronous modes.
    140             - For the asynchronous mode only these parameters can be configured: 
    141                  - Baud Rate
    142                  - Word Length 
    143                  - Stop Bit
    144                  - Parity: If the parity is enabled, then the MSB bit of the data written
    145                    in the data register is transmitted but is changed by the parity bit.
    146                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    147                    the possible USART frame formats are as listed in the following table:
    148             +-------------------------------------------------------------+     
    149             |   M bit |  PCE bit  |            USART frame                |
    150             |---------------------|---------------------------------------|             
    151             |    0    |    0      |    | SB | 8 bit data | STB |          |
    152             |---------|-----------|---------------------------------------|  
    153             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    154             |---------|-----------|---------------------------------------|  
    155             |    1    |    0      |    | SB | 9 bit data | STB |          |
    156             |---------|-----------|---------------------------------------|  
    157             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    158             +-------------------------------------------------------------+            
    159                  - Hardware flow control
    160                  - Receiver/transmitter modes
    161          
    162            The USART_Init() function follows the USART  asynchronous configuration procedure
    163            (details for the procedure are available in reference manual (RM0090)).
    164          
    165            - For the synchronous mode in addition to the asynchronous mode parameters these 
    166              parameters should be also configured:
    167                  - USART Clock Enabled
    168                  - USART polarity
    169                  - USART phase
    170                  - USART LastBit
    171            
    172            These parameters can be configured using the USART_ClockInit() function.
    173          
    174          @endverbatim
    175            * @{
    176            */
    177            
    178          /**
    179            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    180            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    181            *         UART peripheral.
    182            * @retval None
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          void USART_DeInit(USART_TypeDef* USARTx)
    185          {
   \                     USART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    186            /* Check the parameters */
    187            assert_param(IS_USART_ALL_PERIPH(USARTx));
    188          
    189            if (USARTx == USART1)
   \   00000004   0x....             LDR.N    R0,??DataTable1  ;; 0x40011000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD108             BNE.N    ??USART_DeInit_0
    190            {
    191              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    192              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
   \   0000001A   0xE042             B.N      ??USART_DeInit_1
    193            }
    194            else if (USARTx == USART2)
   \                     ??USART_DeInit_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable1_1  ;; 0x40004400
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD10A             BNE.N    ??USART_DeInit_2
    195            {
    196              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000028   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    197              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000032   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000036   0xE034             B.N      ??USART_DeInit_1
    198            }
    199            else if (USARTx == USART3)
   \                     ??USART_DeInit_2: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable1_2  ;; 0x40004800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD10A             BNE.N    ??USART_DeInit_3
    200            {
    201              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000044   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    202              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000004E   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   00000052   0xE026             B.N      ??USART_DeInit_1
    203            }    
    204            else if (USARTx == UART4)
   \                     ??USART_DeInit_3: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable1_3  ;; 0x40004c00
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD10A             BNE.N    ??USART_DeInit_4
    205            {
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000060   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000006A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000006E   0xE018             B.N      ??USART_DeInit_1
    208            }
    209            else if (USARTx == UART5)
   \                     ??USART_DeInit_4: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable1_4  ;; 0x40005000
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD10A             BNE.N    ??USART_DeInit_5
    210            {
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0xF45F 0x1080      MOVS     R0,#+1048576
   \   0000007C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF45F 0x1080      MOVS     R0,#+1048576
   \   00000086   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
   \   0000008A   0xE00A             B.N      ??USART_DeInit_1
    213            }     
    214            else
    215            {
    216              if (USARTx == USART6)
   \                     ??USART_DeInit_5: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40011400
   \   0000008E   0x4284             CMP      R4,R0
   \   00000090   0xD107             BNE.N    ??USART_DeInit_1
    217              { 
    218                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x2020             MOVS     R0,#+32
   \   00000096   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    219                RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x2020             MOVS     R0,#+32
   \   0000009E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    220              }
    221            }
    222          }
   \                     ??USART_DeInit_1: (+1)
   \   000000A2   0xBD10             POP      {R4,PC}          ;; return
    223          
    224          /**
    225            * @brief  Initializes the USARTx peripheral according to the specified
    226            *         parameters in the USART_InitStruct .
    227            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    228            *         UART peripheral.
    229            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
    230            *         the configuration information for the specified USART peripheral.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    234          {
   \                     USART_Init: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
    235            uint32_t tmpreg = 0x00, apbclock = 0x00;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   \   0000000E   0x2600             MOVS     R6,#+0
    236            uint32_t integerdivider = 0x00;
   \   00000010   0x2700             MOVS     R7,#+0
    237            uint32_t fractionaldivider = 0x00;
   \   00000012   0xF05F 0x0800      MOVS     R8,#+0
    238            RCC_ClocksTypeDef RCC_ClocksStatus;
    239          
    240            /* Check the parameters */
    241            assert_param(IS_USART_ALL_PERIPH(USARTx));
    242            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
    243            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
    244            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
    245            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
    246            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
    247            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
    248          
    249            /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    250            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
   \   00000016   0x89A8             LDRH     R0,[R5, #+12]
   \   00000018   0x2800             CMP      R0,#+0
    251            {
    252              assert_param(IS_USART_1236_PERIPH(USARTx));
    253            }
    254          
    255          /*---------------------------- USART CR2 Configuration -----------------------*/
    256            tmpreg = USARTx->CR2;
   \                     ??USART_Init_0: (+1)
   \   0000001A   0x8A20             LDRH     R0,[R4, #+16]
   \   0000001C   0x4681             MOV      R9,R0
    257          
    258            /* Clear STOP[13:12] bits */
    259            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
   \   0000001E   0xF439 0x5940      BICS     R9,R9,#0x3000
    260          
    261            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
    262                Set STOP[13:12] bits according to USART_StopBits value */
    263            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
   \   00000022   0x88E8             LDRH     R0,[R5, #+6]
   \   00000024   0xEA50 0x0909      ORRS     R9,R0,R9
    264            
    265            /* Write to USART CR2 */
    266            USARTx->CR2 = (uint16_t)tmpreg;
   \   00000028   0xF8A4 0x9010      STRH     R9,[R4, #+16]
    267          
    268          /*---------------------------- USART CR1 Configuration -----------------------*/
    269            tmpreg = USARTx->CR1;
   \   0000002C   0x89A0             LDRH     R0,[R4, #+12]
   \   0000002E   0x4681             MOV      R9,R0
    270          
    271            /* Clear M, PCE, PS, TE and RE bits */
    272            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
   \   00000030   0x....             LDR.N    R0,??DataTable1_6  ;; 0xffffe9f3
   \   00000032   0xEA10 0x0909      ANDS     R9,R0,R9
    273          
    274            /* Configure the USART Word Length, Parity and mode: 
    275               Set the M bits according to USART_WordLength value 
    276               Set PCE and PS bits according to USART_Parity value
    277               Set TE and RE bits according to USART_Mode value */
    278            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    279                      USART_InitStruct->USART_Mode;
   \   00000036   0x88A8             LDRH     R0,[R5, #+4]
   \   00000038   0x8929             LDRH     R1,[R5, #+8]
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0x8969             LDRH     R1,[R5, #+10]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0xEA50 0x0909      ORRS     R9,R0,R9
    280          
    281            /* Write to USART CR1 */
    282            USARTx->CR1 = (uint16_t)tmpreg;
   \   00000044   0xF8A4 0x900C      STRH     R9,[R4, #+12]
    283          
    284          /*---------------------------- USART CR3 Configuration -----------------------*/  
    285            tmpreg = USARTx->CR3;
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0x4681             MOV      R9,R0
    286          
    287            /* Clear CTSE and RTSE bits */
    288            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
   \   0000004C   0xF439 0x7940      BICS     R9,R9,#0x300
    289          
    290            /* Configure the USART HFC : 
    291                Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    292            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
   \   00000050   0x89A8             LDRH     R0,[R5, #+12]
   \   00000052   0xEA50 0x0909      ORRS     R9,R0,R9
    293          
    294            /* Write to USART CR3 */
    295            USARTx->CR3 = (uint16_t)tmpreg;
   \   00000056   0xF8A4 0x9014      STRH     R9,[R4, #+20]
    296          
    297          /*---------------------------- USART BRR Configuration -----------------------*/
    298            /* Configure the USART Baud Rate */
    299            RCC_GetClocksFreq(&RCC_ClocksStatus);
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       RCC_GetClocksFreq
    300          
    301            if ((USARTx == USART1) || (USARTx == USART6))
   \   00000060   0x....             LDR.N    R0,??DataTable1  ;; 0x40011000
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD002             BEQ.N    ??USART_Init_1
   \   00000066   0x....             LDR.N    R0,??DataTable1_5  ;; 0x40011400
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD102             BNE.N    ??USART_Init_2
    302            {
    303              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
   \                     ??USART_Init_1: (+1)
   \   0000006C   0x9803             LDR      R0,[SP, #+12]
   \   0000006E   0x0006             MOVS     R6,R0
   \   00000070   0xE001             B.N      ??USART_Init_3
    304            }
    305            else
    306            {
    307              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
   \                     ??USART_Init_2: (+1)
   \   00000072   0x9802             LDR      R0,[SP, #+8]
   \   00000074   0x0006             MOVS     R6,R0
    308            }
    309            
    310            /* Determine the integer part */
    311            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \                     ??USART_Init_3: (+1)
   \   00000076   0x89A0             LDRH     R0,[R4, #+12]
   \   00000078   0x0400             LSLS     R0,R0,#+16
   \   0000007A   0xD508             BPL.N    ??USART_Init_4
    312            {
    313              /* Integer part computing in case Oversampling mode is 8 Samples */
    314              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
   \   0000007C   0x2019             MOVS     R0,#+25
   \   0000007E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000082   0x6829             LDR      R1,[R5, #+0]
   \   00000084   0x0049             LSLS     R1,R1,#+1
   \   00000086   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000008A   0x0007             MOVS     R7,R0
   \   0000008C   0xE007             B.N      ??USART_Init_5
    315            }
    316            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    317            {
    318              /* Integer part computing in case Oversampling mode is 16 Samples */
    319              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
   \                     ??USART_Init_4: (+1)
   \   0000008E   0x2019             MOVS     R0,#+25
   \   00000090   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000094   0x6829             LDR      R1,[R5, #+0]
   \   00000096   0x0089             LSLS     R1,R1,#+2
   \   00000098   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000009C   0x0007             MOVS     R7,R0
    320            }
    321            tmpreg = (integerdivider / 100) << 4;
   \                     ??USART_Init_5: (+1)
   \   0000009E   0x2064             MOVS     R0,#+100
   \   000000A0   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   000000A4   0x0100             LSLS     R0,R0,#+4
   \   000000A6   0x4681             MOV      R9,R0
    322          
    323            /* Determine the fractional part */
    324            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
   \   000000A8   0xEA5F 0x1019      LSRS     R0,R9,#+4
   \   000000AC   0x2164             MOVS     R1,#+100
   \   000000AE   0xFB01 0x7010      MLS      R0,R1,R0,R7
   \   000000B2   0x4680             MOV      R8,R0
    325          
    326            /* Implement the fractional part in the register */
    327            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \   000000B4   0x89A0             LDRH     R0,[R4, #+12]
   \   000000B6   0x0400             LSLS     R0,R0,#+16
   \   000000B8   0xD50A             BPL.N    ??USART_Init_6
    328            {
    329              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
   \   000000BA   0xEA5F 0x00C8      LSLS     R0,R8,#+3
   \   000000BE   0x3032             ADDS     R0,R0,#+50
   \   000000C0   0x2164             MOVS     R1,#+100
   \   000000C2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000C6   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000000CA   0xEA50 0x0909      ORRS     R9,R0,R9
   \   000000CE   0xE009             B.N      ??USART_Init_7
    330            }
    331            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    332            {
    333              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
   \                     ??USART_Init_6: (+1)
   \   000000D0   0xEA5F 0x1008      LSLS     R0,R8,#+4
   \   000000D4   0x3032             ADDS     R0,R0,#+50
   \   000000D6   0x2164             MOVS     R1,#+100
   \   000000D8   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000DC   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000E0   0xEA50 0x0909      ORRS     R9,R0,R9
    334            }
    335            
    336            /* Write to USART BRR register */
    337            USARTx->BRR = (uint16_t)tmpreg;
   \                     ??USART_Init_7: (+1)
   \   000000E4   0xF8A4 0x9008      STRH     R9,[R4, #+8]
    338          }
   \   000000E8   0xB005             ADD      SP,SP,#+20
   \   000000EA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    339          
    340          /**
    341            * @brief  Fills each USART_InitStruct member with its default value.
    342            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
    343            *         be initialized.
    344            * @retval None
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    347          {
    348            /* USART_InitStruct members default value */
    349            USART_InitStruct->USART_BaudRate = 9600;
   \                     USART_StructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    350            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    351            USART_InitStruct->USART_StopBits = USART_StopBits_1;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
    352            USART_InitStruct->USART_Parity = USART_Parity_No ;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8101             STRH     R1,[R0, #+8]
    353            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x8141             STRH     R1,[R0, #+10]
    354            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x8181             STRH     R1,[R0, #+12]
    355          }
   \   0000001A   0x4770             BX       LR               ;; return
    356          
    357          /**
    358            * @brief  Initializes the USARTx peripheral Clock according to the 
    359            *         specified parameters in the USART_ClockInitStruct .
    360            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    361            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    362            *         contains the configuration information for the specified  USART peripheral.
    363            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    364            * @retval None
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    367          {
   \                     USART_ClockInit: (+1)
   \   00000000   0xB410             PUSH     {R4}
    368            uint32_t tmpreg = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    369            /* Check the parameters */
    370            assert_param(IS_USART_1236_PERIPH(USARTx));
    371            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
    372            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
    373            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
    374            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
    375            
    376          /*---------------------------- USART CR2 Configuration -----------------------*/
    377            tmpreg = USARTx->CR2;
   \   00000004   0x8A03             LDRH     R3,[R0, #+16]
   \   00000006   0x001A             MOVS     R2,R3
    378            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    379            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
   \   00000008   0xF432 0x6270      BICS     R2,R2,#0xF00
    380            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    381            /* Set CLKEN bit according to USART_Clock value */
    382            /* Set CPOL bit according to USART_CPOL value */
    383            /* Set CPHA bit according to USART_CPHA value */
    384            /* Set LBCL bit according to USART_LastBit value */
    385            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    386                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
   \   0000000C   0x880B             LDRH     R3,[R1, #+0]
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x888C             LDRH     R4,[R1, #+4]
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x88CC             LDRH     R4,[R1, #+6]
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0x431A             ORRS     R2,R3,R2
    387            /* Write to USART CR2 */
    388            USARTx->CR2 = (uint16_t)tmpreg;
   \   0000001C   0x8202             STRH     R2,[R0, #+16]
    389          }
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    390          
    391          /**
    392            * @brief  Fills each USART_ClockInitStruct member with its default value.
    393            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    394            *         which will be initialized.
    395            * @retval None
    396            */

   \                                 In section .text, align 2, keep-with-next
    397          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    398          {
    399            /* USART_ClockInitStruct members default value */
    400            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
   \                     USART_ClockStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    401            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    402            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    403            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    404          }
   \   00000010   0x4770             BX       LR               ;; return
    405          
    406          /**
    407            * @brief  Enables or disables the specified USART peripheral.
    408            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    409            *         UART peripheral.
    410            * @param  NewState: new state of the USARTx peripheral.
    411            *          This parameter can be: ENABLE or DISABLE.
    412            * @retval None
    413            */

   \                                 In section .text, align 2, keep-with-next
    414          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    415          {
    416            /* Check the parameters */
    417            assert_param(IS_USART_ALL_PERIPH(USARTx));
    418            assert_param(IS_FUNCTIONAL_STATE(NewState));
    419            
    420            if (NewState != DISABLE)
   \                     USART_Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_Cmd_0
    421            {
    422              /* Enable the selected USART by setting the UE bit in the CR1 register */
    423              USARTx->CR1 |= USART_CR1_UE;
   \   00000006   0x8982             LDRH     R2,[R0, #+12]
   \   00000008   0xF452 0x5200      ORRS     R2,R2,#0x2000
   \   0000000C   0x8182             STRH     R2,[R0, #+12]
   \   0000000E   0xE004             B.N      ??USART_Cmd_1
    424            }
    425            else
    426            {
    427              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    428              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
   \                     ??USART_Cmd_0: (+1)
   \   00000010   0x8982             LDRH     R2,[R0, #+12]
   \   00000012   0xF64D 0x73FF      MOVW     R3,#+57343
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8182             STRH     R2,[R0, #+12]
    429            }
    430          }
   \                     ??USART_Cmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    431          
    432          /**
    433            * @brief  Sets the system clock prescaler.
    434            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    435            *         UART peripheral.
    436            * @param  USART_Prescaler: specifies the prescaler clock. 
    437            * @note   The function is used for IrDA mode with UART4 and UART5.   
    438            * @retval None
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    441          { 
    442            /* Check the parameters */
    443            assert_param(IS_USART_ALL_PERIPH(USARTx));
    444            
    445            /* Clear the USART prescaler */
    446            USARTx->GTPR &= USART_GTPR_GT;
   \                     USART_SetPrescaler: (+1)
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xF412 0x427F      ANDS     R2,R2,#0xFF00
   \   00000006   0x8302             STRH     R2,[R0, #+24]
    447            /* Set the USART prescaler */
    448            USARTx->GTPR |= USART_Prescaler;
   \   00000008   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
    449          }
   \   00000010   0x4770             BX       LR               ;; return
    450          
    451          /**
    452            * @brief  Enables or disables the USART's 8x oversampling mode.
    453            * @note   This function has to be called before calling USART_Init() function
    454            *         in order to have correct baudrate Divider value.
    455            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    456            *         UART peripheral.
    457            * @param  NewState: new state of the USART 8x oversampling mode.
    458            *          This parameter can be: ENABLE or DISABLE.
    459            * @retval None
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    462          {
    463            /* Check the parameters */
    464            assert_param(IS_USART_ALL_PERIPH(USARTx));
    465            assert_param(IS_FUNCTIONAL_STATE(NewState));
    466            
    467            if (NewState != DISABLE)
   \                     USART_OverSampling8Cmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_OverSampling8Cmd_0
    468            {
    469              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    470              USARTx->CR1 |= USART_CR1_OVER8;
   \   00000006   0x8982             LDRH     R2,[R0, #+12]
   \   00000008   0xF452 0x4200      ORRS     R2,R2,#0x8000
   \   0000000C   0x8182             STRH     R2,[R0, #+12]
   \   0000000E   0xE003             B.N      ??USART_OverSampling8Cmd_1
    471            }
    472            else
    473            {
    474              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    475              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
   \                     ??USART_OverSampling8Cmd_0: (+1)
   \   00000010   0x8982             LDRH     R2,[R0, #+12]
   \   00000012   0x0452             LSLS     R2,R2,#+17       ;; ZeroExtS R2,R2,#+17,#+17
   \   00000014   0x0C52             LSRS     R2,R2,#+17
   \   00000016   0x8182             STRH     R2,[R0, #+12]
    476            }
    477          }  
   \                     ??USART_OverSampling8Cmd_1: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    478          
    479          /**
    480            * @brief  Enables or disables the USART's one bit sampling method.
    481            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    482            *         UART peripheral.
    483            * @param  NewState: new state of the USART one bit sampling method.
    484            *          This parameter can be: ENABLE or DISABLE.
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    488          {
    489            /* Check the parameters */
    490            assert_param(IS_USART_ALL_PERIPH(USARTx));
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492            
    493            if (NewState != DISABLE)
   \                     USART_OneBitMethodCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_OneBitMethodCmd_0
    494            {
    495              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    496              USARTx->CR3 |= USART_CR3_ONEBIT;
   \   00000006   0x8A82             LDRH     R2,[R0, #+20]
   \   00000008   0xF452 0x6200      ORRS     R2,R2,#0x800
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
   \   0000000E   0xE004             B.N      ??USART_OneBitMethodCmd_1
    497            }
    498            else
    499            {
    500              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    501              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
   \                     ??USART_OneBitMethodCmd_0: (+1)
   \   00000010   0x8A82             LDRH     R2,[R0, #+20]
   \   00000012   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8282             STRH     R2,[R0, #+20]
    502            }
    503          }
   \                     ??USART_OneBitMethodCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    504          
    505          /**
    506            * @}
    507            */
    508          
    509          /** @defgroup USART_Group2 Data transfers functions
    510           *  @brief   Data transfers functions 
    511           *
    512          @verbatim   
    513           ===============================================================================
    514                                      Data transfers functions
    515           ===============================================================================  
    516          
    517            This subsection provides a set of functions allowing to manage the USART data 
    518            transfers.
    519            
    520            During an USART reception, data shifts in least significant bit first through 
    521            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    522            between the internal bus and the received shift register.
    523          
    524            When a transmission is taking place, a write instruction to the USART_DR register 
    525            stores the data in the TDR register and which is copied in the shift register 
    526            at the end of the current transmission.
    527          
    528            The read access of the USART_DR register can be done using the USART_ReceiveData()
    529            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    530            can be done using USART_SendData() function and stores the written data into 
    531            TDR buffer.
    532          
    533          @endverbatim
    534            * @{
    535            */
    536          
    537          /**
    538            * @brief  Transmits single data through the USARTx peripheral.
    539            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    540            *         UART peripheral.
    541            * @param  Data: the data to transmit.
    542            * @retval None
    543            */

   \                                 In section .text, align 2, keep-with-next
    544          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    545          {
    546            /* Check the parameters */
    547            assert_param(IS_USART_ALL_PERIPH(USARTx));
    548            assert_param(IS_USART_DATA(Data)); 
    549              
    550            /* Transmit Data */
    551            USARTx->DR = (Data & (uint16_t)0x01FF);
   \                     USART_SendData: (+1)
   \   00000000   0x05CA             LSLS     R2,R1,#+23       ;; ZeroExtS R2,R1,#+23,#+23
   \   00000002   0x0DD2             LSRS     R2,R2,#+23
   \   00000004   0x8082             STRH     R2,[R0, #+4]
    552          }
   \   00000006   0x4770             BX       LR               ;; return
    553          
    554          /**
    555            * @brief  Returns the most recent received data by the USARTx peripheral.
    556            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    557            *         UART peripheral.
    558            * @retval The received data.
    559            */

   \                                 In section .text, align 2, keep-with-next
    560          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    561          {
    562            /* Check the parameters */
    563            assert_param(IS_USART_ALL_PERIPH(USARTx));
    564            
    565            /* Receive Data */
    566            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
   \                     USART_ReceiveData: (+1)
   \   00000000   0x8880             LDRH     R0,[R0, #+4]
   \   00000002   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000004   0x0DC0             LSRS     R0,R0,#+23
   \   00000006   0x4770             BX       LR               ;; return
    567          }
    568          
    569          /**
    570            * @}
    571            */
    572          
    573          /** @defgroup USART_Group3 MultiProcessor Communication functions
    574           *  @brief   Multi-Processor Communication functions 
    575           *
    576          @verbatim   
    577           ===============================================================================
    578                              Multi-Processor Communication functions
    579           ===============================================================================  
    580          
    581            This subsection provides a set of functions allowing to manage the USART 
    582            multiprocessor communication.
    583            
    584            For instance one of the USARTs can be the master, its TX output is connected to 
    585            the RX input of the other USART. The others are slaves, their respective TX outputs 
    586            are logically ANDed together and connected to the RX input of the master.
    587          
    588            USART multiprocessor communication is possible through the following procedure:
    589               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    590                  or Mode receiver and hardware flow control values using the USART_Init()
    591                  function.
    592               2. Configures the USART address using the USART_SetAddress() function.
    593               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    594                  using USART_WakeUpConfig() function only for the slaves.
    595               4. Enable the USART using the USART_Cmd() function.
    596               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    597          
    598            The USART Slave exit from mute mode when receive the wake up condition.
    599          
    600          @endverbatim
    601            * @{
    602            */
    603          
    604          /**
    605            * @brief  Sets the address of the USART node.
    606            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    607            *         UART peripheral.
    608            * @param  USART_Address: Indicates the address of the USART node.
    609            * @retval None
    610            */

   \                                 In section .text, align 2, keep-with-next
    611          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    612          {
    613            /* Check the parameters */
    614            assert_param(IS_USART_ALL_PERIPH(USARTx));
    615            assert_param(IS_USART_ADDRESS(USART_Address)); 
    616              
    617            /* Clear the USART address */
    618            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
   \                     USART_SetAddress: (+1)
   \   00000000   0x8A02             LDRH     R2,[R0, #+16]
   \   00000002   0xF64F 0x73F0      MOVW     R3,#+65520
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8202             STRH     R2,[R0, #+16]
    619            /* Set the USART address node */
    620            USARTx->CR2 |= USART_Address;
   \   0000000A   0x8A02             LDRH     R2,[R0, #+16]
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x430A             ORRS     R2,R1,R2
   \   00000010   0x8202             STRH     R2,[R0, #+16]
    621          }
   \   00000012   0x4770             BX       LR               ;; return
    622          
    623          /**
    624            * @brief  Determines if the USART is in mute mode or not.
    625            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    626            *         UART peripheral.
    627            * @param  NewState: new state of the USART mute mode.
    628            *          This parameter can be: ENABLE or DISABLE.
    629            * @retval None
    630            */

   \                                 In section .text, align 2, keep-with-next
    631          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    632          {
    633            /* Check the parameters */
    634            assert_param(IS_USART_ALL_PERIPH(USARTx));
    635            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    636            
    637            if (NewState != DISABLE)
   \                     USART_ReceiverWakeUpCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_0
    638            {
    639              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    640              USARTx->CR1 |= USART_CR1_RWU;
   \   00000006   0x8982             LDRH     R2,[R0, #+12]
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x8182             STRH     R2,[R0, #+12]
   \   0000000E   0xE004             B.N      ??USART_ReceiverWakeUpCmd_1
    641            }
    642            else
    643            {
    644              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    645              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
   \                     ??USART_ReceiverWakeUpCmd_0: (+1)
   \   00000010   0x8982             LDRH     R2,[R0, #+12]
   \   00000012   0xF64F 0x73FD      MOVW     R3,#+65533
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8182             STRH     R2,[R0, #+12]
    646            }
    647          }
   \                     ??USART_ReceiverWakeUpCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    648          /**
    649            * @brief  Selects the USART WakeUp method.
    650            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    651            *         UART peripheral.
    652            * @param  USART_WakeUp: specifies the USART wakeup method.
    653            *          This parameter can be one of the following values:
    654            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    655            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    656            * @retval None
    657            */

   \                                 In section .text, align 2, keep-with-next
    658          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    659          {
    660            /* Check the parameters */
    661            assert_param(IS_USART_ALL_PERIPH(USARTx));
    662            assert_param(IS_USART_WAKEUP(USART_WakeUp));
    663            
    664            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
   \                     USART_WakeUpConfig: (+1)
   \   00000000   0x8982             LDRH     R2,[R0, #+12]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8182             STRH     R2,[R0, #+12]
    665            USARTx->CR1 |= USART_WakeUp;
   \   0000000A   0x8982             LDRH     R2,[R0, #+12]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8182             STRH     R2,[R0, #+12]
    666          }
   \   00000010   0x4770             BX       LR               ;; return
    667          
    668          /**
    669            * @}
    670            */
    671          
    672          /** @defgroup USART_Group4 LIN mode functions
    673           *  @brief   LIN mode functions 
    674           *
    675          @verbatim   
    676           ===============================================================================
    677                                          LIN mode functions
    678           ===============================================================================  
    679          
    680            This subsection provides a set of functions allowing to manage the USART LIN 
    681            Mode communication.
    682            
    683            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    684            the LIN standard.
    685          
    686            Only this LIN Feature is supported by the USART IP:
    687              - LIN Master Synchronous Break send capability and LIN slave break detection
    688                capability :  13-bit break generation and 10/11 bit break detection
    689          
    690          
    691            USART LIN Master transmitter communication is possible through the following procedure:
    692               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    693                  Mode transmitter or Mode receiver and hardware flow control values using 
    694                  the USART_Init() function.
    695               2. Enable the USART using the USART_Cmd() function.
    696               3. Enable the LIN mode using the USART_LINCmd() function.
    697               4. Send the break character using USART_SendBreak() function.
    698          
    699            USART LIN Master receiver communication is possible through the following procedure:
    700               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    701                  Mode transmitter or Mode receiver and hardware flow control values using 
    702                  the USART_Init() function.
    703               2. Enable the USART using the USART_Cmd() function.
    704               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    705                  function.
    706               4. Enable the LIN mode using the USART_LINCmd() function.
    707          
    708          
    709          @note In LIN mode, the following bits must be kept cleared:
    710                  - CLKEN in the USART_CR2 register,
    711                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    712          
    713          @endverbatim
    714            * @{
    715            */
    716          
    717          /**
    718            * @brief  Sets the USART LIN Break detection length.
    719            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    720            *         UART peripheral.
    721            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    722            *          This parameter can be one of the following values:
    723            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    724            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    725            * @retval None
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    728          {
    729            /* Check the parameters */
    730            assert_param(IS_USART_ALL_PERIPH(USARTx));
    731            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
    732            
    733            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
   \                     USART_LINBreakDetectLengthConfig: (+1)
   \   00000000   0x8A02             LDRH     R2,[R0, #+16]
   \   00000002   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8202             STRH     R2,[R0, #+16]
    734            USARTx->CR2 |= USART_LINBreakDetectLength;  
   \   0000000A   0x8A02             LDRH     R2,[R0, #+16]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8202             STRH     R2,[R0, #+16]
    735          }
   \   00000010   0x4770             BX       LR               ;; return
    736          
    737          /**
    738            * @brief  Enables or disables the USART's LIN mode.
    739            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    740            *         UART peripheral.
    741            * @param  NewState: new state of the USART LIN mode.
    742            *          This parameter can be: ENABLE or DISABLE.
    743            * @retval None
    744            */

   \                                 In section .text, align 2, keep-with-next
    745          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    746          {
    747            /* Check the parameters */
    748            assert_param(IS_USART_ALL_PERIPH(USARTx));
    749            assert_param(IS_FUNCTIONAL_STATE(NewState));
    750            
    751            if (NewState != DISABLE)
   \                     USART_LINCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_LINCmd_0
    752            {
    753              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    754              USARTx->CR2 |= USART_CR2_LINEN;
   \   00000006   0x8A02             LDRH     R2,[R0, #+16]
   \   00000008   0xF452 0x4280      ORRS     R2,R2,#0x4000
   \   0000000C   0x8202             STRH     R2,[R0, #+16]
   \   0000000E   0xE004             B.N      ??USART_LINCmd_1
    755            }
    756            else
    757            {
    758              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    759              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
   \                     ??USART_LINCmd_0: (+1)
   \   00000010   0x8A02             LDRH     R2,[R0, #+16]
   \   00000012   0xF64B 0x73FF      MOVW     R3,#+49151
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8202             STRH     R2,[R0, #+16]
    760            }
    761          }
   \                     ??USART_LINCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    762          
    763          /**
    764            * @brief  Transmits break characters.
    765            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    766            *         UART peripheral.
    767            * @retval None
    768            */

   \                                 In section .text, align 2, keep-with-next
    769          void USART_SendBreak(USART_TypeDef* USARTx)
    770          {
    771            /* Check the parameters */
    772            assert_param(IS_USART_ALL_PERIPH(USARTx));
    773            
    774            /* Send break characters */
    775            USARTx->CR1 |= USART_CR1_SBK;
   \                     USART_SendBreak: (+1)
   \   00000000   0x8981             LDRH     R1,[R0, #+12]
   \   00000002   0xF051 0x0101      ORRS     R1,R1,#0x1
   \   00000006   0x8181             STRH     R1,[R0, #+12]
    776          }
   \   00000008   0x4770             BX       LR               ;; return
    777          
    778          /**
    779            * @}
    780            */
    781          
    782          /** @defgroup USART_Group5 Halfduplex mode function
    783           *  @brief   Half-duplex mode function 
    784           *
    785          @verbatim   
    786           ===============================================================================
    787                                   Half-duplex mode function
    788           ===============================================================================  
    789          
    790            This subsection provides a set of functions allowing to manage the USART 
    791            Half-duplex communication.
    792            
    793            The USART can be configured to follow a single-wire half-duplex protocol where 
    794            the TX and RX lines are internally connected.
    795          
    796            USART Half duplex communication is possible through the following procedure:
    797               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    798                  or Mode receiver and hardware flow control values using the USART_Init()
    799                  function.
    800               2. Configures the USART address using the USART_SetAddress() function.
    801               3. Enable the USART using the USART_Cmd() function.
    802               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    803          
    804          
    805          @note The RX pin is no longer used
    806          @note In Half-duplex mode the following bits must be kept cleared:
    807                  - LINEN and CLKEN bits in the USART_CR2 register.
    808                  - SCEN and IREN bits in the USART_CR3 register.
    809          
    810          @endverbatim
    811            * @{
    812            */
    813          
    814          /**
    815            * @brief  Enables or disables the USART's Half Duplex communication.
    816            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    817            *         UART peripheral.
    818            * @param  NewState: new state of the USART Communication.
    819            *          This parameter can be: ENABLE or DISABLE.
    820            * @retval None
    821            */

   \                                 In section .text, align 2, keep-with-next
    822          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    823          {
    824            /* Check the parameters */
    825            assert_param(IS_USART_ALL_PERIPH(USARTx));
    826            assert_param(IS_FUNCTIONAL_STATE(NewState));
    827            
    828            if (NewState != DISABLE)
   \                     USART_HalfDuplexCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_HalfDuplexCmd_0
    829            {
    830              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    831              USARTx->CR3 |= USART_CR3_HDSEL;
   \   00000006   0x8A82             LDRH     R2,[R0, #+20]
   \   00000008   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
   \   0000000E   0xE004             B.N      ??USART_HalfDuplexCmd_1
    832            }
    833            else
    834            {
    835              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    836              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
   \                     ??USART_HalfDuplexCmd_0: (+1)
   \   00000010   0x8A82             LDRH     R2,[R0, #+20]
   \   00000012   0xF64F 0x73F7      MOVW     R3,#+65527
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8282             STRH     R2,[R0, #+20]
    837            }
    838          }
   \                     ??USART_HalfDuplexCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    839          
    840          /**
    841            * @}
    842            */
    843          
    844          
    845          /** @defgroup USART_Group6 Smartcard mode functions
    846           *  @brief   Smartcard mode functions 
    847           *
    848          @verbatim   
    849           ===============================================================================
    850                                         Smartcard mode functions
    851           ===============================================================================  
    852          
    853            This subsection provides a set of functions allowing to manage the USART 
    854            Smartcard communication.
    855            
    856            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    857            defined in the ISO 7816-3 standard.
    858          
    859            The USART can provide a clock to the smartcard through the SCLK output.
    860            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    861            from the internal peripheral input clock through a 5-bit prescaler.
    862          
    863            Smartcard communication is possible through the following procedure:
    864               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    865               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    866               3. Program the USART clock using the USART_ClockInit() function as following:
    867                  - USART Clock enabled
    868                  - USART CPOL Low
    869                  - USART CPHA on first edge
    870                  - USART Last Bit Clock Enabled
    871               4. Program the Smartcard interface using the USART_Init() function as following:
    872                  - Word Length = 9 Bits
    873                  - 1.5 Stop Bit
    874                  - Even parity
    875                  - BaudRate = 12096 baud
    876                  - Hardware flow control disabled (RTS and CTS signals)
    877                  - Tx and Rx enabled
    878               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    879                  function
    880               6. Enable the USART using the USART_Cmd() function.
    881               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    882               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    883          
    884            Please refer to the ISO 7816-3 specification for more details.
    885          
    886          
    887          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    888                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    889                between the two configurations.
    890          @note In smartcard mode, the following bits must be kept cleared:
    891                  - LINEN bit in the USART_CR2 register.
    892                  - HDSEL and IREN bits in the USART_CR3 register.
    893          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    894                and UART5 peripherals).
    895          
    896          @endverbatim
    897            * @{
    898            */
    899          
    900          /**
    901            * @brief  Sets the specified USART guard time.
    902            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    903            *         UART peripheral.
    904            * @param  USART_GuardTime: specifies the guard time.   
    905            * @retval None
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    908          {    
    909            /* Check the parameters */
    910            assert_param(IS_USART_1236_PERIPH(USARTx));
    911            
    912            /* Clear the USART Guard time */
    913            USARTx->GTPR &= USART_GTPR_PSC;
   \                     USART_SetGuardTime: (+1)
   \   00000000   0x8B02             LDRH     R2,[R0, #+24]
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0x8302             STRH     R2,[R0, #+24]
    914            /* Set the USART guard time */
    915            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
   \   00000006   0x8B02             LDRH     R2,[R0, #+24]
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xEA52 0x2201      ORRS     R2,R2,R1, LSL #+8
   \   0000000E   0x8302             STRH     R2,[R0, #+24]
    916          }
   \   00000010   0x4770             BX       LR               ;; return
    917          
    918          /**
    919            * @brief  Enables or disables the USART's Smart Card mode.
    920            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    921            *         UART peripheral.
    922            * @param  NewState: new state of the Smart Card mode.
    923            *          This parameter can be: ENABLE or DISABLE.      
    924            * @retval None
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    927          {
    928            /* Check the parameters */
    929            assert_param(IS_USART_1236_PERIPH(USARTx));
    930            assert_param(IS_FUNCTIONAL_STATE(NewState));
    931            if (NewState != DISABLE)
   \                     USART_SmartCardCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_SmartCardCmd_0
    932            {
    933              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    934              USARTx->CR3 |= USART_CR3_SCEN;
   \   00000006   0x8A82             LDRH     R2,[R0, #+20]
   \   00000008   0xF052 0x0220      ORRS     R2,R2,#0x20
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
   \   0000000E   0xE004             B.N      ??USART_SmartCardCmd_1
    935            }
    936            else
    937            {
    938              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    939              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
   \                     ??USART_SmartCardCmd_0: (+1)
   \   00000010   0x8A82             LDRH     R2,[R0, #+20]
   \   00000012   0xF64F 0x73DF      MOVW     R3,#+65503
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8282             STRH     R2,[R0, #+20]
    940            }
    941          }
   \                     ??USART_SmartCardCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    942          
    943          /**
    944            * @brief  Enables or disables NACK transmission.
    945            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    946            *         UART peripheral.
    947            * @param  NewState: new state of the NACK transmission.
    948            *          This parameter can be: ENABLE or DISABLE.  
    949            * @retval None
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    952          {
    953            /* Check the parameters */
    954            assert_param(IS_USART_1236_PERIPH(USARTx)); 
    955            assert_param(IS_FUNCTIONAL_STATE(NewState));
    956            if (NewState != DISABLE)
   \                     USART_SmartCardNACKCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_SmartCardNACKCmd_0
    957            {
    958              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    959              USARTx->CR3 |= USART_CR3_NACK;
   \   00000006   0x8A82             LDRH     R2,[R0, #+20]
   \   00000008   0xF052 0x0210      ORRS     R2,R2,#0x10
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
   \   0000000E   0xE004             B.N      ??USART_SmartCardNACKCmd_1
    960            }
    961            else
    962            {
    963              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    964              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
   \                     ??USART_SmartCardNACKCmd_0: (+1)
   \   00000010   0x8A82             LDRH     R2,[R0, #+20]
   \   00000012   0xF64F 0x73EF      MOVW     R3,#+65519
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8282             STRH     R2,[R0, #+20]
    965            }
    966          }
   \                     ??USART_SmartCardNACKCmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    967          
    968          /**
    969            * @}
    970            */
    971          
    972          /** @defgroup USART_Group7 IrDA mode functions
    973           *  @brief   IrDA mode functions 
    974           *
    975          @verbatim   
    976           ===============================================================================
    977                                          IrDA mode functions
    978           ===============================================================================  
    979          
    980            This subsection provides a set of functions allowing to manage the USART 
    981            IrDA communication.
    982            
    983            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    984            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    985            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    986            While receiving data, transmission should be avoided as the data to be transmitted
    987            could be corrupted.
    988          
    989            IrDA communication is possible through the following procedure:
    990               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    991                  modes and hardware flow control values using the USART_Init() function.
    992               2. Enable the USART using the USART_Cmd() function.
    993               3. Configures the IrDA pulse width by configuring the prescaler using  
    994                  the USART_SetPrescaler() function.
    995               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    996                  using the USART_IrDAConfig() function.
    997               5. Enable the IrDA using the USART_IrDACmd() function.
    998          
    999          @note A pulse of width less than two and greater than one PSC period(s) may or may
   1000                not be rejected.
   1001          @note The receiver set up time should be managed by software. The IrDA physical layer
   1002                specification specifies a minimum of 10 ms delay between transmission and 
   1003                reception (IrDA is a half duplex protocol).
   1004          @note In IrDA mode, the following bits must be kept cleared:
   1005                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
   1006                  - SCEN and HDSEL bits in the USART_CR3 register.
   1007          
   1008          @endverbatim
   1009            * @{
   1010            */
   1011          
   1012          /**
   1013            * @brief  Configures the USART's IrDA interface.
   1014            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1015            *         UART peripheral.
   1016            * @param  USART_IrDAMode: specifies the IrDA mode.
   1017            *          This parameter can be one of the following values:
   1018            *            @arg USART_IrDAMode_LowPower
   1019            *            @arg USART_IrDAMode_Normal
   1020            * @retval None
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1023          {
   1024            /* Check the parameters */
   1025            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1026            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   1027              
   1028            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   \                     USART_IrDAConfig: (+1)
   \   00000000   0x8A82             LDRH     R2,[R0, #+20]
   \   00000002   0xF64F 0x73FB      MOVW     R3,#+65531
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8282             STRH     R2,[R0, #+20]
   1029            USARTx->CR3 |= USART_IrDAMode;
   \   0000000A   0x8A82             LDRH     R2,[R0, #+20]
   \   0000000C   0x430A             ORRS     R2,R1,R2
   \   0000000E   0x8282             STRH     R2,[R0, #+20]
   1030          }
   \   00000010   0x4770             BX       LR               ;; return
   1031          
   1032          /**
   1033            * @brief  Enables or disables the USART's IrDA interface.
   1034            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1035            *         UART peripheral.
   1036            * @param  NewState: new state of the IrDA mode.
   1037            *          This parameter can be: ENABLE or DISABLE.
   1038            * @retval None
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1041          {
   1042            /* Check the parameters */
   1043            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1044            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1045              
   1046            if (NewState != DISABLE)
   \                     USART_IrDACmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??USART_IrDACmd_0
   1047            {
   1048              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1049              USARTx->CR3 |= USART_CR3_IREN;
   \   00000006   0x8A82             LDRH     R2,[R0, #+20]
   \   00000008   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000000C   0x8282             STRH     R2,[R0, #+20]
   \   0000000E   0xE004             B.N      ??USART_IrDACmd_1
   1050            }
   1051            else
   1052            {
   1053              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1054              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   \                     ??USART_IrDACmd_0: (+1)
   \   00000010   0x8A82             LDRH     R2,[R0, #+20]
   \   00000012   0xF64F 0x73FD      MOVW     R3,#+65533
   \   00000016   0x401A             ANDS     R2,R3,R2
   \   00000018   0x8282             STRH     R2,[R0, #+20]
   1055            }
   1056          }
   \                     ??USART_IrDACmd_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
   1057          
   1058          /**
   1059            * @}
   1060            */
   1061          
   1062          /** @defgroup USART_Group8 DMA transfers management functions
   1063           *  @brief   DMA transfers management functions
   1064           *
   1065          @verbatim   
   1066           ===============================================================================
   1067                                DMA transfers management functions
   1068           ===============================================================================  
   1069          
   1070          @endverbatim
   1071            * @{
   1072            */
   1073            
   1074          /**
   1075            * @brief  Enables or disables the USART's DMA interface.
   1076            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1077            *         UART peripheral.
   1078            * @param  USART_DMAReq: specifies the DMA request.
   1079            *          This parameter can be any combination of the following values:
   1080            *            @arg USART_DMAReq_Tx: USART DMA transmit request
   1081            *            @arg USART_DMAReq_Rx: USART DMA receive request
   1082            * @param  NewState: new state of the DMA Request sources.
   1083            *          This parameter can be: ENABLE or DISABLE.   
   1084            * @retval None
   1085            */

   \                                 In section .text, align 2, keep-with-next
   1086          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1087          {
   1088            /* Check the parameters */
   1089            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1090            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   1091            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   1092          
   1093            if (NewState != DISABLE)
   \                     USART_DMACmd: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??USART_DMACmd_0
   1094            {
   1095              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1096                 DMAR bits in the USART CR3 register */
   1097              USARTx->CR3 |= USART_DMAReq;
   \   00000006   0x8A83             LDRH     R3,[R0, #+20]
   \   00000008   0x430B             ORRS     R3,R1,R3
   \   0000000A   0x8283             STRH     R3,[R0, #+20]
   \   0000000C   0xE002             B.N      ??USART_DMACmd_1
   1098            }
   1099            else
   1100            {
   1101              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1102                 DMAR bits in the USART CR3 register */
   1103              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   \                     ??USART_DMACmd_0: (+1)
   \   0000000E   0x8A83             LDRH     R3,[R0, #+20]
   \   00000010   0x438B             BICS     R3,R3,R1
   \   00000012   0x8283             STRH     R3,[R0, #+20]
   1104            }
   1105          }
   \                     ??USART_DMACmd_1: (+1)
   \   00000014   0x4770             BX       LR               ;; return
   1106          
   1107          /**
   1108            * @}
   1109            */
   1110            
   1111          /** @defgroup USART_Group9 Interrupts and flags management functions
   1112           *  @brief   Interrupts and flags management functions 
   1113           *
   1114          @verbatim   
   1115           ===============================================================================
   1116                             Interrupts and flags management functions
   1117           ===============================================================================  
   1118          
   1119            This subsection provides a set of functions allowing to configure the USART 
   1120            Interrupts sources, DMA channels requests and check or clear the flags or 
   1121            pending bits status.
   1122            The user should identify which mode will be used in his application to manage 
   1123            the communication: Polling mode, Interrupt mode or DMA mode. 
   1124              
   1125            Polling Mode
   1126            =============
   1127            In Polling Mode, the SPI communication can be managed by 10 flags:
   1128               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1129               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1130               3. USART_FLAG_TC : to indicate the status of the transmit operation
   1131               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1132               5. USART_FLAG_CTS : to indicate the status of the nCTS input
   1133               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
   1134               7. USART_FLAG_NE : to indicate if a noise error occur
   1135               8. USART_FLAG_FE : to indicate if a frame error occur
   1136               9. USART_FLAG_PE : to indicate if a parity error occur
   1137               10. USART_FLAG_ORE : to indicate if an Overrun error occur
   1138          
   1139            In this Mode it is advised to use the following functions:
   1140                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1141                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1142          
   1143            Interrupt Mode
   1144            ===============
   1145            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1146            and 10 pending bits: 
   1147          
   1148            Pending Bits:
   1149            ------------- 
   1150               1. USART_IT_TXE : to indicate the status of the transmit buffer register
   1151               2. USART_IT_RXNE : to indicate the status of the receive buffer register
   1152               3. USART_IT_TC : to indicate the status of the transmit operation
   1153               4. USART_IT_IDLE : to indicate the status of the Idle Line             
   1154               5. USART_IT_CTS : to indicate the status of the nCTS input
   1155               6. USART_IT_LBD : to indicate the status of the LIN break detection
   1156               7. USART_IT_NE : to indicate if a noise error occur
   1157               8. USART_IT_FE : to indicate if a frame error occur
   1158               9. USART_IT_PE : to indicate if a parity error occur
   1159               10. USART_IT_ORE : to indicate if an Overrun error occur
   1160          
   1161            Interrupt Source:
   1162            -----------------
   1163               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1164                                 interrupt. 
   1165               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1166                                  empty interrupt.
   1167               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1168                                 interrupt. 
   1169               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1170               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1171               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1172                                 interrupt. 
   1173               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1174               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1175          
   1176          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1177          
   1178            In this Mode it is advised to use the following functions:
   1179               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1180               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1181               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1182          
   1183            DMA Mode
   1184            ========
   1185            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1186               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1187               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1188          
   1189            In this Mode it is advised to use the following function:
   1190               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1191          
   1192          @endverbatim
   1193            * @{
   1194            */
   1195          
   1196          /**
   1197            * @brief  Enables or disables the specified USART interrupts.
   1198            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1199            *         UART peripheral.
   1200            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1201            *          This parameter can be one of the following values:
   1202            *            @arg USART_IT_CTS:  CTS change interrupt
   1203            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1204            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1205            *            @arg USART_IT_TC:   Transmission complete interrupt
   1206            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1207            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1208            *            @arg USART_IT_PE:   Parity Error interrupt
   1209            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1210            * @param  NewState: new state of the specified USARTx interrupts.
   1211            *          This parameter can be: ENABLE or DISABLE.
   1212            * @retval None
   1213            */

   \                                 In section .text, align 2, keep-with-next
   1214          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1215          {
   \                     USART_ITConfig: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1216            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   1217            uint32_t usartxbase = 0x00;
   \   00000008   0x2600             MOVS     R6,#+0
   1218            /* Check the parameters */
   1219            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1220            assert_param(IS_USART_CONFIG_IT(USART_IT));
   1221            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1222          
   1223            /* The CTS interrupt is not available for UART4 and UART5 */
   1224            if (USART_IT == USART_IT_CTS)
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0xF640 0x176A      MOVW     R7,#+2410
   \   00000010   0x42B9             CMP      R1,R7
   1225            {
   1226              assert_param(IS_USART_1236_PERIPH(USARTx));
   1227            } 
   1228              
   1229            usartxbase = (uint32_t)USARTx;
   \                     ??USART_ITConfig_0: (+1)
   \   00000012   0x0006             MOVS     R6,R0
   1230          
   1231            /* Get the USART register index */
   1232            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \   00000014   0x000F             MOVS     R7,R1
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x097F             LSRS     R7,R7,#+5
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x003B             MOVS     R3,R7
   1233          
   1234            /* Get the interrupt position */
   1235            itpos = USART_IT & IT_MASK;
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0xF011 0x071F      ANDS     R7,R1,#0x1F
   \   00000024   0x003C             MOVS     R4,R7
   1236            itmask = (((uint32_t)0x01) << itpos);
   \   00000026   0x2701             MOVS     R7,#+1
   \   00000028   0x40A7             LSLS     R7,R7,R4
   \   0000002A   0x003D             MOVS     R5,R7
   1237              
   1238            if (usartreg == 0x01) /* The IT is in CR1 register */
   \   0000002C   0x2B01             CMP      R3,#+1
   \   0000002E   0xD101             BNE.N    ??USART_ITConfig_1
   1239            {
   1240              usartxbase += 0x0C;
   \   00000030   0x360C             ADDS     R6,R6,#+12
   \   00000032   0xE004             B.N      ??USART_ITConfig_2
   1241            }
   1242            else if (usartreg == 0x02) /* The IT is in CR2 register */
   \                     ??USART_ITConfig_1: (+1)
   \   00000034   0x2B02             CMP      R3,#+2
   \   00000036   0xD101             BNE.N    ??USART_ITConfig_3
   1243            {
   1244              usartxbase += 0x10;
   \   00000038   0x3610             ADDS     R6,R6,#+16
   \   0000003A   0xE000             B.N      ??USART_ITConfig_2
   1245            }
   1246            else /* The IT is in CR3 register */
   1247            {
   1248              usartxbase += 0x14; 
   \                     ??USART_ITConfig_3: (+1)
   \   0000003C   0x3614             ADDS     R6,R6,#+20
   1249            }
   1250            if (NewState != DISABLE)
   \                     ??USART_ITConfig_2: (+1)
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x2A00             CMP      R2,#+0
   \   00000042   0xD003             BEQ.N    ??USART_ITConfig_4
   1251            {
   1252              *(__IO uint32_t*)usartxbase  |= itmask;
   \   00000044   0x6837             LDR      R7,[R6, #+0]
   \   00000046   0x432F             ORRS     R7,R5,R7
   \   00000048   0x6037             STR      R7,[R6, #+0]
   \   0000004A   0xE002             B.N      ??USART_ITConfig_5
   1253            }
   1254            else
   1255            {
   1256              *(__IO uint32_t*)usartxbase &= ~itmask;
   \                     ??USART_ITConfig_4: (+1)
   \   0000004C   0x6837             LDR      R7,[R6, #+0]
   \   0000004E   0x43AF             BICS     R7,R7,R5
   \   00000050   0x6037             STR      R7,[R6, #+0]
   1257            }
   1258          }
   \                     ??USART_ITConfig_5: (+1)
   \   00000052   0xBCF0             POP      {R4-R7}
   \   00000054   0x4770             BX       LR               ;; return
   1259          
   1260          /**
   1261            * @brief  Checks whether the specified USART flag is set or not.
   1262            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1263            *         UART peripheral.
   1264            * @param  USART_FLAG: specifies the flag to check.
   1265            *          This parameter can be one of the following values:
   1266            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1267            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1268            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1269            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1270            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1271            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1272            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1273            *            @arg USART_FLAG_NE:   Noise Error flag
   1274            *            @arg USART_FLAG_FE:   Framing Error flag
   1275            *            @arg USART_FLAG_PE:   Parity Error flag
   1276            * @retval The new state of USART_FLAG (SET or RESET).
   1277            */

   \                                 In section .text, align 2, keep-with-next
   1278          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1279          {
   \                     USART_GetFlagStatus: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   1280            FlagStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   1281            /* Check the parameters */
   1282            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1283            assert_param(IS_USART_FLAG(USART_FLAG));
   1284          
   1285            /* The CTS flag is not available for UART4 and UART5 */
   1286            if (USART_FLAG == USART_FLAG_CTS)
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0xF5B1 0x7F00      CMP      R1,#+512
   1287            {
   1288              assert_param(IS_USART_1236_PERIPH(USARTx));
   1289            } 
   1290              
   1291            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   \                     ??USART_GetFlagStatus_0: (+1)
   \   0000000A   0x8813             LDRH     R3,[R2, #+0]
   \   0000000C   0x420B             TST      R3,R1
   \   0000000E   0xD002             BEQ.N    ??USART_GetFlagStatus_1
   1292            {
   1293              bitstatus = SET;
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x0018             MOVS     R0,R3
   \   00000014   0xE001             B.N      ??USART_GetFlagStatus_2
   1294            }
   1295            else
   1296            {
   1297              bitstatus = RESET;
   \                     ??USART_GetFlagStatus_1: (+1)
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x0018             MOVS     R0,R3
   1298            }
   1299            return bitstatus;
   \                     ??USART_GetFlagStatus_2: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x4770             BX       LR               ;; return
   1300          }
   1301          
   1302          /**
   1303            * @brief  Clears the USARTx's pending flags.
   1304            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1305            *         UART peripheral.
   1306            * @param  USART_FLAG: specifies the flag to clear.
   1307            *          This parameter can be any combination of the following values:
   1308            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1309            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1310            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1311            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1312            *   
   1313            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1314            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1315            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1316            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1317            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1318            *          (USART_ReceiveData()).
   1319            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1320            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1321            *          to USART_DR register (USART_SendData()).
   1322            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1323            *          (USART_SendData()).
   1324            *   
   1325            * @retval None
   1326            */

   \                                 In section .text, align 2, keep-with-next
   1327          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1328          {
   1329            /* Check the parameters */
   1330            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1331            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   1332          
   1333            /* The CTS flag is not available for UART4 and UART5 */
   1334            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
   \                     USART_ClearFlag: (+1)
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x058A             LSLS     R2,R1,#+22
   1335            {
   1336              assert_param(IS_USART_1236_PERIPH(USARTx));
   1337            } 
   1338                 
   1339            USARTx->SR = (uint16_t)~USART_FLAG;
   \                     ??USART_ClearFlag_0: (+1)
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x43CA             MVNS     R2,R1
   \   00000008   0x8002             STRH     R2,[R0, #+0]
   1340          }
   \   0000000A   0x4770             BX       LR               ;; return
   1341          
   1342          /**
   1343            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1344            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1345            *         UART peripheral.
   1346            * @param  USART_IT: specifies the USART interrupt source to check.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1349            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1350            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1351            *            @arg USART_IT_TC:   Transmission complete interrupt
   1352            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1353            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1354            *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
   1355            *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
   1356            *            @arg USART_IT_NE:   Noise Error interrupt
   1357            *            @arg USART_IT_FE:   Framing Error interrupt
   1358            *            @arg USART_IT_PE:   Parity Error interrupt
   1359            * @retval The new state of USART_IT (SET or RESET).
   1360            */

   \                                 In section .text, align 2, keep-with-next
   1361          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1362          {
   \                     USART_GetITStatus: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
   1363            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2400             MOVS     R4,#+0
   1364            ITStatus bitstatus = RESET;
   \   0000000A   0x2000             MOVS     R0,#+0
   1365            /* Check the parameters */
   1366            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1367            assert_param(IS_USART_GET_IT(USART_IT)); 
   1368          
   1369            /* The CTS interrupt is not available for UART4 and UART5 */ 
   1370            if (USART_IT == USART_IT_CTS)
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0xF640 0x166A      MOVW     R6,#+2410
   \   00000012   0x42B1             CMP      R1,R6
   1371            {
   1372              assert_param(IS_USART_1236_PERIPH(USARTx));
   1373            } 
   1374              
   1375            /* Get the USART register index */
   1376            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \                     ??USART_GetITStatus_0: (+1)
   \   00000014   0x000E             MOVS     R6,R1
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x0976             LSRS     R6,R6,#+5
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x0034             MOVS     R4,R6
   1377            /* Get the interrupt position */
   1378            itmask = USART_IT & IT_MASK;
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0xF011 0x061F      ANDS     R6,R1,#0x1F
   \   00000024   0x0035             MOVS     R5,R6
   1379            itmask = (uint32_t)0x01 << itmask;
   \   00000026   0x2601             MOVS     R6,#+1
   \   00000028   0xFA16 0xF505      LSLS     R5,R6,R5
   1380            
   1381            if (usartreg == 0x01) /* The IT  is in CR1 register */
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD102             BNE.N    ??USART_GetITStatus_1
   1382            {
   1383              itmask &= USARTx->CR1;
   \   00000030   0x8996             LDRH     R6,[R2, #+12]
   \   00000032   0x4035             ANDS     R5,R6,R5
   \   00000034   0xE006             B.N      ??USART_GetITStatus_2
   1384            }
   1385            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   \                     ??USART_GetITStatus_1: (+1)
   \   00000036   0x2C02             CMP      R4,#+2
   \   00000038   0xD102             BNE.N    ??USART_GetITStatus_3
   1386            {
   1387              itmask &= USARTx->CR2;
   \   0000003A   0x8A16             LDRH     R6,[R2, #+16]
   \   0000003C   0x4035             ANDS     R5,R6,R5
   \   0000003E   0xE001             B.N      ??USART_GetITStatus_2
   1388            }
   1389            else /* The IT  is in CR3 register */
   1390            {
   1391              itmask &= USARTx->CR3;
   \                     ??USART_GetITStatus_3: (+1)
   \   00000040   0x8A96             LDRH     R6,[R2, #+20]
   \   00000042   0x4035             ANDS     R5,R6,R5
   1392            }
   1393            
   1394            bitpos = USART_IT >> 0x08;
   \                     ??USART_GetITStatus_2: (+1)
   \   00000044   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000046   0x0A0E             LSRS     R6,R1,#+8
   \   00000048   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004A   0x0033             MOVS     R3,R6
   1395            bitpos = (uint32_t)0x01 << bitpos;
   \   0000004C   0x2601             MOVS     R6,#+1
   \   0000004E   0xFA16 0xF303      LSLS     R3,R6,R3
   1396            bitpos &= USARTx->SR;
   \   00000052   0x8816             LDRH     R6,[R2, #+0]
   \   00000054   0x4033             ANDS     R3,R6,R3
   1397            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD004             BEQ.N    ??USART_GetITStatus_4
   \   0000005A   0x2B00             CMP      R3,#+0
   \   0000005C   0xD002             BEQ.N    ??USART_GetITStatus_4
   1398            {
   1399              bitstatus = SET;
   \   0000005E   0x2601             MOVS     R6,#+1
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0xE001             B.N      ??USART_GetITStatus_5
   1400            }
   1401            else
   1402            {
   1403              bitstatus = RESET;
   \                     ??USART_GetITStatus_4: (+1)
   \   00000064   0x2600             MOVS     R6,#+0
   \   00000066   0x0030             MOVS     R0,R6
   1404            }
   1405            
   1406            return bitstatus;  
   \                     ??USART_GetITStatus_5: (+1)
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0xBC70             POP      {R4-R6}
   \   0000006C   0x4770             BX       LR               ;; return
   1407          }
   1408          
   1409          /**
   1410            * @brief  Clears the USARTx's interrupt pending bits.
   1411            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1412            *         UART peripheral.
   1413            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1414            *          This parameter can be one of the following values:
   1415            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1416            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1417            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1418            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1419            *
   1420            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1421            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1422            *          software sequence: a read operation to USART_SR register 
   1423            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1424            *          (USART_ReceiveData()).
   1425            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1426            *          (USART_ReceiveData()).
   1427            * @note   TC pending bit can be also cleared by software sequence: a read 
   1428            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1429            *          operation to USART_DR register (USART_SendData()).
   1430            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1431            *          (USART_SendData()).
   1432            *  
   1433            * @retval None
   1434            */

   \                                 In section .text, align 2, keep-with-next
   1435          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1436          {
   \                     USART_ClearITPendingBit: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1437            uint16_t bitpos = 0x00, itmask = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   1438            /* Check the parameters */
   1439            assert_param(IS_USART_ALL_PERIPH(USARTx));
   1440            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   1441          
   1442            /* The CTS interrupt is not available for UART4 and UART5 */
   1443            if (USART_IT == USART_IT_CTS)
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0xF640 0x146A      MOVW     R4,#+2410
   \   0000000C   0x42A1             CMP      R1,R4
   1444            {
   1445              assert_param(IS_USART_1236_PERIPH(USARTx));
   1446            } 
   1447              
   1448            bitpos = USART_IT >> 0x08;
   \                     ??USART_ClearITPendingBit_0: (+1)
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0x0A0C             LSRS     R4,R1,#+8
   \   00000012   0x0022             MOVS     R2,R4
   1449            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   \   00000014   0x2401             MOVS     R4,#+1
   \   00000016   0x4094             LSLS     R4,R4,R2
   \   00000018   0x0023             MOVS     R3,R4
   1450            USARTx->SR = (uint16_t)~itmask;
   \   0000001A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001C   0x43DC             MVNS     R4,R3
   \   0000001E   0x8004             STRH     R4,[R0, #+0]
   1451          }
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0xFFFFE9F3         DC32     0xffffe9f3
   1452          
   1453          /**
   1454            * @}
   1455            */
   1456          
   1457          /**
   1458            * @}
   1459            */
   1460          
   1461          /**
   1462            * @}
   1463            */
   1464          
   1465          /**
   1466            * @}
   1467            */
   1468          
   1469          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   USART_ClearFlag
       4   USART_ClearITPendingBit
       4   USART_ClockInit
       0   USART_ClockStructInit
       0   USART_Cmd
       0   USART_DMACmd
       8   USART_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   USART_GetFlagStatus
      12   USART_GetITStatus
       0   USART_HalfDuplexCmd
      16   USART_ITConfig
      48   USART_Init
        48   -> RCC_GetClocksFreq
       0   USART_IrDACmd
       0   USART_IrDAConfig
       0   USART_LINBreakDetectLengthConfig
       0   USART_LINCmd
       0   USART_OneBitMethodCmd
       0   USART_OverSampling8Cmd
       0   USART_ReceiveData
       0   USART_ReceiverWakeUpCmd
       0   USART_SendBreak
       0   USART_SendData
       0   USART_SetAddress
       0   USART_SetGuardTime
       0   USART_SetPrescaler
       0   USART_SmartCardCmd
       0   USART_SmartCardNACKCmd
       0   USART_StructInit
       0   USART_WakeUpConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
      12  USART_ClearFlag
      36  USART_ClearITPendingBit
      34  USART_ClockInit
      18  USART_ClockStructInit
      28  USART_Cmd
      22  USART_DMACmd
     164  USART_DeInit
      30  USART_GetFlagStatus
     110  USART_GetITStatus
      28  USART_HalfDuplexCmd
      86  USART_ITConfig
     238  USART_Init
      28  USART_IrDACmd
      18  USART_IrDAConfig
      18  USART_LINBreakDetectLengthConfig
      28  USART_LINCmd
      28  USART_OneBitMethodCmd
      26  USART_OverSampling8Cmd
       8  USART_ReceiveData
      28  USART_ReceiverWakeUpCmd
      10  USART_SendBreak
       8  USART_SendData
      20  USART_SetAddress
      18  USART_SetGuardTime
      18  USART_SetPrescaler
      28  USART_SmartCardCmd
      28  USART_SmartCardNACKCmd
      28  USART_StructInit
      18  USART_WakeUpConfig

 
 1 192 bytes in section .text
 
 1 192 bytes of CODE memory

Errors: none
Warnings: none
