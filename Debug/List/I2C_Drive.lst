###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        03/Jan/2017  10:56:10
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\modules\Source\I2C_Drive.c
#    Command line =  
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\modules\Source\I2C_Drive.c" -D USE_STDPERIPH_DRIVER -D STM32F40XX
#        -lC "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Debug\List\" -o
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Debug\Obj\" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\board\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\app\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I
#        "E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\modules\Header\" -On --use_c++_inline -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.2\arm\CMSIS\Include\"
#        --relaxed_fp
#    List file    =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Debug\List\I2C_Drive.lst
#    Object file  =  
#        E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 -
#        TSI\Debug\Obj\I2C_Drive.o
#
###############################################################################

E:\Ventilator\SoftWare\SVC_Software\SVC_Ver\SVC2_3-S950802 - TSI\modules\Source\I2C_Drive.c
      1          #include "main.h"
      2          //----------------------------------------------------
      3          /* Private variables */

   \                                 In section .bss, align 2
      4          u16     TM_I2C_Timeout;
   \                     TM_I2C_Timeout:
   \   00000000                      DS8 2
      5          

   \                                 In section .bss, align 1
      6          u8      ADD_EErom = 0, BYTE_rom = 0, index1 = 0 , En_ADD = 0;
   \                     ADD_EErom:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     BYTE_rom:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     index1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     En_ADD:
   \   00000000                      DS8 1
      7          //----------------------------------------------------
      8          /* Private defines */
      9          #define I2C_TRANSMITTER_MODE   0
     10          #define I2C_RECEIVER_MODE      1
     11          #define I2C_ACK_ENABLE         1
     12          #define I2C_ACK_DISABLE        0
     13          
     14          

   \                                 In section .rodata, align 4
     15          const u8 Flow_E2Prom_ADD_[86]=
   \                     Flow_E2Prom_ADD_:
   \   00000000   0x00 0x02          DC8 0, 2, 2, 6, 8, 4, 12, 2, 14, 2, 16, 2, 18, 2, 20, 4, 24, 4, 28, 4
   \              0x02 0x06    
   \              0x08 0x04    
   \              0x0C 0x02    
   \              0x0E 0x02    
   \              0x10 0x02    
   \              0x12 0x02    
   \              0x14 0x04    
   \              0x18 0x04    
   \              0x1C 0x04    
   \   00000014   0x20 0x04          DC8 32, 4, 36, 4, 40, 4, 44, 2, 46, 2, 48, 2, 50, 2, 52, 2, 54, 2, 56
   \              0x24 0x04    
   \              0x28 0x04    
   \              0x2C 0x02    
   \              0x2E 0x02    
   \              0x30 0x02    
   \              0x32 0x02    
   \              0x34 0x02    
   \              0x36 0x02    
   \              0x38         
   \   00000027   0x02 0x3A          DC8 2, 58, 2, 0, 1, 2, 4, 6, 4, 10, 4, 14, 4, 18, 4, 22, 4, 26, 4, 30
   \              0x02 0x00    
   \              0x01 0x02    
   \              0x04 0x06    
   \              0x04 0x0A    
   \              0x04 0x0E    
   \              0x04 0x12    
   \              0x04 0x16    
   \              0x04 0x1A    
   \              0x04 0x1E    
   \   0000003B   0x04 0x22          DC8 4, 34, 16, 50, 16, 66, 16, 82, 16, 98, 16, 114, 16, 130, 16, 146
   \              0x10 0x32    
   \              0x10 0x42    
   \              0x10 0x52    
   \              0x10 0x62    
   \              0x10 0x72    
   \              0x10 0x82    
   \              0x10 0x92    
   \   0000004B   0x10 0xA2          DC8 16, 162, 16, 178, 16, 194, 16, 210, 16, 226, 16, 0, 0
   \              0x10 0xB2    
   \              0x10 0xC2    
   \              0x10 0xD2    
   \              0x10 0xE2    
   \              0x10 0x00    
   \              0x00         
     16          {
     17          /*Address ,   Bytes	      */
     18            0		,	2,	//    CRC
     19            2		,	6,	//	SN
     20            8		,	4,	//	MN
     21            12	        ,	2,	//	Rev
     22            14	        ,	2,	//	Year
     23            16	        ,	2,	//	Month
     24            18	        ,	2,	//	Day
     25            20	        ,	4,	//	Tcal
     26            24	        ,	4,	//	S
     27            28	        ,	4,	//	Z	
     28            32	        ,	4,	//	S2
     29            36	        ,	4,	//	Z2
     30            40	        ,	4,	//	Tcorr
     31            
     32            44	        ,	2,	//	Cal Air
     33            46	        ,	2,	//	Location Air
     34            48	        ,	2,	//	Cal Oxygen (2A)
     35            50            ,	2,	//	Location	Oxygen
     36            52	        ,	2,	//	Cal	Heliox
     37            54	        ,	2,	//	Location Heliox
     38            56	        ,	2,	//	Cal Gas4	
     39            58	        ,	2,	//	Location	Gac4
     40            
     41            0		,	1,	//	offset (33)
     42            2		,	4,	//	K0			
     43            6		,	4,	//	K1			
     44            10	        ,	4,	//	K2			
     45            14	        ,	4,	//	K3
     46            18	        ,	4,	//	L0			
     47            22	        ,	4,	//	L1			
     48            26	        ,	4,	//	L2			
     49            30	        ,	4,	//	L3			
     50            
     51            34	        ,	16,	//	VABC[0]
     52            50	        ,	16,	//	VABC[1]
     53            66	        ,	16,	//	VABC[2]
     54            82	        ,	16,	//	VABC[3]
     55            98	        ,	16,	//	VABC[4]
     56            114	        ,	16,	//	VABC[5]
     57            130	        ,	16,	//	VABC[6]
     58            146	        ,	16,	//	VABC[7]
     59            162	        ,	16,	//	VABC[8]
     60            178	        ,	16,	//	VABC[9]
     61            194	        ,	16,	//	VABC[10]
     62            210	        ,	16,	//	VABC[11]
     63            226	        ,	16,	//	VABC[12]
     64          };
     65          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     66          uint8_t TM_I2C_Read(I2C_TypeDef* I2Cx, uint8_t address, uint8_t reg) {
   \                     TM_I2C_Read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     67          	uint8_t received_data;
     68          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_DISABLE);
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       TM_I2C_Start
     69          	TM_I2C_WriteData(I2Cx, reg);
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       TM_I2C_WriteData
     70          	TM_I2C_Stop(I2Cx);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       TM_I2C_Stop
     71          	TM_I2C_Start(I2Cx, address, I2C_RECEIVER_MODE, I2C_ACK_DISABLE);
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       TM_I2C_Start
     72          	received_data = TM_I2C_ReadNack(I2Cx);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       TM_I2C_ReadNack
   \   0000003A   0x0007             MOVS     R7,R0
     73          	return received_data;
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     74          }
     75          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     76          void TM_I2C_ReadMulti(I2C_TypeDef* I2Cx, uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {
   \                     TM_I2C_ReadMulti: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
     77          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_ENABLE);
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0031             MOVS     R1,R6
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       TM_I2C_Start
     78          	TM_I2C_WriteData(I2Cx, reg);
   \   0000001C   0x0039             MOVS     R1,R7
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       TM_I2C_WriteData
     79          	//TM_I2C_Stop(I2Cx);
     80          	TM_I2C_Start(I2Cx, address, I2C_RECEIVER_MODE, I2C_ACK_ENABLE);
   \   00000026   0x2301             MOVS     R3,#+1
   \   00000028   0x2201             MOVS     R2,#+1
   \   0000002A   0x0031             MOVS     R1,R6
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x.... 0x....      BL       TM_I2C_Start
     81          	while (count--) 
   \                     ??TM_I2C_ReadMulti_0: (+1)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x1E44             SUBS     R4,R0,#+1
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD012             BEQ.N    ??TM_I2C_ReadMulti_1
     82                  {
     83          //            if(!En_ADD)
     84          //            {
     85          //                ADD_EErom = Flow_E2Prom_ADD_[index1++];
     86          //                BYTE_rom = Flow_E2Prom_ADD_[index1++];
     87          //                En_ADD = 1;
     88          //            }
     89          		if (!count) 
   \   0000003E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD107             BNE.N    ??TM_I2C_ReadMulti_2
     90                          {
     91                              /* Last byte */
     92                              *data++ = TM_I2C_ReadNack(I2Cx);
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       TM_I2C_ReadNack
   \   0000004A   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000004E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000052   0xE7EF             B.N      ??TM_I2C_ReadMulti_0
     93          //                    *((u8*)data + ADD_EErom + BYTE_rom -1) = TM_I2C_ReadNack(I2Cx);
     94          		} 
     95                          else 
     96                          {
     97                              *data++ = TM_I2C_ReadAck(I2Cx);
   \                     ??TM_I2C_ReadMulti_2: (+1)
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       TM_I2C_ReadAck
   \   0000005A   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000005E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000062   0xE7E7             B.N      ??TM_I2C_ReadMulti_0
     98          //                    *((u8*)data + ADD_EErom + BYTE_rom -1) = TM_I2C_ReadAck(I2Cx);
     99          		}
    100          //            BYTE_rom--;
    101          //            if(!BYTE_rom)
    102          //            {               
    103          //                En_ADD = 0;
    104          //            }
    105          	}
    106          }
   \                     ??TM_I2C_ReadMulti_1: (+1)
   \   00000064   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    107          //******** |
    108          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    109          uint8_t TM_I2C_ReadNoRegister(I2C_TypeDef* I2Cx, uint8_t address) {
   \                     TM_I2C_ReadNoRegister: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    110          	uint8_t data;
    111          	TM_I2C_Start(I2Cx, address, I2C_RECEIVER_MODE, I2C_ACK_ENABLE);
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       TM_I2C_Start
    112          	/* Also stop condition happens */
    113          	data = TM_I2C_ReadNack(I2Cx);
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       TM_I2C_ReadNack
   \   0000001A   0x0006             MOVS     R6,R0
    114          	return data;
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    115          }
    116          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    117          void TM_I2C_ReadMultiNoRegister(I2C_TypeDef* I2Cx, uint8_t address, uint8_t* data, uint16_t count) {
   \                     TM_I2C_ReadMultiNoRegister: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    118          	TM_I2C_Start(I2Cx, address, I2C_RECEIVER_MODE, I2C_ACK_ENABLE);
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       TM_I2C_Start
    119          	while (count--) {
   \                     ??TM_I2C_ReadMultiNoRegister_0: (+1)
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0x1E47             SUBS     R7,R0,#+1
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00C             BEQ.N    ??TM_I2C_ReadMultiNoRegister_1
    120          		if (!count) {
   \   00000022   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD104             BNE.N    ??TM_I2C_ReadMultiNoRegister_2
    121          			/* Last byte */
    122          			*data = TM_I2C_ReadNack(I2Cx);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       TM_I2C_ReadNack
   \   0000002E   0x7030             STRB     R0,[R6, #+0]
   \   00000030   0xE7F2             B.N      ??TM_I2C_ReadMultiNoRegister_0
    123          		} else {
    124          			*data = TM_I2C_ReadAck(I2Cx);
   \                     ??TM_I2C_ReadMultiNoRegister_2: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       TM_I2C_ReadAck
   \   00000038   0x7030             STRB     R0,[R6, #+0]
   \   0000003A   0xE7ED             B.N      ??TM_I2C_ReadMultiNoRegister_0
    125          		}
    126          	}
    127          }
   \                     ??TM_I2C_ReadMultiNoRegister_1: (+1)
   \   0000003C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    128          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    129          void TM_I2C_Write(I2C_TypeDef* I2Cx, uint8_t address, uint8_t reg, uint8_t data) {
   \                     TM_I2C_Write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    130          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_DISABLE);
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       TM_I2C_Start
    131          	TM_I2C_WriteData(I2Cx, reg);
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       TM_I2C_WriteData
    132          	TM_I2C_WriteData(I2Cx, data);
   \   00000022   0x0039             MOVS     R1,R7
   \   00000024   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       TM_I2C_WriteData
    133          	TM_I2C_Stop(I2Cx);
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       TM_I2C_Stop
    134          }
   \   00000032   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    135          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    136          void TM_I2C_WriteMulti(I2C_TypeDef* I2Cx, uint8_t address, uint8_t reg, uint8_t* data, uint16_t count) {
   \                     TM_I2C_WriteMulti: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
    137          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_DISABLE);
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0031             MOVS     R1,R6
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       TM_I2C_Start
    138          	TM_I2C_WriteData(I2Cx, reg);
   \   0000001C   0x0039             MOVS     R1,R7
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       TM_I2C_WriteData
    139          	while (count--) {
   \                     ??TM_I2C_WriteMulti_0: (+1)
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x1E44             SUBS     R4,R0,#+1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD007             BEQ.N    ??TM_I2C_WriteMulti_1
    140          		TM_I2C_WriteData(I2Cx, *data++);
   \   00000030   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       TM_I2C_WriteData
   \   0000003A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000003E   0xE7F2             B.N      ??TM_I2C_WriteMulti_0
    141          	}
    142          	TM_I2C_Stop(I2Cx);
   \                     ??TM_I2C_WriteMulti_1: (+1)
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x.... 0x....      BL       TM_I2C_Stop
    143          }
   \   00000046   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    144          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    145          void TM_I2C_WriteNoRegister(I2C_TypeDef* I2Cx, uint8_t address, uint8_t data) {
   \                     TM_I2C_WriteNoRegister: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    146          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_DISABLE);
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       TM_I2C_Start
    147          	TM_I2C_WriteData(I2Cx, data);
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       TM_I2C_WriteData
    148          	TM_I2C_Stop(I2Cx);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       TM_I2C_Stop
    149          }
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    150          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    151          void TM_I2C_WriteMultiNoRegister(I2C_TypeDef* I2Cx, uint8_t address, uint8_t* data, uint16_t count) {
   \                     TM_I2C_WriteMultiNoRegister: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    152          	TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_DISABLE);
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       TM_I2C_Start
    153          	while (count--) {
   \                     ??TM_I2C_WriteMultiNoRegister_0: (+1)
   \   00000018   0x0038             MOVS     R0,R7
   \   0000001A   0x1E47             SUBS     R7,R0,#+1
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD005             BEQ.N    ??TM_I2C_WriteMultiNoRegister_1
    154          		TM_I2C_WriteData(I2Cx, *data++);
   \   00000022   0x7831             LDRB     R1,[R6, #+0]
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       TM_I2C_WriteData
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xE7F4             B.N      ??TM_I2C_WriteMultiNoRegister_0
    155          	}
    156          	TM_I2C_Stop(I2Cx);
   \                     ??TM_I2C_WriteMultiNoRegister_1: (+1)
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       TM_I2C_Stop
    157          }
   \   00000034   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    158          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    159          uint8_t TM_I2C_IsDeviceConnected(I2C_TypeDef* I2Cx, uint8_t address) {
   \                     TM_I2C_IsDeviceConnected: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    160          	uint8_t connected = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    161          	/* Try to start, function will return 0 in case device will send ACK */
    162          	if (!TM_I2C_Start(I2Cx, address, I2C_TRANSMITTER_MODE, I2C_ACK_ENABLE)) {
   \   00000008   0x2301             MOVS     R3,#+1
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       TM_I2C_Start
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??TM_I2C_IsDeviceConnected_0
    163          		connected = 1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x0006             MOVS     R6,R0
    164          	}
    165          	
    166          	/* STOP I2C */
    167          	TM_I2C_Stop(I2Cx);
   \                     ??TM_I2C_IsDeviceConnected_0: (+1)
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       TM_I2C_Stop
    168          	
    169          	/* Return status */
    170          	return connected;
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    171          }
    172          //----------------------------------------------------
    173          /* Private functions */

   \                                 In section .text, align 2, keep-with-next
    174          int16_t TM_I2C_Start(I2C_TypeDef* I2Cx, uint8_t address, uint8_t direction, uint8_t ack) {
   \                     TM_I2C_Start: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    175          	/* Generate I2C start pulse */
    176          	I2Cx->CR1 |= I2C_CR1_START;
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000010   0x8020             STRH     R0,[R4, #+0]
    177          	
    178          	/* Wait till I2C is busy */
    179          	TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   00000012   0xF247 0x5030      MOVW     R0,#+30000
   \   00000016   0x....             LDR.N    R1,??DataTable4
   \   00000018   0x8008             STRH     R0,[R1, #+0]
    180          	while (!(I2Cx->SR1 & I2C_SR1_SB)) {
   \                     ??TM_I2C_Start_0: (+1)
   \   0000001A   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD40A             BMI.N    ??TM_I2C_Start_1
    181          		if (--TM_I2C_Timeout == 0x00) {
   \   00000020   0x....             LDR.N    R0,??DataTable4
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable4
   \   00000028   0x8008             STRH     R0,[R1, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable4
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F3             BNE.N    ??TM_I2C_Start_0
    182          			return 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE03E             B.N      ??TM_I2C_Start_2
    183          		}
    184          	}
    185          
    186          	/* Enable ack if we select it */
    187          	if (ack) {
   \                     ??TM_I2C_Start_1: (+1)
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD003             BEQ.N    ??TM_I2C_Start_3
    188          		I2Cx->CR1 |= I2C_CR1_ACK;
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000042   0x8020             STRH     R0,[R4, #+0]
    189          	}
    190          
    191          	/* Send write/read bit */
    192          	if (direction == I2C_TRANSMITTER_MODE) {
   \                     ??TM_I2C_Start_3: (+1)
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD116             BNE.N    ??TM_I2C_Start_4
    193          		/* Send address with zero last bit */
    194          		I2Cx->DR = address & ~I2C_OAR1_ADD0;
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0xF64F 0x70FE      MOVW     R0,#+65534
   \   00000050   0x4028             ANDS     R0,R0,R5
   \   00000052   0x8220             STRH     R0,[R4, #+16]
    195          		
    196          		/* Wait till finished */
    197          		TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   00000054   0xF247 0x5030      MOVW     R0,#+30000
   \   00000058   0x....             LDR.N    R1,??DataTable4
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
    198          		while (!(I2Cx->SR1 & I2C_SR1_ADDR)) {
   \                     ??TM_I2C_Start_5: (+1)
   \   0000005C   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD40A             BMI.N    ??TM_I2C_Start_4
    199          			if (--TM_I2C_Timeout == 0x00) {
   \   00000062   0x....             LDR.N    R0,??DataTable4
   \   00000064   0x8800             LDRH     R0,[R0, #+0]
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable4
   \   0000006A   0x8008             STRH     R0,[R1, #+0]
   \   0000006C   0x....             LDR.N    R0,??DataTable4
   \   0000006E   0x8800             LDRH     R0,[R0, #+0]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD1F3             BNE.N    ??TM_I2C_Start_5
    200          				return 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE01D             B.N      ??TM_I2C_Start_2
    201          			}
    202          		}
    203          	}
    204          	if (direction == I2C_RECEIVER_MODE) {
   \                     ??TM_I2C_Start_4: (+1)
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0x2E01             CMP      R6,#+1
   \   0000007C   0xD118             BNE.N    ??TM_I2C_Start_6
    205          		/* Send address with 1 last bit */
    206          		I2Cx->DR = address | I2C_OAR1_ADD0;
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0xF055 0x0001      ORRS     R0,R5,#0x1
   \   00000084   0x8220             STRH     R0,[R4, #+16]
    207          		
    208          		/* Wait till finished */
    209          		TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   00000086   0xF247 0x5030      MOVW     R0,#+30000
   \   0000008A   0x....             LDR.N    R1,??DataTable4
   \   0000008C   0x8008             STRH     R0,[R1, #+0]
    210          		while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
   \                     ??TM_I2C_Start_7: (+1)
   \   0000008E   0x....             LDR.N    R1,??DataTable4_1  ;; 0x30002
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       I2C_CheckEvent
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD10A             BNE.N    ??TM_I2C_Start_6
    211          			if (--TM_I2C_Timeout == 0x00) {
   \   0000009A   0x....             LDR.N    R0,??DataTable4
   \   0000009C   0x8800             LDRH     R0,[R0, #+0]
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0x....             LDR.N    R1,??DataTable4
   \   000000A2   0x8008             STRH     R0,[R1, #+0]
   \   000000A4   0x....             LDR.N    R0,??DataTable4
   \   000000A6   0x8800             LDRH     R0,[R0, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD1F0             BNE.N    ??TM_I2C_Start_7
    212          				return 1;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE001             B.N      ??TM_I2C_Start_2
    213          			}
    214          		}
    215          	}
    216          	
    217          	/* Read status register to clear ADDR flag */
    218          	I2Cx->SR2;
   \                     ??TM_I2C_Start_6: (+1)
   \   000000B0   0x8B20             LDRH     R0,[R4, #+24]
    219          	
    220          	/* Return 0, everything ok */
    221          	return 0;
   \   000000B2   0x2000             MOVS     R0,#+0
   \                     ??TM_I2C_Start_2: (+1)
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    222          }
    223          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    224          void TM_I2C_WriteData(I2C_TypeDef* I2Cx, uint8_t data) {
    225          	/* Wait till I2C is not busy anymore */
    226          	TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \                     TM_I2C_WriteData: (+1)
   \   00000000   0xF247 0x5230      MOVW     R2,#+30000
   \   00000004   0x....             LDR.N    R3,??DataTable4
   \   00000006   0x801A             STRH     R2,[R3, #+0]
    227          	while (!(I2Cx->SR1 & I2C_SR1_TXE) && TM_I2C_Timeout) {
   \                     ??TM_I2C_WriteData_0: (+1)
   \   00000008   0x8A82             LDRH     R2,[R0, #+20]
   \   0000000A   0x0612             LSLS     R2,R2,#+24
   \   0000000C   0xD409             BMI.N    ??TM_I2C_WriteData_1
   \   0000000E   0x....             LDR.N    R2,??DataTable4
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD005             BEQ.N    ??TM_I2C_WriteData_1
    228          		TM_I2C_Timeout--;
   \   00000016   0x....             LDR.N    R2,??DataTable4
   \   00000018   0x8812             LDRH     R2,[R2, #+0]
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0x....             LDR.N    R3,??DataTable4
   \   0000001E   0x801A             STRH     R2,[R3, #+0]
   \   00000020   0xE7F2             B.N      ??TM_I2C_WriteData_0
    229          	}
    230          	
    231          	/* Send I2C data */
    232          	I2Cx->DR = data;
   \                     ??TM_I2C_WriteData_1: (+1)
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x8201             STRH     R1,[R0, #+16]
    233          }
   \   00000026   0x4770             BX       LR               ;; return
    234          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    235          uint8_t TM_I2C_ReadAck(I2C_TypeDef* I2Cx) {
   \                     TM_I2C_ReadAck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    236          	uint8_t data;
    237          	
    238          	/* Enable ACK */
    239          	I2Cx->CR1 |= I2C_CR1_ACK;
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   0000000A   0x8020             STRH     R0,[R4, #+0]
    240          	
    241          	/* Wait till not received */
    242          	TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   0000000C   0xF247 0x5030      MOVW     R0,#+30000
   \   00000010   0x....             LDR.N    R1,??DataTable4
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    243          	while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
   \                     ??TM_I2C_ReadAck_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable4_2  ;; 0x30040
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       I2C_CheckEvent
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD10A             BNE.N    ??TM_I2C_ReadAck_1
    244          		if (--TM_I2C_Timeout == 0x00) {
   \   00000020   0x....             LDR.N    R0,??DataTable4
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable4
   \   00000028   0x8008             STRH     R0,[R1, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable4
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F0             BNE.N    ??TM_I2C_ReadAck_0
    245          			return 1;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE003             B.N      ??TM_I2C_ReadAck_2
    246          		}
    247          	}
    248          	
    249          	/* Read data */
    250          	data = I2Cx->DR;
   \                     ??TM_I2C_ReadAck_1: (+1)
   \   00000036   0x8A20             LDRH     R0,[R4, #+16]
   \   00000038   0x0005             MOVS     R5,R0
    251          	
    252          	/* Return data */
    253          	return data;
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??TM_I2C_ReadAck_2: (+1)
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    254          }
    255          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    256          uint8_t TM_I2C_ReadNack(I2C_TypeDef* I2Cx) {
   \                     TM_I2C_ReadNack: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    257          	uint8_t data;
    258          	
    259          	/* Disable ACK */
    260          	I2Cx->CR1 &= ~I2C_CR1_ACK;
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0xF64F 0x31FF      MOVW     R1,#+64511
   \   0000000A   0x4008             ANDS     R0,R1,R0
   \   0000000C   0x8020             STRH     R0,[R4, #+0]
    261          	
    262          	/* Generate stop */
    263          	I2Cx->CR1 |= I2C_CR1_STOP;
   \   0000000E   0x8820             LDRH     R0,[R4, #+0]
   \   00000010   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    264          	
    265          	/* Wait till received */
    266          	TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   00000016   0xF247 0x5030      MOVW     R0,#+30000
   \   0000001A   0x....             LDR.N    R1,??DataTable4
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    267          	while (!I2C_CheckEvent(I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
   \                     ??TM_I2C_ReadNack_0: (+1)
   \   0000001E   0x....             LDR.N    R1,??DataTable4_2  ;; 0x30040
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       I2C_CheckEvent
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10A             BNE.N    ??TM_I2C_ReadNack_1
    268          		if (--TM_I2C_Timeout == 0x00) {
   \   0000002A   0x....             LDR.N    R0,??DataTable4
   \   0000002C   0x8800             LDRH     R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable4
   \   00000032   0x8008             STRH     R0,[R1, #+0]
   \   00000034   0x....             LDR.N    R0,??DataTable4
   \   00000036   0x8800             LDRH     R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F0             BNE.N    ??TM_I2C_ReadNack_0
    269          			return 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE003             B.N      ??TM_I2C_ReadNack_2
    270          		}
    271          	}
    272          
    273          	/* Read data */
    274          	data = I2Cx->DR;
   \                     ??TM_I2C_ReadNack_1: (+1)
   \   00000040   0x8A20             LDRH     R0,[R4, #+16]
   \   00000042   0x0005             MOVS     R5,R0
    275          	
    276          	/* Return data */
    277          	return data;
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??TM_I2C_ReadNack_2: (+1)
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    278          }
    279          //----------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    280          uint8_t TM_I2C_Stop(I2C_TypeDef* I2Cx) {
   \                     TM_I2C_Stop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    281          	/* Wait till transmitter not empty */
    282          	TM_I2C_Timeout = TM_I2C_TIMEOUT;
   \   00000002   0xF247 0x5030      MOVW     R0,#+30000
   \   00000006   0x....             LDR.N    R2,??DataTable4
   \   00000008   0x8010             STRH     R0,[R2, #+0]
    283          	while (((!(I2Cx->SR1 & I2C_SR1_TXE)) || (!(I2Cx->SR1 & I2C_SR1_BTF)))) {
   \                     ??TM_I2C_Stop_0: (+1)
   \   0000000A   0x8A88             LDRH     R0,[R1, #+20]
   \   0000000C   0x0600             LSLS     R0,R0,#+24
   \   0000000E   0xD502             BPL.N    ??TM_I2C_Stop_1
   \   00000010   0x8A88             LDRH     R0,[R1, #+20]
   \   00000012   0x0740             LSLS     R0,R0,#+29
   \   00000014   0xD40A             BMI.N    ??TM_I2C_Stop_2
    284          		if (--TM_I2C_Timeout == 0x00) {
   \                     ??TM_I2C_Stop_1: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable4
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x1E40             SUBS     R0,R0,#+1
   \   0000001C   0x....             LDR.N    R2,??DataTable4
   \   0000001E   0x8010             STRH     R0,[R2, #+0]
   \   00000020   0x....             LDR.N    R0,??DataTable4
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD1F0             BNE.N    ??TM_I2C_Stop_0
    285          			return 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE004             B.N      ??TM_I2C_Stop_3
    286          		}
    287          	}
    288          	
    289          	/* Generate stop */
    290          	I2Cx->CR1 |= I2C_CR1_STOP;
   \                     ??TM_I2C_Stop_2: (+1)
   \   0000002C   0x8808             LDRH     R0,[R1, #+0]
   \   0000002E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000032   0x8008             STRH     R0,[R1, #+0]
    291          	
    292          	/* Return 0, everything ok */
    293          	return 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??TM_I2C_Stop_3: (+1)
   \   00000036   0x4770             BX       LR               ;; return
    294          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     TM_I2C_Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x00030040         DC32     0x30040
    295          //----------------------------------------------------
    296          
    297          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TM_I2C_IsDeviceConnected
        16   -> TM_I2C_Start
        16   -> TM_I2C_Stop
      24   TM_I2C_Read
        24   -> TM_I2C_ReadNack
        24   -> TM_I2C_Start
        24   -> TM_I2C_Stop
        24   -> TM_I2C_WriteData
      16   TM_I2C_ReadAck
        16   -> I2C_CheckEvent
      24   TM_I2C_ReadMulti
        24   -> TM_I2C_ReadAck
        24   -> TM_I2C_ReadNack
        24   -> TM_I2C_Start
        24   -> TM_I2C_WriteData
      24   TM_I2C_ReadMultiNoRegister
        24   -> TM_I2C_ReadAck
        24   -> TM_I2C_ReadNack
        24   -> TM_I2C_Start
      16   TM_I2C_ReadNack
        16   -> I2C_CheckEvent
      16   TM_I2C_ReadNoRegister
        16   -> TM_I2C_ReadNack
        16   -> TM_I2C_Start
      24   TM_I2C_Start
        24   -> I2C_CheckEvent
       0   TM_I2C_Stop
      24   TM_I2C_Write
        24   -> TM_I2C_Start
        24   -> TM_I2C_Stop
        24   -> TM_I2C_WriteData
       0   TM_I2C_WriteData
      24   TM_I2C_WriteMulti
        24   -> TM_I2C_Start
        24   -> TM_I2C_Stop
        24   -> TM_I2C_WriteData
      24   TM_I2C_WriteMultiNoRegister
        24   -> TM_I2C_Start
        24   -> TM_I2C_Stop
        24   -> TM_I2C_WriteData
      16   TM_I2C_WriteNoRegister
        16   -> TM_I2C_Start
        16   -> TM_I2C_Stop
        16   -> TM_I2C_WriteData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       1  ADD_EErom
       1  BYTE_rom
       1  En_ADD
      88  Flow_E2Prom_ADD_
      42  TM_I2C_IsDeviceConnected
      66  TM_I2C_Read
      64  TM_I2C_ReadAck
     104  TM_I2C_ReadMulti
      62  TM_I2C_ReadMultiNoRegister
      74  TM_I2C_ReadNack
      34  TM_I2C_ReadNoRegister
     182  TM_I2C_Start
      56  TM_I2C_Stop
       2  TM_I2C_Timeout
      52  TM_I2C_Write
      40  TM_I2C_WriteData
      74  TM_I2C_WriteMulti
      54  TM_I2C_WriteMultiNoRegister
      40  TM_I2C_WriteNoRegister
       1  index1

 
   6 bytes in section .bss
  88 bytes in section .rodata
 956 bytes in section .text
 
 956 bytes of CODE  memory
  88 bytes of CONST memory
   6 bytes of DATA  memory

Errors: none
Warnings: none
