###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        05/Nov/2025  15:02:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
#    Command line =  
#        "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F40XX -lC "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\List\" -o "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\Debug\Obj\" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\Turbo Fan\Codes\14030723
#        BLDC-valve2 added\board\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\app\" -I "D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\CMSIS\Device\ST\STM32F4xx\Include\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2
#        added\Libraries\STM32F4xx_StdPeriph_Driver\inc\" -I "D:\Turbo
#        Fan\Codes\14030723 BLDC-valve2 added\modules\Header\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.2\arm\CMSIS\Include\" --relaxed_fp
#    List file    =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\List\stm32f4xx_rcc.lst
#    Object file  =  
#        D:\Turbo Fan\Codes\14030723 BLDC-valve2
#        added\Debug\Obj\stm32f4xx_rcc.o
#
###############################################################################

D:\Turbo Fan\Codes\14030723 BLDC-valve2 added\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:
      9            *           + Internal/external clocks, PLL, CSS and MCO configuration
     10            *           + System, AHB and APB busses clocks configuration
     11            *           + Peripheral clocks configuration
     12            *           + Interrupts and flags management
     13            *
     14           @verbatim                
     15           ===============================================================================
     16                                ##### RCC specific features #####
     17           ===============================================================================
     18              [..]  
     19                After reset the device is running from Internal High Speed oscillator 
     20                (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
     21                and I-Cache are disabled, and all peripherals are off except internal
     22                SRAM, Flash and JTAG.
     23                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     24                    all peripherals mapped on these busses are running at HSI speed.
     25                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     26                (+) All GPIOs are in input floating state, except the JTAG pins which
     27                    are assigned to be used for debug purpose.
     28              [..]          
     29                Once the device started from reset, the user application has to:        
     30                (+) Configure the clock source to be used to drive the System clock
     31                    (if the application needs higher frequency/performance)
     32                (+) Configure the System clock frequency and Flash settings  
     33                (+) Configure the AHB and APB busses prescalers
     34                (+) Enable the clock for the peripheral(s) to be used
     35                (+) Configure the clock source(s) for peripherals which clocks are not
     36                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)                                
     37           @endverbatim    
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     42            *
     43            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     44            * You may not use this file except in compliance with the License.
     45            * You may obtain a copy of the License at:
     46            *
     47            *        http://www.st.com/software_license_agreement_liberty_v2
     48            *
     49            * Unless required by applicable law or agreed to in writing, software 
     50            * distributed under the License is distributed on an "AS IS" BASIS, 
     51            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     52            * See the License for the specific language governing permissions and
     53            * limitations under the License.
     54            *
     55            ******************************************************************************
     56            */
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f4xx_rcc.h"
     60          
     61          /** @addtogroup STM32F4xx_StdPeriph_Driver
     62            * @{
     63            */
     64          
     65          /** @defgroup RCC 
     66            * @brief RCC driver modules
     67            * @{
     68            */ 
     69          
     70          /* Private typedef -----------------------------------------------------------*/
     71          /* Private define ------------------------------------------------------------*/
     72          /* ------------ RCC registers bit address in the alias region ----------- */
     73          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     74          /* --- CR Register ---*/
     75          /* Alias word address of HSION bit */
     76          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     77          #define HSION_BitNumber           0x00
     78          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     79          /* Alias word address of CSSON bit */
     80          #define CSSON_BitNumber           0x13
     81          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     82          /* Alias word address of PLLON bit */
     83          #define PLLON_BitNumber           0x18
     84          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     85          /* Alias word address of PLLI2SON bit */
     86          #define PLLI2SON_BitNumber        0x1A
     87          #define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
     88          
     89          /* Alias word address of PLLSAION bit */
     90          #define PLLSAION_BitNumber        0x1C
     91          #define CR_PLLSAION_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLSAION_BitNumber * 4))
     92          
     93          /* --- CFGR Register ---*/
     94          /* Alias word address of I2SSRC bit */
     95          #define CFGR_OFFSET               (RCC_OFFSET + 0x08)
     96          #define I2SSRC_BitNumber          0x17
     97          #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
     98          
     99          /* --- BDCR Register ---*/
    100          /* Alias word address of RTCEN bit */
    101          #define BDCR_OFFSET               (RCC_OFFSET + 0x70)
    102          #define RTCEN_BitNumber           0x0F
    103          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
    104          /* Alias word address of BDRST bit */
    105          #define BDRST_BitNumber           0x10
    106          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
    107          
    108          /* --- CSR Register ---*/
    109          /* Alias word address of LSION bit */
    110          #define CSR_OFFSET                (RCC_OFFSET + 0x74)
    111          #define LSION_BitNumber           0x00
    112          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    113          
    114          /* --- DCKCFGR Register ---*/
    115          /* Alias word address of TIMPRE bit */
    116          #define DCKCFGR_OFFSET            (RCC_OFFSET + 0x8C)
    117          #define TIMPRE_BitNumber          0x18
    118          #define DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (DCKCFGR_OFFSET * 32) + (TIMPRE_BitNumber * 4))
    119          /* ---------------------- RCC registers bit mask ------------------------ */
    120          /* CFGR register bit mask */
    121          #define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
    122          #define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
    123          
    124          /* RCC Flag Mask */
    125          #define FLAG_MASK                 ((uint8_t)0x1F)
    126          
    127          /* CR register byte 3 (Bits[23:16]) base address */
    128          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
    129          
    130          /* CIR register byte 2 (Bits[15:8]) base address */
    131          #define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
    132          
    133          /* CIR register byte 3 (Bits[23:16]) base address */
    134          #define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
    135          
    136          /* BDCR register base address */
    137          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    138          
    139          /* Private macro -------------------------------------------------------------*/
    140          /* Private variables ---------------------------------------------------------*/

   \                                 In section .data, align 4
    141          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
    142          
    143          /* Private function prototypes -----------------------------------------------*/
    144          /* Private functions ---------------------------------------------------------*/
    145          
    146          /** @defgroup RCC_Private_Functions
    147            * @{
    148            */ 
    149          
    150          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
    151           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
    152           *
    153          @verbatim   
    154           ===================================================================================
    155           ##### Internal and  external clocks, PLL, CSS and MCO configuration functions #####
    156           ===================================================================================  
    157              [..]
    158                This section provide functions allowing to configure the internal/external clocks,
    159                PLLs, CSS and MCO pins.
    160            
    161                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    162                    the PLL as System clock source.
    163          
    164                (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    165                    clock source.
    166          
    167                (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    168                    through the PLL as System clock source. Can be used also as RTC clock source.
    169          
    170                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    171          
    172                (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    173                  (++) The first output is used to generate the high speed system clock (up to 168 MHz)
    174                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
    175                       the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    176          
    177                (#) PLLI2S (clocked by HSI or HSE), used to generate an accurate clock to achieve 
    178                    high-quality audio performance on the I2S interface or SAI interface in case 
    179                    of STM32F429x/439x devices.
    180               
    181                (#) PLLSAI clocked by (HSI or HSE), used to generate an accurate clock to SAI 
    182                    interface and LCD TFT controller available only for STM32F42xxx/43xxx devices.
    183            
    184                (#) CSS (Clock security system), once enable and if a HSE clock failure occurs 
    185                   (HSE used directly or through PLL as System clock source), the System clock
    186                   is automatically switched to HSI and an interrupt is generated if enabled. 
    187                   The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
    188                   exception vector.   
    189          
    190                (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    191                    clock (through a configurable prescaler) on PA8 pin.
    192          
    193                (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    194                    clock (through a configurable prescaler) on PC9 pin.
    195           @endverbatim
    196            * @{
    197            */
    198          
    199          /**
    200            * @brief  Resets the RCC clock configuration to the default reset state.
    201            * @note   The default reset state of the clock configuration is given below:
    202            *            - HSI ON and used as system clock source
    203            *            - HSE, PLL and PLLI2S OFF
    204            *            - AHB, APB1 and APB2 prescaler set to 1.
    205            *            - CSS, MCO1 and MCO2 OFF
    206            *            - All interrupts disabled
    207            * @note   This function doesn't modify the configuration of the
    208            *            - Peripheral clocks  
    209            *            - LSI, LSE and RTC clocks 
    210            * @param  None
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void RCC_DeInit(void)
    214          {
    215            /* Set HSION bit */
    216            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable50  ;; 0x40023800
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40023800
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    217          
    218            /* Reset CFGR register */
    219            RCC->CFGR = 0x00000000;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable50_1  ;; 0x40023808
   \   00000016   0x6008             STR      R0,[R1, #+0]
    220          
    221            /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
    222            RCC->CR &= (uint32_t)0xEAF6FFFF;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable50  ;; 0x40023800
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable50_2  ;; 0xeaf6ffff
   \   00000022   0x4008             ANDS     R0,R1,R0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40023800
   \   00000028   0x6008             STR      R0,[R1, #+0]
    223          
    224            /* Reset PLLCFGR register */
    225            RCC->PLLCFGR = 0x24003010;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable50_3  ;; 0x24003010
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable50_4  ;; 0x40023804
   \   00000032   0x6008             STR      R0,[R1, #+0]
    226          
    227            /* Reset PLLI2SCFGR register */
    228            RCC->PLLI2SCFGR = 0x20003000;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable50_5  ;; 0x20003000
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable50_6  ;; 0x40023884
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    229          
    230            /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
    231            RCC->PLLSAICFGR = 0x24003000;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable50_7  ;; 0x24003000
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable50_8  ;; 0x40023888
   \   00000046   0x6008             STR      R0,[R1, #+0]
    232           
    233            /* Reset HSEBYP bit */
    234            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable50  ;; 0x40023800
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable50  ;; 0x40023800
   \   00000056   0x6008             STR      R0,[R1, #+0]
    235          
    236            /* Disable all interrupts */
    237            RCC->CIR = 0x00000000;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable50_9  ;; 0x4002380c
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    238          
    239            /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
    240            RCC->DCKCFGR = 0x00000000; 
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable50_10  ;; 0x4002388c
   \   00000066   0x6008             STR      R0,[R1, #+0]
    241          
    242          }
   \   00000068   0x4770             BX       LR               ;; return
    243          
    244          /**
    245            * @brief  Configures the External High Speed oscillator (HSE).
    246            * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    247            *         software should wait on HSERDY flag to be set indicating that HSE clock
    248            *         is stable and can be used to clock the PLL and/or system clock.
    249            * @note   HSE state can not be changed if it is used directly or through the
    250            *         PLL as system clock. In this case, you have to select another source
    251            *         of the system clock then change the HSE state (ex. disable it).
    252            * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.  
    253            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    254            *         was previously enabled you have to enable it again after calling this
    255            *         function.    
    256            * @param  RCC_HSE: specifies the new state of the HSE.
    257            *          This parameter can be one of the following values:
    258            *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    259            *                              6 HSE oscillator clock cycles.
    260            *            @arg RCC_HSE_ON: turn ON the HSE oscillator
    261            *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    262            * @retval None
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          void RCC_HSEConfig(uint8_t RCC_HSE)
    265          {
    266            /* Check the parameters */
    267            assert_param(IS_RCC_HSE(RCC_HSE));
    268          
    269            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    270            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   \                     RCC_HSEConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_11  ;; 0x40023802
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    271          
    272            /* Set the new HSE configuration -------------------------------------------*/
    273            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable50_11  ;; 0x40023802
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    274          }
   \   0000000E   0x4770             BX       LR               ;; return
    275          
    276          /**
    277            * @brief  Waits for HSE start-up.
    278            * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
    279            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    280            *         and this flag is not set. The timeout value is defined by the constant
    281            *         HSE_STARTUP_TIMEOUT in stm32f4xx.h file. You can tailor it depending
    282            *         on the HSE crystal used in your application. 
    283            * @param  None
    284            * @retval An ErrorStatus enumeration value:
    285            *          - SUCCESS: HSE oscillator is stable and ready to use
    286            *          - ERROR: HSE oscillator not yet ready
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          ErrorStatus RCC_WaitForHSEStartUp(void)
    289          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    290            __IO uint32_t startupcounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    291            ErrorStatus status = ERROR;
   \   00000006   0x2400             MOVS     R4,#+0
    292            FlagStatus hsestatus = RESET;
   \   00000008   0x2500             MOVS     R5,#+0
    293            /* Wait till HSE is ready and if Time out is reached exit */
    294            do
    295            {
    296              hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2031             MOVS     R0,#+49
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000010   0x0005             MOVS     R5,R0
    297              startupcounter++;
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
    298            } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
   \   00000018   0x9800             LDR      R0,[SP, #+0]
   \   0000001A   0xF5B0 0x4FA0      CMP      R0,#+20480
   \   0000001E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD0F1             BEQ.N    ??RCC_WaitForHSEStartUp_0
    299          
    300            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000026   0x2031             MOVS     R0,#+49
   \   00000028   0x.... 0x....      BL       RCC_GetFlagStatus
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??RCC_WaitForHSEStartUp_2
    301            {
    302              status = SUCCESS;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE001             B.N      ??RCC_WaitForHSEStartUp_3
    303            }
    304            else
    305            {
    306              status = ERROR;
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x0004             MOVS     R4,R0
    307            }
    308            return (status);
   \                     ??RCC_WaitForHSEStartUp_3: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    309          }
    310          
    311          /**
    312            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    313            * @note   The calibration is used to compensate for the variations in voltage
    314            *         and temperature that influence the frequency of the internal HSI RC.
    315            * @param  HSICalibrationValue: specifies the calibration trimming value.
    316            *         This parameter must be a number between 0 and 0x1F.
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    320          {
    321            uint32_t tmpreg = 0;
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    322            /* Check the parameters */
    323            assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    324          
    325            tmpreg = RCC->CR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50  ;; 0x40023800
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
    326          
    327            /* Clear HSITRIM[4:0] bits */
    328            tmpreg &= ~RCC_CR_HSITRIM;
   \   0000000A   0xF031 0x01F8      BICS     R1,R1,#0xF8
    329          
    330            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    331            tmpreg |= (uint32_t)HSICalibrationValue << 3;
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
    332          
    333            /* Store the new value */
    334            RCC->CR = tmpreg;
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable50  ;; 0x40023800
   \   00000018   0x6011             STR      R1,[R2, #+0]
    335          }
   \   0000001A   0x4770             BX       LR               ;; return
    336          
    337          /**
    338            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    339            * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
    340            *         It is used (enabled by hardware) as system clock source after startup
    341            *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
    342            *         of the HSE used directly or indirectly as system clock (if the Clock
    343            *         Security System CSS is enabled).             
    344            * @note   HSI can not be stopped if it is used as system clock source. In this case,
    345            *         you have to select another source of the system clock then stop the HSI.  
    346            * @note   After enabling the HSI, the application software should wait on HSIRDY
    347            *         flag to be set indicating that HSI clock is stable and can be used as
    348            *         system clock source.  
    349            * @param  NewState: new state of the HSI.
    350            *          This parameter can be: ENABLE or DISABLE.
    351            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    352            *         clock cycles.  
    353            * @retval None
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          void RCC_HSICmd(FunctionalState NewState)
    356          {
    357            /* Check the parameters */
    358            assert_param(IS_FUNCTIONAL_STATE(NewState));
    359          
    360            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_12  ;; 0x42470000
   \   00000006   0x6008             STR      R0,[R1, #+0]
    361          }
   \   00000008   0x4770             BX       LR               ;; return
    362          
    363          /**
    364            * @brief  Configures the External Low Speed oscillator (LSE).
    365            * @note   As the LSE is in the Backup domain and write access is denied to
    366            *         this domain after reset, you have to enable write access using 
    367            *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
    368            *         (to be done once after reset).  
    369            * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    370            *         software should wait on LSERDY flag to be set indicating that LSE clock
    371            *         is stable and can be used to clock the RTC.
    372            * @param  RCC_LSE: specifies the new state of the LSE.
    373            *          This parameter can be one of the following values:
    374            *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    375            *                              6 LSE oscillator clock cycles.
    376            *            @arg RCC_LSE_ON: turn ON the LSE oscillator
    377            *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void RCC_LSEConfig(uint8_t RCC_LSE)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_RCC_LSE(RCC_LSE));
    384          
    385            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    386            /* Reset LSEON bit */
    387            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \                     RCC_LSEConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_13  ;; 0x40023870
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    388          
    389            /* Reset LSEBYP bit */
    390            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable50_13  ;; 0x40023870
   \   0000000E   0x7011             STRB     R1,[R2, #+0]
    391          
    392            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    393            switch (RCC_LSE)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x0001             MOVS     R1,R0
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0xD002             BEQ.N    ??RCC_LSEConfig_0
   \   00000018   0x2904             CMP      R1,#+4
   \   0000001A   0xD005             BEQ.N    ??RCC_LSEConfig_1
   \   0000001C   0xE009             B.N      ??RCC_LSEConfig_2
    394            {
    395              case RCC_LSE_ON:
    396                /* Set LSEON bit */
    397                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
   \                     ??RCC_LSEConfig_0: (+1)
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable50_13  ;; 0x40023870
   \   00000024   0x7011             STRB     R1,[R2, #+0]
    398                break;
   \   00000026   0xE004             B.N      ??RCC_LSEConfig_3
    399              case RCC_LSE_Bypass:
    400                /* Set LSEBYP and LSEON bits */
    401                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
   \                     ??RCC_LSEConfig_1: (+1)
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable50_13  ;; 0x40023870
   \   0000002E   0x7011             STRB     R1,[R2, #+0]
    402                break;
   \   00000030   0xE7FF             B.N      ??RCC_LSEConfig_3
    403              default:
    404                break;
    405            }
    406          }
   \                     ??RCC_LSEConfig_2: (+1)
   \                     ??RCC_LSEConfig_3: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    407          
    408          /**
    409            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    410            * @note   After enabling the LSI, the application software should wait on 
    411            *         LSIRDY flag to be set indicating that LSI clock is stable and can
    412            *         be used to clock the IWDG and/or the RTC.
    413            * @note   LSI can not be disabled if the IWDG is running.  
    414            * @param  NewState: new state of the LSI.
    415            *          This parameter can be: ENABLE or DISABLE.
    416            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    417            *         clock cycles. 
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void RCC_LSICmd(FunctionalState NewState)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_FUNCTIONAL_STATE(NewState));
    424          
    425            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_14  ;; 0x42470e80
   \   00000006   0x6008             STR      R0,[R1, #+0]
    426          }
   \   00000008   0x4770             BX       LR               ;; return
    427          
    428          /**
    429            * @brief  Configures the main PLL clock source, multiplication and division factors.
    430            * @note   This function must be used only when the main PLL is disabled.
    431            *  
    432            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    433            *          This parameter can be one of the following values:
    434            *            @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
    435            *            @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
    436            * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
    437            *  
    438            * @param  PLLM: specifies the division factor for PLL VCO input clock
    439            *          This parameter must be a number between 0 and 63.
    440            * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
    441            *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
    442            *         of 2 MHz to limit PLL jitter.
    443            *  
    444            * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
    445            *          This parameter must be a number between 192 and 432.
    446            * @note   You have to set the PLLN parameter correctly to ensure that the VCO
    447            *         output frequency is between 192 and 432 MHz.
    448            *   
    449            * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
    450            *          This parameter must be a number in the range {2, 4, 6, or 8}.
    451            * @note   You have to set the PLLP parameter correctly to not exceed 168 MHz on
    452            *         the System clock frequency.
    453            *  
    454            * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
    455            *          This parameter must be a number between 4 and 15.
    456            * @note   If the USB OTG FS is used in your application, you have to set the
    457            *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
    458            *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
    459            *         correctly.
    460            *   
    461            * @retval None
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
    464          {
   \                     RCC_PLLConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x9C03             LDR      R4,[SP, #+12]
    465            /* Check the parameters */
    466            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    467            assert_param(IS_RCC_PLLM_VALUE(PLLM));
    468            assert_param(IS_RCC_PLLN_VALUE(PLLN));
    469            assert_param(IS_RCC_PLLP_VALUE(PLLP));
    470            assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
    471          
    472            RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
    473                           (PLLQ << 24);
   \   00000004   0xEA51 0x1582      ORRS     R5,R1,R2, LSL #+6
   \   00000008   0x1E9E             SUBS     R6,R3,#+2
   \   0000000A   0x03F6             LSLS     R6,R6,#+15
   \   0000000C   0x0C36             LSRS     R6,R6,#+16
   \   0000000E   0x0436             LSLS     R6,R6,#+16
   \   00000010   0x4335             ORRS     R5,R6,R5
   \   00000012   0x4305             ORRS     R5,R0,R5
   \   00000014   0xEA55 0x6504      ORRS     R5,R5,R4, LSL #+24
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable50_4  ;; 0x40023804
   \   0000001C   0x6035             STR      R5,[R6, #+0]
    474          }
   \   0000001E   0xBC70             POP      {R4-R6}
   \   00000020   0x4770             BX       LR               ;; return
    475          
    476          /**
    477            * @brief  Enables or disables the main PLL.
    478            * @note   After enabling the main PLL, the application software should wait on 
    479            *         PLLRDY flag to be set indicating that PLL clock is stable and can
    480            *         be used as system clock source.
    481            * @note   The main PLL can not be disabled if it is used as system clock source
    482            * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
    483            * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void RCC_PLLCmd(FunctionalState NewState)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_15  ;; 0x42470060
   \   00000006   0x6008             STR      R0,[R1, #+0]
    491          }
   \   00000008   0x4770             BX       LR               ;; return
    492          
    493          #if defined (STM32F40_41xxx) || defined (STM32F401xx)
    494          /**
    495            * @brief  Configures the PLLI2S clock multiplication and division factors.
    496            *  
    497            * @note   This function can be used only for STM32F405xx/407xx, STM32F415xx/417xx 
    498            *         or STM32F401xx devices. 
    499            *    
    500            * @note   This function must be used only when the PLLI2S is disabled.
    501            * @note   PLLI2S clock source is common with the main PLL (configured in 
    502            *         RCC_PLLConfig function )  
    503            *             
    504            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    505            *          This parameter must be a number between 192 and 432.
    506            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    507            *         output frequency is between 192 and 432 MHz.
    508            *    
    509            * @param  PLLI2SR: specifies the division factor for I2S clock
    510            *          This parameter must be a number between 2 and 7.
    511            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    512            *         on the I2S clock frequency.
    513            *   
    514            * @retval None
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
    517          {
    518            /* Check the parameters */
    519            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    520            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    521          
    522            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
   \                     RCC_PLLI2SConfig: (+1)
   \   00000000   0x070A             LSLS     R2,R1,#+28
   \   00000002   0xEA52 0x1280      ORRS     R2,R2,R0, LSL #+6
   \   00000006   0x.... 0x....      LDR.W    R3,??DataTable50_6  ;; 0x40023884
   \   0000000A   0x601A             STR      R2,[R3, #+0]
    523          }
   \   0000000C   0x4770             BX       LR               ;; return
    524          #endif /* STM32F40_41xxx || STM32F401xx */
    525          
    526          #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
    527          /**
    528            * @brief  Configures the PLLI2S clock multiplication and division factors.
    529            * 
    530            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    531            *         
    532            * @note   This function must be used only when the PLLI2S is disabled.
    533            * @note   PLLI2S clock source is common with the main PLL (configured in 
    534            *         RCC_PLLConfig function )  
    535            *             
    536            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    537            *          This parameter must be a number between 192 and 432.
    538            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    539            *         output frequency is between 192 and 432 MHz.
    540            * 
    541            * @param  PLLI2SQ: specifies the division factor for SAI1 clock
    542            *          This parameter must be a number between 2 and 15.
    543            *                 
    544            * @param  PLLI2SR: specifies the division factor for I2S clock
    545            *          This parameter must be a number between 2 and 7.
    546            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    547            *         on the I2S clock frequency.
    548            * @note   the PLLI2SR parameter is only available with STM32F42xxx/43xxx devices.  
    549            *   
    550            * @retval None
    551            */
    552          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR)
    553          {
    554            /* Check the parameters */
    555            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    556            assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SQ));
    557            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    558          
    559            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SQ << 24) | (PLLI2SR << 28);
    560          }
    561          #endif /* STM32F427_437xx ||  STM32F429_439xx */
    562          
    563          /**
    564            * @brief  Enables or disables the PLLI2S. 
    565            * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
    566            * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
    567            * @retval None
    568            */

   \                                 In section .text, align 2, keep-with-next
    569          void RCC_PLLI2SCmd(FunctionalState NewState)
    570          {
    571            /* Check the parameters */
    572            assert_param(IS_FUNCTIONAL_STATE(NewState));
    573            *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
   \                     RCC_PLLI2SCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_16  ;; 0x42470068
   \   00000006   0x6008             STR      R0,[R1, #+0]
    574          }
   \   00000008   0x4770             BX       LR               ;; return
    575          
    576          /**
    577            * @brief  Configures the PLLSAI clock multiplication and division factors.
    578            *
    579            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    580            *        
    581            * @note   This function must be used only when the PLLSAI is disabled.
    582            * @note   PLLSAI clock source is common with the main PLL (configured in 
    583            *         RCC_PLLConfig function )  
    584            *             
    585            * @param  PLLSAIN: specifies the multiplication factor for PLLSAI VCO output clock
    586            *          This parameter must be a number between 192 and 432.
    587            * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
    588            *         output frequency is between 192 and 432 MHz.
    589            *           
    590            * @param  PLLSAIQ: specifies the division factor for SAI1 clock
    591            *          This parameter must be a number between 2 and 15.
    592            *            
    593            * @param  PLLSAIR: specifies the division factor for LTDC clock
    594            *          This parameter must be a number between 2 and 7.
    595            *   
    596            * @retval None
    597            */

   \                                 In section .text, align 2, keep-with-next
    598          void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
    599          {
   \                     RCC_PLLSAIConfig: (+1)
   \   00000000   0xB410             PUSH     {R4}
    600            /* Check the parameters */
    601            assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
    602            assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
    603          
    604            RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
   \   00000002   0x060B             LSLS     R3,R1,#+24
   \   00000004   0xEA53 0x1380      ORRS     R3,R3,R0, LSL #+6
   \   00000008   0xEA53 0x7302      ORRS     R3,R3,R2, LSL #+28
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable50_8  ;; 0x40023888
   \   00000010   0x6023             STR      R3,[R4, #+0]
    605          }
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    606          
    607          /**
    608            * @brief  Enables or disables the PLLSAI. 
    609            * 
    610            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    611            *       
    612            * @note   The PLLSAI is disabled by hardware when entering STOP and STANDBY modes.  
    613            * @param  NewState: new state of the PLLSAI. This parameter can be: ENABLE or DISABLE.
    614            * @retval None
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          void RCC_PLLSAICmd(FunctionalState NewState)
    617          {
    618            /* Check the parameters */
    619            assert_param(IS_FUNCTIONAL_STATE(NewState));
    620            *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
   \                     RCC_PLLSAICmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_17  ;; 0x42470070
   \   00000006   0x6008             STR      R0,[R1, #+0]
    621          }
   \   00000008   0x4770             BX       LR               ;; return
    622          
    623          /**
    624            * @brief  Enables or disables the Clock Security System.
    625            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    626            *         is automatically disabled and an interrupt is generated to inform the
    627            *         software about the failure (Clock Security System Interrupt, CSSI),
    628            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    629            *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
    630            * @param  NewState: new state of the Clock Security System.
    631            *         This parameter can be: ENABLE or DISABLE.
    632            * @retval None
    633            */

   \                                 In section .text, align 2, keep-with-next
    634          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    635          {
    636            /* Check the parameters */
    637            assert_param(IS_FUNCTIONAL_STATE(NewState));
    638            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_18  ;; 0x4247004c
   \   00000006   0x6008             STR      R0,[R1, #+0]
    639          }
   \   00000008   0x4770             BX       LR               ;; return
    640          
    641          /**
    642            * @brief  Selects the clock source to output on MCO1 pin(PA8).
    643            * @note   PA8 should be configured in alternate function mode.
    644            * @param  RCC_MCO1Source: specifies the clock source to output.
    645            *          This parameter can be one of the following values:
    646            *            @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
    647            *            @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
    648            *            @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
    649            *            @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
    650            * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
    651            *          This parameter can be one of the following values:
    652            *            @arg RCC_MCO1Div_1: no division applied to MCO1 clock
    653            *            @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
    654            *            @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
    655            *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
    656            *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
    657            * @retval None
    658            */

   \                                 In section .text, align 2, keep-with-next
    659          void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
    660          {
    661            uint32_t tmpreg = 0;
   \                     RCC_MCO1Config: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    662            
    663            /* Check the parameters */
    664            assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
    665            assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
    666          
    667            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable50_1  ;; 0x40023808
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x001A             MOVS     R2,R3
    668          
    669            /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
    670            tmpreg &= CFGR_MCO1_RESET_MASK;
   \   0000000A   0xF032 0x62EC      BICS     R2,R2,#0x7600000
    671          
    672            /* Select MCO1 clock source and prescaler */
    673            tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
   \   0000000E   0xEA51 0x0300      ORRS     R3,R1,R0
   \   00000012   0x431A             ORRS     R2,R3,R2
    674          
    675            /* Store the new value */
    676            RCC->CFGR = tmpreg;  
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable50_1  ;; 0x40023808
   \   00000018   0x601A             STR      R2,[R3, #+0]
    677          }
   \   0000001A   0x4770             BX       LR               ;; return
    678          
    679          /**
    680            * @brief  Selects the clock source to output on MCO2 pin(PC9).
    681            * @note   PC9 should be configured in alternate function mode.
    682            * @param  RCC_MCO2Source: specifies the clock source to output.
    683            *          This parameter can be one of the following values:
    684            *            @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    685            *            @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
    686            *            @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
    687            *            @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
    688            * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
    689            *          This parameter can be one of the following values:
    690            *            @arg RCC_MCO2Div_1: no division applied to MCO2 clock
    691            *            @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
    692            *            @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
    693            *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
    694            *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
    695            * @retval None
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
    698          {
    699            uint32_t tmpreg = 0;
   \                     RCC_MCO2Config: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
    700            
    701            /* Check the parameters */
    702            assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
    703            assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
    704            
    705            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R3,??DataTable50_1  ;; 0x40023808
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x001A             MOVS     R2,R3
    706            
    707            /* Clear MCO2 and MCO2PRE[2:0] bits */
    708            tmpreg &= CFGR_MCO2_RESET_MASK;
   \   0000000A   0x0152             LSLS     R2,R2,#+5        ;; ZeroExtS R2,R2,#+5,#+5
   \   0000000C   0x0952             LSRS     R2,R2,#+5
    709          
    710            /* Select MCO2 clock source and prescaler */
    711            tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
   \   0000000E   0xEA51 0x0300      ORRS     R3,R1,R0
   \   00000012   0x431A             ORRS     R2,R3,R2
    712          
    713            /* Store the new value */
    714            RCC->CFGR = tmpreg;  
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable50_1  ;; 0x40023808
   \   00000018   0x601A             STR      R2,[R3, #+0]
    715          }
   \   0000001A   0x4770             BX       LR               ;; return
    716          
    717          /**
    718            * @}
    719            */
    720          
    721          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    722           *  @brief   System, AHB and APB busses clocks configuration functions
    723           *
    724          @verbatim   
    725           ===============================================================================
    726                ##### System, AHB and APB busses clocks configuration functions #####
    727           ===============================================================================  
    728              [..]
    729                This section provide functions allowing to configure the System, AHB, APB1 and 
    730                APB2 busses clocks.
    731            
    732                (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    733                    HSE and PLL.
    734                    The AHB clock (HCLK) is derived from System clock through configurable 
    735                    prescaler and used to clock the CPU, memory and peripherals mapped 
    736                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    737                    from AHB clock through configurable prescalers and used to clock 
    738                    the peripherals mapped on these busses. You can use 
    739                    "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
    740          
    741                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    742                  (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
    743                       from an external clock mapped on the I2S_CKIN pin. 
    744                       You have to use RCC_I2SCLKConfig() function to configure this clock. 
    745                  (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    746                       divided by 2 to 31. You have to use RCC_RTCCLKConfig() and RCC_RTCCLKCmd()
    747                       functions to configure this clock. 
    748                  (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
    749                       to work correctly, while the SDIO require a frequency equal or lower than
    750                       to 48. This clock is derived of the main PLL through PLLQ divider.
    751                  (+@) IWDG clock which is always the LSI clock.
    752                 
    753                (#) For STM32F405xx/407xx and STM32F415xx/417xx devices, the maximum frequency 
    754                   of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz. Depending 
    755                   on the device voltage range, the maximum frequency should be adapted accordingly:
    756           +-------------------------------------------------------------------------------------+     
    757           | Latency       |                HCLK clock frequency (MHz)                           |
    758           |               |---------------------------------------------------------------------|     
    759           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    760           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    761           |---------------|----------------|----------------|-----------------|-----------------|              
    762           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    763           |---------------|----------------|----------------|-----------------|-----------------|   
    764           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    765           |---------------|----------------|----------------|-----------------|-----------------|   
    766           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    767           |---------------|----------------|----------------|-----------------|-----------------| 
    768           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    769           |---------------|----------------|----------------|-----------------|-----------------| 
    770           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    771           |---------------|----------------|----------------|-----------------|-----------------| 
    772           |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    773           |---------------|----------------|----------------|-----------------|-----------------| 
    774           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    775           |---------------|----------------|----------------|-----------------|-----------------| 
    776           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    777           +---------------|----------------|----------------|-----------------|-----------------+ 
    778                (#) For STM32F42xxx/43xxx devices, the maximum frequency of the SYSCLK and HCLK is 180 MHz, 
    779                    PCLK2 90 MHz and PCLK1 45 MHz. Depending on the device voltage range, the maximum 
    780                    frequency should be adapted accordingly:
    781           +-------------------------------------------------------------------------------------+     
    782           | Latency       |                HCLK clock frequency (MHz)                           |
    783           |               |---------------------------------------------------------------------|     
    784           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    785           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    786           |---------------|----------------|----------------|-----------------|-----------------|              
    787           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    788           |---------------|----------------|----------------|-----------------|-----------------|   
    789           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    790           |---------------|----------------|----------------|-----------------|-----------------|   
    791           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    792           |---------------|----------------|----------------|-----------------|-----------------| 
    793           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    794           |---------------|----------------|----------------|-----------------|-----------------| 
    795           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    796           |---------------|----------------|----------------|-----------------|-----------------| 
    797           |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    798           |---------------|----------------|----------------|-----------------|-----------------| 
    799           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    800           |---------------|----------------|----------------|-----------------|-----------------| 
    801           |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
    802           |---------------|----------------|----------------|-----------------|-----------------| 
    803           |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
    804           +-------------------------------------------------------------------------------------+
    805             
    806                (#) For STM32F401xx devices, the maximum frequency of the SYSCLK and HCLK is 84 MHz, 
    807                    PCLK2 84 MHz and PCLK1 42 MHz. Depending on the device voltage range, the maximum 
    808                    frequency should be adapted accordingly:
    809           +-------------------------------------------------------------------------------------+     
    810           | Latency       |                HCLK clock frequency (MHz)                           |
    811           |               |---------------------------------------------------------------------|     
    812           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    813           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    814           |---------------|----------------|----------------|-----------------|-----------------|              
    815           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    816           |---------------|----------------|----------------|-----------------|-----------------|   
    817           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    818           |---------------|----------------|----------------|-----------------|-----------------|   
    819           |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    820           |---------------|----------------|----------------|-----------------|-----------------| 
    821           |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
    822           |---------------|----------------|----------------|-----------------|-----------------| 
    823           |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  | 
    824           +-------------------------------------------------------------------------------------+ 
    825            
    826                -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
    827                     (++) when VOS = '0', the maximum value of fHCLK = 144MHz. 
    828                     (++) when VOS = '1', the maximum value of fHCLK = 168MHz. 
    829                    [..] 
    830                    On STM32F42xxx/43xxx devices:
    831                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 120MHz.
    832                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 144MHz.
    833                     (++) when VOS[1:0] = '0x11', the maximum value of f  is 168MHz 
    834                    [..]  
    835                    On STM32F401x devices:
    836                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 64MHz.
    837                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 84MHz.
    838                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    839          
    840          @endverbatim
    841            * @{
    842            */
    843          
    844          /**
    845            * @brief  Configures the system clock (SYSCLK).
    846            * @note   The HSI is used (enabled by hardware) as system clock source after
    847            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    848            *         of failure of the HSE used directly or indirectly as system clock
    849            *         (if the Clock Security System CSS is enabled).
    850            * @note   A switch from one clock source to another occurs only if the target
    851            *         clock source is ready (clock stable after startup delay or PLL locked). 
    852            *         If a clock source which is not yet ready is selected, the switch will
    853            *         occur when the clock source will be ready. 
    854            *         You can use RCC_GetSYSCLKSource() function to know which clock is
    855            *         currently used as system clock source. 
    856            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    857            *          This parameter can be one of the following values:
    858            *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    859            *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    860            *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    861            * @retval None
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    864          {
    865            uint32_t tmpreg = 0;
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    866          
    867            /* Check the parameters */
    868            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    869          
    870            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
    871          
    872            /* Clear SW[1:0] bits */
    873            tmpreg &= ~RCC_CFGR_SW;
   \   0000000A   0x0889             LSRS     R1,R1,#+2
   \   0000000C   0x0089             LSLS     R1,R1,#+2
    874          
    875            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    876            tmpreg |= RCC_SYSCLKSource;
   \   0000000E   0x4301             ORRS     R1,R0,R1
    877          
    878            /* Store the new value */
    879            RCC->CFGR = tmpreg;
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000014   0x6011             STR      R1,[R2, #+0]
    880          }
   \   00000016   0x4770             BX       LR               ;; return
    881          
    882          /**
    883            * @brief  Returns the clock source used as system clock.
    884            * @param  None
    885            * @retval The clock source used as system clock. The returned value can be one
    886            *         of the following:
    887            *              - 0x00: HSI used as system clock
    888            *              - 0x04: HSE used as system clock
    889            *              - 0x08: PLL used as system clock
    890            */

   \                                 In section .text, align 2, keep-with-next
    891          uint8_t RCC_GetSYSCLKSource(void)
    892          {
    893            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable50_1  ;; 0x40023808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   0000000A   0x4770             BX       LR               ;; return
    894          }
    895          
    896          /**
    897            * @brief  Configures the AHB clock (HCLK).
    898            * @note   Depending on the device voltage range, the software has to set correctly
    899            *         these bits to ensure that HCLK not exceed the maximum allowed frequency
    900            *         (for more details refer to section above
    901            *           "CPU, AHB and APB busses clocks configuration functions")
    902            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    903            *         the system clock (SYSCLK).
    904            *          This parameter can be one of the following values:
    905            *            @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    906            *            @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    907            *            @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    908            *            @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    909            *            @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    910            *            @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    911            *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    912            *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    913            *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    914            * @retval None
    915            */

   \                                 In section .text, align 2, keep-with-next
    916          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    917          {
    918            uint32_t tmpreg = 0;
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    919            
    920            /* Check the parameters */
    921            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    922          
    923            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
    924          
    925            /* Clear HPRE[3:0] bits */
    926            tmpreg &= ~RCC_CFGR_HPRE;
   \   0000000A   0xF031 0x01F0      BICS     R1,R1,#0xF0
    927          
    928            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    929            tmpreg |= RCC_SYSCLK;
   \   0000000E   0x4301             ORRS     R1,R0,R1
    930          
    931            /* Store the new value */
    932            RCC->CFGR = tmpreg;
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000014   0x6011             STR      R1,[R2, #+0]
    933          }
   \   00000016   0x4770             BX       LR               ;; return
    934          
    935          
    936          /**
    937            * @brief  Configures the Low Speed APB clock (PCLK1).
    938            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    939            *         the AHB clock (HCLK).
    940            *          This parameter can be one of the following values:
    941            *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK
    942            *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
    943            *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
    944            *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
    945            *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    946            * @retval None
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    949          {
    950            uint32_t tmpreg = 0;
   \                     RCC_PCLK1Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    951          
    952            /* Check the parameters */
    953            assert_param(IS_RCC_PCLK(RCC_HCLK));
    954          
    955            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
    956          
    957            /* Clear PPRE1[2:0] bits */
    958            tmpreg &= ~RCC_CFGR_PPRE1;
   \   0000000A   0xF431 0x51E0      BICS     R1,R1,#0x1C00
    959          
    960            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    961            tmpreg |= RCC_HCLK;
   \   0000000E   0x4301             ORRS     R1,R0,R1
    962          
    963            /* Store the new value */
    964            RCC->CFGR = tmpreg;
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000014   0x6011             STR      R1,[R2, #+0]
    965          }
   \   00000016   0x4770             BX       LR               ;; return
    966          
    967          /**
    968            * @brief  Configures the High Speed APB clock (PCLK2).
    969            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    970            *         the AHB clock (HCLK).
    971            *          This parameter can be one of the following values:
    972            *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK
    973            *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
    974            *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
    975            *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
    976            *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    977            * @retval None
    978            */

   \                                 In section .text, align 2, keep-with-next
    979          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    980          {
    981            uint32_t tmpreg = 0;
   \                     RCC_PCLK2Config: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
    982          
    983            /* Check the parameters */
    984            assert_param(IS_RCC_PCLK(RCC_HCLK));
    985          
    986            tmpreg = RCC->CFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
    987          
    988            /* Clear PPRE2[2:0] bits */
    989            tmpreg &= ~RCC_CFGR_PPRE2;
   \   0000000A   0xF431 0x4160      BICS     R1,R1,#0xE000
    990          
    991            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    992            tmpreg |= RCC_HCLK << 3;
   \   0000000E   0xEA51 0x01C0      ORRS     R1,R1,R0, LSL #+3
    993          
    994            /* Store the new value */
    995            RCC->CFGR = tmpreg;
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000016   0x6011             STR      R1,[R2, #+0]
    996          }
   \   00000018   0x4770             BX       LR               ;; return
    997          
    998          /**
    999            * @brief  Returns the frequencies of different on chip clocks; SYSCLK, HCLK, 
   1000            *         PCLK1 and PCLK2.       
   1001            * 
   1002            * @note   The system frequency computed by this function is not the real 
   1003            *         frequency in the chip. It is calculated based on the predefined 
   1004            *         constant and the selected clock source:
   1005            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1006            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
   1007            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
   1008            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1009            * @note     (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
   1010            *               16 MHz) but the real value may vary depending on the variations
   1011            *               in voltage and temperature.
   1012            * @note     (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
   1013            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
   1014            *                frequency of the crystal used. Otherwise, this function may
   1015            *                have wrong result.
   1016            *                
   1017            * @note   The result of this function could be not correct when using fractional
   1018            *         value for HSE crystal.
   1019            *   
   1020            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
   1021            *          the clocks frequencies.
   1022            *     
   1023            * @note   This function can be used by the user application to compute the 
   1024            *         baudrate for the communication peripherals or configure other parameters.
   1025            * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
   1026            *         must be called to update the structure's field. Otherwise, any
   1027            *         configuration based on this function will be incorrect.
   1028            *    
   1029            * @retval None
   1030            */

   \                                 In section .text, align 2, keep-with-next
   1031          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
   1032          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1033            uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2402             MOVS     R4,#+2
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x2602             MOVS     R6,#+2
   1034          
   1035            /* Get SYSCLK source -------------------------------------------------------*/
   1036            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable50_1  ;; 0x40023808
   \   00000012   0x683F             LDR      R7,[R7, #+0]
   \   00000014   0xF017 0x070C      ANDS     R7,R7,#0xC
   \   00000018   0x0039             MOVS     R1,R7
   1037          
   1038            switch (tmp)
   \   0000001A   0x000F             MOVS     R7,R1
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD004             BEQ.N    ??RCC_GetClocksFreq_0
   \   00000020   0x2F04             CMP      R7,#+4
   \   00000022   0xD006             BEQ.N    ??RCC_GetClocksFreq_1
   \   00000024   0x2F08             CMP      R7,#+8
   \   00000026   0xD008             BEQ.N    ??RCC_GetClocksFreq_2
   \   00000028   0xE03C             B.N      ??RCC_GetClocksFreq_3
   1039            {
   1040              case 0x00:  /* HSI used as system clock source */
   1041                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable50_19  ;; 0xf42400
   \   0000002E   0x6007             STR      R7,[R0, #+0]
   1042                break;
   \   00000030   0xE03B             B.N      ??RCC_GetClocksFreq_4
   1043              case 0x04:  /* HSE used as system clock  source */
   1044                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R7,??DataTable50_20  ;; 0x7a1200
   \   00000036   0x6007             STR      R7,[R0, #+0]
   1045                break;
   \   00000038   0xE037             B.N      ??RCC_GetClocksFreq_4
   1046              case 0x08:  /* PLL used as system clock  source */
   1047          
   1048                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
   1049                   SYSCLK = PLL_VCO / PLLP
   1050                   */    
   1051                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R7,??DataTable50_4  ;; 0x40023804
   \   0000003E   0x683F             LDR      R7,[R7, #+0]
   \   00000040   0xF3C7 0x5780      UBFX     R7,R7,#+22,#+1
   \   00000044   0x003D             MOVS     R5,R7
   1052                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000046   0x.... 0x....      LDR.W    R7,??DataTable50_4  ;; 0x40023804
   \   0000004A   0x683F             LDR      R7,[R7, #+0]
   \   0000004C   0xF017 0x073F      ANDS     R7,R7,#0x3F
   \   00000050   0x003E             MOVS     R6,R7
   1053                
   1054                if (pllsource != 0)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD00D             BEQ.N    ??RCC_GetClocksFreq_5
   1055                {
   1056                  /* HSE used as PLL clock source */
   1057                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   00000056   0x.... 0x....      LDR.W    R7,??DataTable50_20  ;; 0x7a1200
   \   0000005A   0xFBB7 0xF7F6      UDIV     R7,R7,R6
   \   0000005E   0x.... 0x....      LDR.W    R12,??DataTable50_4  ;; 0x40023804
   \   00000062   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000066   0xF3CC 0x1C88      UBFX     R12,R12,#+6,#+9
   \   0000006A   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000006E   0x003B             MOVS     R3,R7
   \   00000070   0xE00C             B.N      ??RCC_GetClocksFreq_6
   1058                }
   1059                else
   1060                {
   1061                  /* HSI used as PLL clock source */
   1062                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   00000072   0x.... 0x....      LDR.W    R7,??DataTable50_19  ;; 0xf42400
   \   00000076   0xFBB7 0xF7F6      UDIV     R7,R7,R6
   \   0000007A   0x.... 0x....      LDR.W    R12,??DataTable50_4  ;; 0x40023804
   \   0000007E   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000082   0xF3CC 0x1C88      UBFX     R12,R12,#+6,#+9
   \   00000086   0xFB0C 0xF707      MUL      R7,R12,R7
   \   0000008A   0x003B             MOVS     R3,R7
   1063                }
   1064          
   1065                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??RCC_GetClocksFreq_6: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R7,??DataTable50_4  ;; 0x40023804
   \   00000090   0x683F             LDR      R7,[R7, #+0]
   \   00000092   0xF3C7 0x4701      UBFX     R7,R7,#+16,#+2
   \   00000096   0x1C7F             ADDS     R7,R7,#+1
   \   00000098   0x007F             LSLS     R7,R7,#+1
   \   0000009A   0x003C             MOVS     R4,R7
   1066                RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
   \   0000009C   0xFBB3 0xF7F4      UDIV     R7,R3,R4
   \   000000A0   0x6007             STR      R7,[R0, #+0]
   1067                break;
   \   000000A2   0xE002             B.N      ??RCC_GetClocksFreq_4
   1068              default:
   1069                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R7,??DataTable50_19  ;; 0xf42400
   \   000000A8   0x6007             STR      R7,[R0, #+0]
   1070                break;
   1071            }
   1072            /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
   1073          
   1074            /* Get HCLK prescaler */
   1075            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R7,??DataTable50_1  ;; 0x40023808
   \   000000AE   0x683F             LDR      R7,[R7, #+0]
   \   000000B0   0xF017 0x07F0      ANDS     R7,R7,#0xF0
   \   000000B4   0x0039             MOVS     R1,R7
   1076            tmp = tmp >> 4;
   \   000000B6   0x0909             LSRS     R1,R1,#+4
   1077            presc = APBAHBPrescTable[tmp];
   \   000000B8   0x.... 0x....      LDR.W    R7,??DataTable50_21
   \   000000BC   0x5DCF             LDRB     R7,[R1, R7]
   \   000000BE   0x003A             MOVS     R2,R7
   1078            /* HCLK clock frequency */
   1079            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   000000C0   0x6807             LDR      R7,[R0, #+0]
   \   000000C2   0x46BC             MOV      R12,R7
   \   000000C4   0xFA3C 0xFC02      LSRS     R12,R12,R2
   \   000000C8   0xF8C0 0xC004      STR      R12,[R0, #+4]
   1080          
   1081            /* Get PCLK1 prescaler */
   1082            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   \   000000CC   0x.... 0x....      LDR.W    R7,??DataTable50_1  ;; 0x40023808
   \   000000D0   0x683F             LDR      R7,[R7, #+0]
   \   000000D2   0xF417 0x57E0      ANDS     R7,R7,#0x1C00
   \   000000D6   0x0039             MOVS     R1,R7
   1083            tmp = tmp >> 10;
   \   000000D8   0x0A89             LSRS     R1,R1,#+10
   1084            presc = APBAHBPrescTable[tmp];
   \   000000DA   0x.... 0x....      LDR.W    R7,??DataTable50_21
   \   000000DE   0x5DCF             LDRB     R7,[R1, R7]
   \   000000E0   0x003A             MOVS     R2,R7
   1085            /* PCLK1 clock frequency */
   1086            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   000000E2   0x6847             LDR      R7,[R0, #+4]
   \   000000E4   0x46BC             MOV      R12,R7
   \   000000E6   0xFA3C 0xFC02      LSRS     R12,R12,R2
   \   000000EA   0xF8C0 0xC008      STR      R12,[R0, #+8]
   1087          
   1088            /* Get PCLK2 prescaler */
   1089            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   \   000000EE   0x.... 0x....      LDR.W    R7,??DataTable50_1  ;; 0x40023808
   \   000000F2   0x683F             LDR      R7,[R7, #+0]
   \   000000F4   0xF417 0x4760      ANDS     R7,R7,#0xE000
   \   000000F8   0x0039             MOVS     R1,R7
   1090            tmp = tmp >> 13;
   \   000000FA   0x0B49             LSRS     R1,R1,#+13
   1091            presc = APBAHBPrescTable[tmp];
   \   000000FC   0x.... 0x....      LDR.W    R7,??DataTable50_21
   \   00000100   0x5DCF             LDRB     R7,[R1, R7]
   \   00000102   0x003A             MOVS     R2,R7
   1092            /* PCLK2 clock frequency */
   1093            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   00000104   0x6847             LDR      R7,[R0, #+4]
   \   00000106   0x46BC             MOV      R12,R7
   \   00000108   0xFA3C 0xFC02      LSRS     R12,R12,R2
   \   0000010C   0xF8C0 0xC00C      STR      R12,[R0, #+12]
   1094          }
   \   00000110   0xBCF0             POP      {R4-R7}
   \   00000112   0x4770             BX       LR               ;; return
   1095          
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
   1101           *  @brief   Peripheral clocks configuration functions 
   1102           *
   1103          @verbatim   
   1104           ===============================================================================
   1105                        ##### Peripheral clocks configuration functions #####
   1106           ===============================================================================  
   1107              [..] This section provide functions allowing to configure the Peripheral clocks. 
   1108            
   1109                (#) The RTC clock which is derived from the LSI, LSE or HSE clock divided 
   1110                    by 2 to 31.
   1111               
   1112                (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
   1113                    except internal SRAM, Flash and JTAG. Before to start using a peripheral 
   1114                    you have to enable its interface clock. You can do this using 
   1115                    RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
   1116          
   1117                (#) To reset the peripherals configuration (to the default state after device reset)
   1118                    you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
   1119                    RCC_APB1PeriphResetCmd() functions.
   1120               
   1121                (#) To further reduce power consumption in SLEEP mode the peripheral clocks 
   1122                    can be disabled prior to executing the WFI or WFE instructions. 
   1123                    You can do this using RCC_AHBPeriphClockLPModeCmd(), 
   1124                    RCC_APB2PeriphClockLPModeCmd() and RCC_APB1PeriphClockLPModeCmd() functions.  
   1125          
   1126          @endverbatim
   1127            * @{
   1128            */
   1129          
   1130          /**
   1131            * @brief  Configures the RTC clock (RTCCLK).
   1132            * @note   As the RTC clock configuration bits are in the Backup domain and write
   1133            *         access is denied to this domain after reset, you have to enable write
   1134            *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
   1135            *         the RTC clock source (to be done once after reset).    
   1136            * @note   Once the RTC clock is configured it can't be changed unless the  
   1137            *         Backup domain is reset using RCC_BackupResetCmd() function, or by
   1138            *         a Power On Reset (POR).
   1139            *    
   1140            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
   1141            *          This parameter can be one of the following values:
   1142            *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
   1143            *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
   1144            *            @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected
   1145            *                                            as RTC clock, where x:[2,31]
   1146            *  
   1147            * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
   1148            *         work in STOP and STANDBY modes, and can be used as wakeup source.
   1149            *         However, when the HSE clock is used as RTC clock source, the RTC
   1150            *         cannot be used in STOP and STANDBY modes.    
   1151            * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
   1152            *         RTC clock source).
   1153            *  
   1154            * @retval None
   1155            */

   \                                 In section .text, align 2, keep-with-next
   1156          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
   1157          {
   1158            uint32_t tmpreg = 0;
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1159          
   1160            /* Check the parameters */
   1161            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   1162          
   1163            if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   \   00000002   0xF410 0x7240      ANDS     R2,R0,#0x300
   \   00000006   0xF5B2 0x7F40      CMP      R2,#+768
   \   0000000A   0xD10C             BNE.N    ??RCC_RTCCLKConfig_0
   1164            { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
   1165              tmpreg = RCC->CFGR;
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x0011             MOVS     R1,R2
   1166          
   1167              /* Clear RTCPRE[4:0] bits */
   1168              tmpreg &= ~RCC_CFGR_RTCPRE;
   \   00000014   0xF431 0x11F8      BICS     R1,R1,#0x1F0000
   1169          
   1170              /* Configure HSE division factor for RTC clock */
   1171              tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable50_22  ;; 0xffffcff
   \   0000001C   0x4002             ANDS     R2,R2,R0
   \   0000001E   0x4311             ORRS     R1,R2,R1
   1172          
   1173              /* Store the new value */
   1174              RCC->CFGR = tmpreg;
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable50_1  ;; 0x40023808
   \   00000024   0x6011             STR      R1,[R2, #+0]
   1175            }
   1176              
   1177            /* Select the RTC clock source */
   1178            RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
   \                     ??RCC_RTCCLKConfig_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable50_13  ;; 0x40023870
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0x0503             LSLS     R3,R0,#+20       ;; ZeroExtS R3,R0,#+20,#+20
   \   0000002E   0x0D1B             LSRS     R3,R3,#+20
   \   00000030   0x431A             ORRS     R2,R3,R2
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable50_13  ;; 0x40023870
   \   00000036   0x601A             STR      R2,[R3, #+0]
   1179          }
   \   00000038   0x4770             BX       LR               ;; return
   1180          
   1181          /**
   1182            * @brief  Enables or disables the RTC clock.
   1183            * @note   This function must be used only after the RTC clock source was selected
   1184            *         using the RCC_RTCCLKConfig function.
   1185            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
   1186            * @retval None
   1187            */

   \                                 In section .text, align 2, keep-with-next
   1188          void RCC_RTCCLKCmd(FunctionalState NewState)
   1189          {
   1190            /* Check the parameters */
   1191            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1192          
   1193            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_23  ;; 0x42470e3c
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1194          }
   \   00000008   0x4770             BX       LR               ;; return
   1195          
   1196          /**
   1197            * @brief  Forces or releases the Backup domain reset.
   1198            * @note   This function resets the RTC peripheral (including the backup registers)
   1199            *         and the RTC clock source selection in RCC_CSR register.
   1200            * @note   The BKPSRAM is not affected by this reset.    
   1201            * @param  NewState: new state of the Backup domain reset.
   1202            *          This parameter can be: ENABLE or DISABLE.
   1203            * @retval None
   1204            */

   \                                 In section .text, align 2, keep-with-next
   1205          void RCC_BackupResetCmd(FunctionalState NewState)
   1206          {
   1207            /* Check the parameters */
   1208            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1209            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   \                     RCC_BackupResetCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable50_24  ;; 0x42470e40
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1210          }
   \   00000008   0x4770             BX       LR               ;; return
   1211          
   1212          /**
   1213            * @brief  Configures the I2S clock source (I2SCLK).
   1214            * @note   This function must be called before enabling the I2S APB clock.
   1215            * @param  RCC_I2SCLKSource: specifies the I2S clock source.
   1216            *          This parameter can be one of the following values:
   1217            *            @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
   1218            *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1219            *                                        used as I2S clock source
   1220            * @retval None
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
   1223          {
   1224            /* Check the parameters */
   1225            assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
   1226          
   1227            *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   \                     RCC_I2SCLKConfig: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable50_25  ;; 0x4247015c
   \   00000004   0x6008             STR      R0,[R1, #+0]
   1228          }
   \   00000006   0x4770             BX       LR               ;; return
   1229          
   1230          /**
   1231            * @brief  Configures the SAI clock Divider coming from PLLI2S.
   1232            * 
   1233            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1234            *   
   1235            * @note   This function must be called before enabling the PLLI2S.
   1236            *              
   1237            * @param  RCC_PLLI2SDivQ: specifies the PLLI2S division factor for SAI1 clock .
   1238            *          This parameter must be a number between 1 and 32.
   1239            *          SAI1 clock frequency = f(PLLI2S_Q) / RCC_PLLI2SDivQ 
   1240            *              
   1241            * @retval None
   1242            */

   \                                 In section .text, align 2, keep-with-next
   1243          void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
   1244          {
   1245            uint32_t tmpreg = 0;
   \                     RCC_SAIPLLI2SClkDivConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1246            
   1247            /* Check the parameters */
   1248            assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
   1249            
   1250            tmpreg = RCC->DCKCFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_10  ;; 0x4002388c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
   1251          
   1252            /* Clear PLLI2SDIVQ[4:0] bits */
   1253            tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
   \   0000000A   0x0949             LSRS     R1,R1,#+5
   \   0000000C   0x0149             LSLS     R1,R1,#+5
   1254          
   1255            /* Set PLLI2SDIVQ values */
   1256            tmpreg |= (RCC_PLLI2SDivQ - 1);
   \   0000000E   0x1E42             SUBS     R2,R0,#+1
   \   00000010   0x4311             ORRS     R1,R2,R1
   1257          
   1258            /* Store the new value */
   1259            RCC->DCKCFGR = tmpreg;
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable50_10  ;; 0x4002388c
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1260          }
   \   00000018   0x4770             BX       LR               ;; return
   1261          
   1262          /**
   1263            * @brief  Configures the SAI clock Divider coming from PLLSAI.
   1264            * 
   1265            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1266            *        
   1267            * @note   This function must be called before enabling the PLLSAI.
   1268            *   
   1269            * @param  RCC_PLLSAIDivQ: specifies the PLLSAI division factor for SAI1 clock .
   1270            *          This parameter must be a number between 1 and 32.
   1271            *          SAI1 clock frequency = f(PLLSAI_Q) / RCC_PLLSAIDivQ  
   1272            *              
   1273            * @retval None
   1274            */

   \                                 In section .text, align 2, keep-with-next
   1275          void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
   1276          {
   1277            uint32_t tmpreg = 0;
   \                     RCC_SAIPLLSAIClkDivConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1278            
   1279            /* Check the parameters */
   1280            assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
   1281            
   1282            tmpreg = RCC->DCKCFGR;
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable50_10  ;; 0x4002388c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0011             MOVS     R1,R2
   1283          
   1284            /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
   1285            tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
   \   0000000A   0xF431 0x51F8      BICS     R1,R1,#0x1F00
   1286          
   1287            /* Set PLLSAIDIVQ values */
   1288            tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
   \   0000000E   0x1E42             SUBS     R2,R0,#+1
   \   00000010   0xEA51 0x2102      ORRS     R1,R1,R2, LSL #+8
   1289          
   1290            /* Store the new value */
   1291            RCC->DCKCFGR = tmpreg;
   \   00000014   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1292          }
   \   00000018   0x4770             BX       LR               ;; return
   1293          
   1294          /**
   1295            * @brief  Configures SAI1BlockA clock source selection.
   1296            * 
   1297            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1298            *       
   1299            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1300            *         the SAI clock.
   1301            * @param  RCC_SAIBlockACLKSource: specifies the SAI Block A clock source.
   1302            *          This parameter can be one of the following values:
   1303            *            @arg RCC_SAIACLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1304            *                                           as SAI1 Block A clock 
   1305            *            @arg RCC_SAIACLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1306            *                                           as SAI1 Block A clock 
   1307            *            @arg RCC_SAIACLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1308            *                                        used as SAI1 Block A clock
   1309            * @retval None
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311          void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
   1312          {
   1313            uint32_t tmpreg = 0;
   \                     RCC_SAIBlockACLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1314            
   1315            /* Check the parameters */
   1316            assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
   1317            
   1318            tmpreg = RCC->DCKCFGR;
   \   00000002   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x0011             MOVS     R1,R2
   1319          
   1320            /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
   1321            tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
   \   00000008   0xF431 0x1140      BICS     R1,R1,#0x300000
   1322          
   1323            /* Set SAI Block A source selection value */
   1324            tmpreg |= RCC_SAIBlockACLKSource;
   \   0000000C   0x4301             ORRS     R1,R0,R1
   1325          
   1326            /* Store the new value */
   1327            RCC->DCKCFGR = tmpreg;
   \   0000000E   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000010   0x6011             STR      R1,[R2, #+0]
   1328          }
   \   00000012   0x4770             BX       LR               ;; return
   1329          
   1330          /**
   1331            * @brief  Configures SAI1BlockB clock source selection.
   1332            * 
   1333            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1334            *       
   1335            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1336            *         the SAI clock.
   1337            * @param  RCC_SAIBlockBCLKSource: specifies the SAI Block B clock source.
   1338            *          This parameter can be one of the following values:
   1339            *            @arg RCC_SAIBCLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1340            *                                           as SAI1 Block B clock 
   1341            *            @arg RCC_SAIBCLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1342            *                                           as SAI1 Block B clock 
   1343            *            @arg RCC_SAIBCLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1344            *                                        used as SAI1 Block B clock
   1345            * @retval None
   1346            */

   \                                 In section .text, align 2, keep-with-next
   1347          void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
   1348          {
   1349            uint32_t tmpreg = 0;
   \                     RCC_SAIBlockBCLKConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1350            
   1351            /* Check the parameters */
   1352            assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
   1353            
   1354            tmpreg = RCC->DCKCFGR;
   \   00000002   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x0011             MOVS     R1,R2
   1355          
   1356            /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
   1357            tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
   \   00000008   0xF431 0x0140      BICS     R1,R1,#0xC00000
   1358          
   1359            /* Set SAI Block B source selection value */
   1360            tmpreg |= RCC_SAIBlockBCLKSource;
   \   0000000C   0x4301             ORRS     R1,R0,R1
   1361          
   1362            /* Store the new value */
   1363            RCC->DCKCFGR = tmpreg;
   \   0000000E   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000010   0x6011             STR      R1,[R2, #+0]
   1364          }
   \   00000012   0x4770             BX       LR               ;; return
   1365          
   1366          
   1367          /**
   1368            * @brief  Configures the LTDC clock Divider coming from PLLSAI.
   1369            * 
   1370            * @note   The LTDC peripheral is only available with STM32F429xx/439xx Devices.
   1371            *      
   1372            * @note   This function must be called before enabling the PLLSAI.
   1373            *   
   1374            * @param  RCC_PLLSAIDivR: specifies the PLLSAI division factor for LTDC clock .
   1375            *          This parameter must be a number between 2 and 16.
   1376            *          LTDC clock frequency = f(PLLSAI_R) / RCC_PLLSAIDivR  
   1377            *            
   1378            * @retval None
   1379            */

   \                                 In section .text, align 2, keep-with-next
   1380          void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
   1381          {
   1382            uint32_t tmpreg = 0;
   \                     RCC_LTDCCLKDivConfig: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   1383            
   1384            /* Check the parameters */
   1385            assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
   1386            
   1387            tmpreg = RCC->DCKCFGR;
   \   00000002   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x0011             MOVS     R1,R2
   1388          
   1389            /* Clear PLLSAIDIVR[2:0] bits */
   1390            tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
   \   00000008   0xF431 0x3140      BICS     R1,R1,#0x30000
   1391          
   1392            /* Set PLLSAIDIVR values */
   1393            tmpreg |= RCC_PLLSAIDivR;
   \   0000000C   0x4301             ORRS     R1,R0,R1
   1394          
   1395            /* Store the new value */
   1396            RCC->DCKCFGR = tmpreg;
   \   0000000E   0x....             LDR.N    R2,??DataTable50_10  ;; 0x4002388c
   \   00000010   0x6011             STR      R1,[R2, #+0]
   1397          }
   \   00000012   0x4770             BX       LR               ;; return
   1398          
   1399          /**
   1400            * @brief  Configures the Timers clocks prescalers selection.
   1401            * 
   1402            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx devices. 
   1403            *   
   1404            * @param  RCC_TIMCLKPrescaler : specifies the Timers clocks prescalers selection
   1405            *         This parameter can be one of the following values:
   1406            *            @arg RCC_TIMPrescDesactivated: The Timers kernels clocks prescaler is 
   1407            *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
   1408            *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
   1409            *                 division by 4 or more.
   1410            *                   
   1411            *            @arg RCC_TIMPrescActivated: The Timers kernels clocks prescaler is 
   1412            *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
   1413            *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
   1414            *                 to division by 8 or more.
   1415            * @retval None
   1416            */

   \                                 In section .text, align 2, keep-with-next
   1417          void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
   1418          {
   1419            /* Check the parameters */
   1420            assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
   1421          
   1422            *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
   \                     RCC_TIMCLKPresConfig: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable50_26  ;; 0x424711e0
   \   00000002   0x6008             STR      R0,[R1, #+0]
   1423            
   1424          }
   \   00000004   0x4770             BX       LR               ;; return
   1425          
   1426          /**
   1427            * @brief  Enables or disables the AHB1 peripheral clock.
   1428            * @note   After reset, the peripheral clock (used for registers read/write access)
   1429            *         is disabled and the application software has to enable this clock before 
   1430            *         using it.   
   1431            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1432            *          This parameter can be any combination of the following values:
   1433            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1434            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1435            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1436            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1437            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1438            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1439            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1440            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1441            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1442            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1443            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
   1444            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1445            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1446            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
   1447            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1448            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1449            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
   1450            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1451            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1452            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1453            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1454            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1455            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1456            * @param  NewState: new state of the specified peripheral clock.
   1457            *          This parameter can be: ENABLE or DISABLE.
   1458            * @retval None
   1459            */

   \                                 In section .text, align 2, keep-with-next
   1460          void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1461          {
   1462            /* Check the parameters */
   1463            assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
   1464          
   1465            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1466            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB1PeriphClockCmd_0
   1467            {
   1468              RCC->AHB1ENR |= RCC_AHB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_27  ;; 0x40023830
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_27  ;; 0x40023830
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB1PeriphClockCmd_1
   1469            }
   1470            else
   1471            {
   1472              RCC->AHB1ENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_27  ;; 0x40023830
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_27  ;; 0x40023830
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1473            }
   1474          }
   \                     ??RCC_AHB1PeriphClockCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1475          
   1476          /**
   1477            * @brief  Enables or disables the AHB2 peripheral clock.
   1478            * @note   After reset, the peripheral clock (used for registers read/write access)
   1479            *         is disabled and the application software has to enable this clock before 
   1480            *         using it. 
   1481            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1482            *          This parameter can be any combination of the following values:
   1483            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1484            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1485            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1486            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1487            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1488            * @param  NewState: new state of the specified peripheral clock.
   1489            *          This parameter can be: ENABLE or DISABLE.
   1490            * @retval None
   1491            */

   \                                 In section .text, align 2, keep-with-next
   1492          void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1493          {
   1494            /* Check the parameters */
   1495            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1496            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1497          
   1498            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB2PeriphClockCmd_0
   1499            {
   1500              RCC->AHB2ENR |= RCC_AHB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_28  ;; 0x40023834
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_28  ;; 0x40023834
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB2PeriphClockCmd_1
   1501            }
   1502            else
   1503            {
   1504              RCC->AHB2ENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_28  ;; 0x40023834
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_28  ;; 0x40023834
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1505            }
   1506          }
   \                     ??RCC_AHB2PeriphClockCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1507          
   1508          /**
   1509            * @brief  Enables or disables the AHB3 peripheral clock.
   1510            * @note   After reset, the peripheral clock (used for registers read/write access)
   1511            *         is disabled and the application software has to enable this clock before 
   1512            *         using it. 
   1513            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1514            *          This parameter must be: RCC_AHB3Periph_FSMC
   1515            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1516            * @param  NewState: new state of the specified peripheral clock.
   1517            *          This parameter can be: ENABLE or DISABLE.
   1518            * @retval None
   1519            */

   \                                 In section .text, align 2, keep-with-next
   1520          void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1521          {
   1522            /* Check the parameters */
   1523            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
   1524            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1525          
   1526            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB3PeriphClockCmd_0
   1527            {
   1528              RCC->AHB3ENR |= RCC_AHB3Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_29  ;; 0x40023838
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_29  ;; 0x40023838
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB3PeriphClockCmd_1
   1529            }
   1530            else
   1531            {
   1532              RCC->AHB3ENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_29  ;; 0x40023838
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_29  ;; 0x40023838
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1533            }
   1534          }
   \                     ??RCC_AHB3PeriphClockCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1535          
   1536          /**
   1537            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1538            * @note   After reset, the peripheral clock (used for registers read/write access)
   1539            *         is disabled and the application software has to enable this clock before 
   1540            *         using it. 
   1541            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1542            *          This parameter can be any combination of the following values:
   1543            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1544            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1545            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1546            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1547            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1548            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1549            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1550            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1551            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1552            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1553            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1554            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1555            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1556            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1557            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1558            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1559            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1560            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1561            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1562            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1563            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1564            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1565            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1566            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1567            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1568            * @param  NewState: new state of the specified peripheral clock.
   1569            *          This parameter can be: ENABLE or DISABLE.
   1570            * @retval None
   1571            */

   \                                 In section .text, align 2, keep-with-next
   1572          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1573          {
   1574            /* Check the parameters */
   1575            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
   1576            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1577          
   1578            if (NewState != DISABLE)
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB1PeriphClockCmd_0
   1579            {
   1580              RCC->APB1ENR |= RCC_APB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_30  ;; 0x40023840
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_30  ;; 0x40023840
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB1PeriphClockCmd_1
   1581            }
   1582            else
   1583            {
   1584              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_30  ;; 0x40023840
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_30  ;; 0x40023840
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1585            }
   1586          }
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1587          
   1588          /**
   1589            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1590            * @note   After reset, the peripheral clock (used for registers read/write access)
   1591            *         is disabled and the application software has to enable this clock before 
   1592            *         using it.
   1593            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1594            *          This parameter can be any combination of the following values:
   1595            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1596            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1597            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1598            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1599            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1600            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1601            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1602            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1603            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1604            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   1605            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1606            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1607            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1608            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1609            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1610            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1611            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1612            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices) 
   1613            * @param  NewState: new state of the specified peripheral clock.
   1614            *          This parameter can be: ENABLE or DISABLE.
   1615            * @retval None
   1616            */

   \                                 In section .text, align 2, keep-with-next
   1617          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1618          {
   1619            /* Check the parameters */
   1620            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1621            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1622          
   1623            if (NewState != DISABLE)
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB2PeriphClockCmd_0
   1624            {
   1625              RCC->APB2ENR |= RCC_APB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_31  ;; 0x40023844
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_31  ;; 0x40023844
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB2PeriphClockCmd_1
   1626            }
   1627            else
   1628            {
   1629              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_31  ;; 0x40023844
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_31  ;; 0x40023844
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1630            }
   1631          }
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1632          
   1633          /**
   1634            * @brief  Forces or releases AHB1 peripheral reset.
   1635            * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
   1636            *          This parameter can be any combination of the following values:
   1637            *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
   1638            *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
   1639            *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
   1640            *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
   1641            *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
   1642            *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
   1643            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1644            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1645            *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
   1646            *            @arg RCC_AHB1Periph_GPIOJ:   GPIOJ clock (STM32F42xxx/43xxx devices) 
   1647            *            @arg RCC_AHB1Periph_GPIOK:   GPIOK clock (STM32F42xxx/43xxxdevices)   
   1648            *            @arg RCC_AHB1Periph_CRC:     CRC clock
   1649            *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
   1650            *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
   1651            *            @arg RCC_AHB1Periph_DMA2D:   DMA2D clock (STM32F429xx/439xx devices)   
   1652            *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
   1653            *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
   1654            *                  
   1655            * @param  NewState: new state of the specified peripheral reset.
   1656            *          This parameter can be: ENABLE or DISABLE.
   1657            * @retval None
   1658            */

   \                                 In section .text, align 2, keep-with-next
   1659          void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1660          {
   1661            /* Check the parameters */
   1662            assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
   1663            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1664          
   1665            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB1PeriphResetCmd_0
   1666            {
   1667              RCC->AHB1RSTR |= RCC_AHB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_32  ;; 0x40023810
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_32  ;; 0x40023810
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB1PeriphResetCmd_1
   1668            }
   1669            else
   1670            {
   1671              RCC->AHB1RSTR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_32  ;; 0x40023810
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_32  ;; 0x40023810
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1672            }
   1673          }
   \                     ??RCC_AHB1PeriphResetCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1674          
   1675          /**
   1676            * @brief  Forces or releases AHB2 peripheral reset.
   1677            * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
   1678            *          This parameter can be any combination of the following values:
   1679            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1680            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1681            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1682            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1683            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1684            * @param  NewState: new state of the specified peripheral reset.
   1685            *          This parameter can be: ENABLE or DISABLE.
   1686            * @retval None
   1687            */

   \                                 In section .text, align 2, keep-with-next
   1688          void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1689          {
   1690            /* Check the parameters */
   1691            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1692            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1693          
   1694            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB2PeriphResetCmd_0
   1695            {
   1696              RCC->AHB2RSTR |= RCC_AHB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_33  ;; 0x40023814
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_33  ;; 0x40023814
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB2PeriphResetCmd_1
   1697            }
   1698            else
   1699            {
   1700              RCC->AHB2RSTR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_33  ;; 0x40023814
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_33  ;; 0x40023814
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1701            }
   1702          }
   \                     ??RCC_AHB2PeriphResetCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1703          
   1704          /**
   1705            * @brief  Forces or releases AHB3 peripheral reset.
   1706            * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
   1707            *          This parameter must be: RCC_AHB3Periph_FSMC
   1708            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1709            * @param  NewState: new state of the specified peripheral reset.
   1710            *          This parameter can be: ENABLE or DISABLE.
   1711            * @retval None
   1712            */

   \                                 In section .text, align 2, keep-with-next
   1713          void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1714          {
   1715            /* Check the parameters */
   1716            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   1717            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1718          
   1719            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB3PeriphResetCmd_0
   1720            {
   1721              RCC->AHB3RSTR |= RCC_AHB3Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_34  ;; 0x40023818
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_34  ;; 0x40023818
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB3PeriphResetCmd_1
   1722            }
   1723            else
   1724            {
   1725              RCC->AHB3RSTR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_34  ;; 0x40023818
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_34  ;; 0x40023818
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1726            }
   1727          }
   \                     ??RCC_AHB3PeriphResetCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1728          
   1729          /**
   1730            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1731            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1732            *          This parameter can be any combination of the following values:
   1733            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1734            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1735            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1736            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1737            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1738            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1739            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1740            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1741            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1742            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1743            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1744            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1745            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1746            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1747            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1748            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1749            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1750            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1751            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1752            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1753            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1754            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1755            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1756            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1757            *            @arg RCC_APB1Periph_UART8:  UART8 clock  
   1758            * @param  NewState: new state of the specified peripheral reset.
   1759            *          This parameter can be: ENABLE or DISABLE.
   1760            * @retval None
   1761            */

   \                                 In section .text, align 2, keep-with-next
   1762          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1763          {
   1764            /* Check the parameters */
   1765            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1766            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1767            if (NewState != DISABLE)
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB1PeriphResetCmd_0
   1768            {
   1769              RCC->APB1RSTR |= RCC_APB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_35  ;; 0x40023820
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_35  ;; 0x40023820
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB1PeriphResetCmd_1
   1770            }
   1771            else
   1772            {
   1773              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_35  ;; 0x40023820
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_35  ;; 0x40023820
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1774            }
   1775          }
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1776          
   1777          /**
   1778            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1779            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1780            *          This parameter can be any combination of the following values:
   1781            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1782            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1783            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1784            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1785            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1786            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1787            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1788            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1789            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1790            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock  
   1791            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1792            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1793            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1794            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1795            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1796            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1797            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1798            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   1799            * @param  NewState: new state of the specified peripheral reset.
   1800            *          This parameter can be: ENABLE or DISABLE.
   1801            * @retval None
   1802            */

   \                                 In section .text, align 2, keep-with-next
   1803          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1804          {
   1805            /* Check the parameters */
   1806            assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
   1807            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1808            if (NewState != DISABLE)
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB2PeriphResetCmd_0
   1809            {
   1810              RCC->APB2RSTR |= RCC_APB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_36  ;; 0x40023824
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_36  ;; 0x40023824
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB2PeriphResetCmd_1
   1811            }
   1812            else
   1813            {
   1814              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_36  ;; 0x40023824
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_36  ;; 0x40023824
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1815            }
   1816          }
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1817          
   1818          /**
   1819            * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
   1820            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1821            *         power consumption.
   1822            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1823            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1824            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1825            *          This parameter can be any combination of the following values:
   1826            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1827            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1828            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1829            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1830            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1831            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1832            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1833            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1834            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1835            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1836            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)   
   1837            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1838            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1839            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1840            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1841            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices) 
   1842            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1843            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1844            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1845            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1846            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1847            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1848            * @param  NewState: new state of the specified peripheral clock.
   1849            *          This parameter can be: ENABLE or DISABLE.
   1850            * @retval None
   1851            */

   \                                 In section .text, align 2, keep-with-next
   1852          void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1853          {
   1854            /* Check the parameters */
   1855            assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
   1856            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1857            if (NewState != DISABLE)
   \                     RCC_AHB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_0
   1858            {
   1859              RCC->AHB1LPENR |= RCC_AHB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_37  ;; 0x40023850
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_37  ;; 0x40023850
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB1PeriphClockLPModeCmd_1
   1860            }
   1861            else
   1862            {
   1863              RCC->AHB1LPENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockLPModeCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_37  ;; 0x40023850
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_37  ;; 0x40023850
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1864            }
   1865          }
   \                     ??RCC_AHB1PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1866          
   1867          /**
   1868            * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
   1869            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1870            *           power consumption.
   1871            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1872            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1873            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1874            *          This parameter can be any combination of the following values:
   1875            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1876            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1877            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1878            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1879            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
   1880            * @param  NewState: new state of the specified peripheral clock.
   1881            *          This parameter can be: ENABLE or DISABLE.
   1882            * @retval None
   1883            */

   \                                 In section .text, align 2, keep-with-next
   1884          void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1885          {
   1886            /* Check the parameters */
   1887            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   1888            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1889            if (NewState != DISABLE)
   \                     RCC_AHB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_0
   1890            {
   1891              RCC->AHB2LPENR |= RCC_AHB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_38  ;; 0x40023854
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_38  ;; 0x40023854
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB2PeriphClockLPModeCmd_1
   1892            }
   1893            else
   1894            {
   1895              RCC->AHB2LPENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockLPModeCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_38  ;; 0x40023854
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_38  ;; 0x40023854
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1896            }
   1897          }
   \                     ??RCC_AHB2PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1898          
   1899          /**
   1900            * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
   1901            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1902            *         power consumption.
   1903            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1904            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1905            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1906            *          This parameter must be: RCC_AHB3Periph_FSMC
   1907            *                                  or RCC_AHB3Periph_FMC (STM32F429x/439x devices) 
   1908            * @param  NewState: new state of the specified peripheral clock.
   1909            *          This parameter can be: ENABLE or DISABLE.
   1910            * @retval None
   1911            */

   \                                 In section .text, align 2, keep-with-next
   1912          void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1913          {
   1914            /* Check the parameters */
   1915            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   1916            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1917            if (NewState != DISABLE)
   \                     RCC_AHB3PeriphClockLPModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_0
   1918            {
   1919              RCC->AHB3LPENR |= RCC_AHB3Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_39  ;; 0x40023858
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_39  ;; 0x40023858
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_AHB3PeriphClockLPModeCmd_1
   1920            }
   1921            else
   1922            {
   1923              RCC->AHB3LPENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockLPModeCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_39  ;; 0x40023858
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_39  ;; 0x40023858
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1924            }
   1925          }
   \                     ??RCC_AHB3PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1926          
   1927          /**
   1928            * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
   1929            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1930            *         power consumption.
   1931            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1932            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1933            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1934            *          This parameter can be any combination of the following values:
   1935            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1936            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1937            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1938            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1939            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1940            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1941            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1942            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1943            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1944            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1945            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1946            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1947            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1948            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1949            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1950            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1951            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1952            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1953            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1954            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1955            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1956            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1957            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1958            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1959            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1960            * @param  NewState: new state of the specified peripheral clock.
   1961            *          This parameter can be: ENABLE or DISABLE.
   1962            * @retval None
   1963            */

   \                                 In section .text, align 2, keep-with-next
   1964          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1965          {
   1966            /* Check the parameters */
   1967            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1968            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1969            if (NewState != DISABLE)
   \                     RCC_APB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_0
   1970            {
   1971              RCC->APB1LPENR |= RCC_APB1Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_40  ;; 0x40023860
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_40  ;; 0x40023860
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB1PeriphClockLPModeCmd_1
   1972            }
   1973            else
   1974            {
   1975              RCC->APB1LPENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockLPModeCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_40  ;; 0x40023860
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_40  ;; 0x40023860
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   1976            }
   1977          }
   \                     ??RCC_APB1PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   1978          
   1979          /**
   1980            * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
   1981            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1982            *         power consumption.
   1983            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1984            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1985            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1986            *          This parameter can be any combination of the following values:
   1987            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1988            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1989            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1990            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1991            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1992            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1993            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1994            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1995            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1996            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   1997            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1998            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1999            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   2000            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   2001            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   2002            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   2003            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   2004            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   2005            * @param  NewState: new state of the specified peripheral clock.
   2006            *          This parameter can be: ENABLE or DISABLE.
   2007            * @retval None
   2008            */

   \                                 In section .text, align 2, keep-with-next
   2009          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   2010          {
   2011            /* Check the parameters */
   2012            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   2013            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2014            if (NewState != DISABLE)
   \                     RCC_APB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_0
   2015            {
   2016              RCC->APB2LPENR |= RCC_APB2Periph;
   \   00000006   0x....             LDR.N    R2,??DataTable50_41  ;; 0x40023864
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_41  ;; 0x40023864
   \   0000000E   0x601A             STR      R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_APB2PeriphClockLPModeCmd_1
   2017            }
   2018            else
   2019            {
   2020              RCC->APB2LPENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockLPModeCmd_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_41  ;; 0x40023864
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_41  ;; 0x40023864
   \   0000001A   0x601A             STR      R2,[R3, #+0]
   2021            }
   2022          }
   \                     ??RCC_APB2PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   2023          
   2024          /**
   2025            * @}
   2026            */
   2027          
   2028          /** @defgroup RCC_Group4 Interrupts and flags management functions
   2029           *  @brief   Interrupts and flags management functions 
   2030           *
   2031          @verbatim   
   2032           ===============================================================================
   2033                          ##### Interrupts and flags management functions #####
   2034           ===============================================================================  
   2035          
   2036          @endverbatim
   2037            * @{
   2038            */
   2039          
   2040          /**
   2041            * @brief  Enables or disables the specified RCC interrupts.
   2042            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   2043            *          This parameter can be any combination of the following values:
   2044            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2045            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2046            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2047            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2048            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2049            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt
   2050            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)
   2051            * @param  NewState: new state of the specified RCC interrupts.
   2052            *          This parameter can be: ENABLE or DISABLE.
   2053            * @retval None
   2054            */

   \                                 In section .text, align 2, keep-with-next
   2055          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   2056          {
   2057            /* Check the parameters */
   2058            assert_param(IS_RCC_IT(RCC_IT));
   2059            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2060            if (NewState != DISABLE)
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD005             BEQ.N    ??RCC_ITConfig_0
   2061            {
   2062              /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
   2063              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000006   0x....             LDR.N    R2,??DataTable50_42  ;; 0x4002380d
   \   00000008   0x7812             LDRB     R2,[R2, #+0]
   \   0000000A   0x4302             ORRS     R2,R0,R2
   \   0000000C   0x....             LDR.N    R3,??DataTable50_42  ;; 0x4002380d
   \   0000000E   0x701A             STRB     R2,[R3, #+0]
   \   00000010   0xE004             B.N      ??RCC_ITConfig_1
   2064            }
   2065            else
   2066            {
   2067              /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
   2068              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_0: (+1)
   \   00000012   0x....             LDR.N    R2,??DataTable50_42  ;; 0x4002380d
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x4382             BICS     R2,R2,R0
   \   00000018   0x....             LDR.N    R3,??DataTable50_42  ;; 0x4002380d
   \   0000001A   0x701A             STRB     R2,[R3, #+0]
   2069            }
   2070          }
   \                     ??RCC_ITConfig_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
   2071          
   2072          /**
   2073            * @brief  Checks whether the specified RCC flag is set or not.
   2074            * @param  RCC_FLAG: specifies the flag to check.
   2075            *          This parameter can be one of the following values:
   2076            *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   2077            *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   2078            *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
   2079            *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
   2080            *            @arg RCC_FLAG_PLLSAIRDY: PLLSAI clock ready (only for STM32F42xxx/43xxx devices)
   2081            *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   2082            *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   2083            *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
   2084            *            @arg RCC_FLAG_PINRST: Pin reset
   2085            *            @arg RCC_FLAG_PORRST: POR/PDR reset
   2086            *            @arg RCC_FLAG_SFTRST: Software reset
   2087            *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   2088            *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   2089            *            @arg RCC_FLAG_LPWRRST: Low Power reset
   2090            * @retval The new state of RCC_FLAG (SET or RESET).
   2091            */

   \                                 In section .text, align 2, keep-with-next
   2092          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   2093          {
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   2094            uint32_t tmp = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   2095            uint32_t statusreg = 0;
   \   00000006   0x2300             MOVS     R3,#+0
   2096            FlagStatus bitstatus = RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   2097          
   2098            /* Check the parameters */
   2099            assert_param(IS_RCC_FLAG(RCC_FLAG));
   2100          
   2101            /* Get the RCC register index */
   2102            tmp = RCC_FLAG >> 5;
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x094C             LSRS     R4,R1,#+5
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x0022             MOVS     R2,R4
   2103            if (tmp == 1)               /* The flag to check is in CR register */
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD103             BNE.N    ??RCC_GetFlagStatus_0
   2104            {
   2105              statusreg = RCC->CR;
   \   00000016   0x....             LDR.N    R4,??DataTable50  ;; 0x40023800
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0x0023             MOVS     R3,R4
   \   0000001C   0xE008             B.N      ??RCC_GetFlagStatus_1
   2106            }
   2107            else if (tmp == 2)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   0000001E   0x2A02             CMP      R2,#+2
   \   00000020   0xD103             BNE.N    ??RCC_GetFlagStatus_2
   2108            {
   2109              statusreg = RCC->BDCR;
   \   00000022   0x....             LDR.N    R4,??DataTable50_13  ;; 0x40023870
   \   00000024   0x6824             LDR      R4,[R4, #+0]
   \   00000026   0x0023             MOVS     R3,R4
   \   00000028   0xE002             B.N      ??RCC_GetFlagStatus_1
   2110            }
   2111            else                       /* The flag to check is in CSR register */
   2112            {
   2113              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   0000002A   0x....             LDR.N    R4,??DataTable50_43  ;; 0x40023874
   \   0000002C   0x6824             LDR      R4,[R4, #+0]
   \   0000002E   0x0023             MOVS     R3,R4
   2114            }
   2115          
   2116            /* Get the flag position */
   2117            tmp = RCC_FLAG & FLAG_MASK;
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0xF011 0x041F      ANDS     R4,R1,#0x1F
   \   00000036   0x0022             MOVS     R2,R4
   2118            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   \   00000038   0x001C             MOVS     R4,R3
   \   0000003A   0x40D4             LSRS     R4,R4,R2
   \   0000003C   0x07E4             LSLS     R4,R4,#+31
   \   0000003E   0xD502             BPL.N    ??RCC_GetFlagStatus_3
   2119            {
   2120              bitstatus = SET;
   \   00000040   0x2401             MOVS     R4,#+1
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xE001             B.N      ??RCC_GetFlagStatus_4
   2121            }
   2122            else
   2123            {
   2124              bitstatus = RESET;
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   00000046   0x2400             MOVS     R4,#+0
   \   00000048   0x0020             MOVS     R0,R4
   2125            }
   2126            /* Return the flag status */
   2127            return bitstatus;
   \                     ??RCC_GetFlagStatus_4: (+1)
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return
   2128          }
   2129          
   2130          /**
   2131            * @brief  Clears the RCC reset flags.
   2132            *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
   2133            *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   2134            * @param  None
   2135            * @retval None
   2136            */

   \                                 In section .text, align 2, keep-with-next
   2137          void RCC_ClearFlag(void)
   2138          {
   2139            /* Set RMVF bit to clear the reset flags */
   2140            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable50_43  ;; 0x40023874
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000008   0x....             LDR.N    R1,??DataTable50_43  ;; 0x40023874
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   2141          }
   \   0000000C   0x4770             BX       LR               ;; return
   2142          
   2143          /**
   2144            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   2145            * @param  RCC_IT: specifies the RCC interrupt source to check.
   2146            *          This parameter can be one of the following values:
   2147            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2148            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2149            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2150            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2151            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2152            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt           
   2153            *            @arg RCC_IT_PLLSAIRDY: PLLSAI clock ready interrupt (only for STM32F42xxx/43xxx devices)    
   2154            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2155            * @retval The new state of RCC_IT (SET or RESET).
   2156            */

   \                                 In section .text, align 2, keep-with-next
   2157          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   2158          {
   \                     RCC_GetITStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   2159            ITStatus bitstatus = RESET;
   \   00000002   0x2000             MOVS     R0,#+0
   2160          
   2161            /* Check the parameters */
   2162            assert_param(IS_RCC_GET_IT(RCC_IT));
   2163          
   2164            /* Check the status of the specified RCC interrupt */
   2165            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \   00000004   0x....             LDR.N    R2,??DataTable50_9  ;; 0x4002380c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x420A             TST      R2,R1
   \   0000000C   0xD002             BEQ.N    ??RCC_GetITStatus_0
   2166            {
   2167              bitstatus = SET;
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xE001             B.N      ??RCC_GetITStatus_1
   2168            }
   2169            else
   2170            {
   2171              bitstatus = RESET;
   \                     ??RCC_GetITStatus_0: (+1)
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x0010             MOVS     R0,R2
   2172            }
   2173            /* Return the RCC_IT status */
   2174            return  bitstatus;
   \                     ??RCC_GetITStatus_1: (+1)
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4770             BX       LR               ;; return
   2175          }
   2176          
   2177          /**
   2178            * @brief  Clears the RCC's interrupt pending bits.
   2179            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   2180            *          This parameter can be any combination of the following values:
   2181            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2182            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2183            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2184            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2185            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2186            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   2187            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)   
   2188            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2189            * @retval None
   2190            */

   \                                 In section .text, align 2, keep-with-next
   2191          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   2192          {
   2193            /* Check the parameters */
   2194            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   2195          
   2196            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   2197               pending bits */
   2198            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable50_44  ;; 0x4002380e
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   2199          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_2:
   \   00000000   0xEAF6FFFF         DC32     0xeaf6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_3:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_4:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_5:
   \   00000000   0x20003000         DC32     0x20003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_6:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_7:
   \   00000000   0x24003000         DC32     0x24003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_8:
   \   00000000   0x40023888         DC32     0x40023888

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_9:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_10:
   \   00000000   0x4002388C         DC32     0x4002388c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_11:
   \   00000000   0x40023802         DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_12:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_13:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_14:
   \   00000000   0x42470E80         DC32     0x42470e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_15:
   \   00000000   0x42470060         DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_16:
   \   00000000   0x42470068         DC32     0x42470068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_17:
   \   00000000   0x42470070         DC32     0x42470070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_18:
   \   00000000   0x4247004C         DC32     0x4247004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_19:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_20:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_21:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_22:
   \   00000000   0x0FFFFCFF         DC32     0xffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_23:
   \   00000000   0x42470E3C         DC32     0x42470e3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_24:
   \   00000000   0x42470E40         DC32     0x42470e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_25:
   \   00000000   0x4247015C         DC32     0x4247015c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_26:
   \   00000000   0x424711E0         DC32     0x424711e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_27:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_28:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_29:
   \   00000000   0x40023838         DC32     0x40023838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_30:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_31:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_32:
   \   00000000   0x40023810         DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_33:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_34:
   \   00000000   0x40023818         DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_35:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_36:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_37:
   \   00000000   0x40023850         DC32     0x40023850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_38:
   \   00000000   0x40023854         DC32     0x40023854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_39:
   \   00000000   0x40023858         DC32     0x40023858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_40:
   \   00000000   0x40023860         DC32     0x40023860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_41:
   \   00000000   0x40023864         DC32     0x40023864

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_42:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_43:
   \   00000000   0x40023874         DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_44:
   \   00000000   0x4002380E         DC32     0x4002380e
   2200          
   2201          /**
   2202            * @}
   2203            */ 
   2204          
   2205          /**
   2206            * @}
   2207            */ 
   2208          
   2209          /**
   2210            * @}
   2211            */ 
   2212          
   2213          /**
   2214            * @}
   2215            */ 
   2216          
   2217          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   RCC_AHB1PeriphClockCmd
       0   RCC_AHB1PeriphClockLPModeCmd
       0   RCC_AHB1PeriphResetCmd
       0   RCC_AHB2PeriphClockCmd
       0   RCC_AHB2PeriphClockLPModeCmd
       0   RCC_AHB2PeriphResetCmd
       0   RCC_AHB3PeriphClockCmd
       0   RCC_AHB3PeriphClockLPModeCmd
       0   RCC_AHB3PeriphResetCmd
       0   RCC_APB1PeriphClockCmd
       0   RCC_APB1PeriphClockLPModeCmd
       0   RCC_APB1PeriphResetCmd
       0   RCC_APB2PeriphClockCmd
       0   RCC_APB2PeriphClockLPModeCmd
       0   RCC_APB2PeriphResetCmd
       0   RCC_AdjustHSICalibrationValue
       0   RCC_BackupResetCmd
       0   RCC_ClearFlag
       0   RCC_ClearITPendingBit
       0   RCC_ClockSecuritySystemCmd
       0   RCC_DeInit
      16   RCC_GetClocksFreq
       4   RCC_GetFlagStatus
       0   RCC_GetITStatus
       0   RCC_GetSYSCLKSource
       0   RCC_HCLKConfig
       0   RCC_HSEConfig
       0   RCC_HSICmd
       0   RCC_I2SCLKConfig
       0   RCC_ITConfig
       0   RCC_LSEConfig
       0   RCC_LSICmd
       0   RCC_LTDCCLKDivConfig
       0   RCC_MCO1Config
       0   RCC_MCO2Config
       0   RCC_PCLK1Config
       0   RCC_PCLK2Config
       0   RCC_PLLCmd
      12   RCC_PLLConfig
       0   RCC_PLLI2SCmd
       0   RCC_PLLI2SConfig
       0   RCC_PLLSAICmd
       4   RCC_PLLSAIConfig
       0   RCC_RTCCLKCmd
       0   RCC_RTCCLKConfig
       0   RCC_SAIBlockACLKConfig
       0   RCC_SAIBlockBCLKConfig
       0   RCC_SAIPLLI2SClkDivConfig
       0   RCC_SAIPLLSAIClkDivConfig
       0   RCC_SYSCLKConfig
       0   RCC_TIMCLKPresConfig
      16   RCC_WaitForHSEStartUp
        16   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable50_10
       4  ??DataTable50_11
       4  ??DataTable50_12
       4  ??DataTable50_13
       4  ??DataTable50_14
       4  ??DataTable50_15
       4  ??DataTable50_16
       4  ??DataTable50_17
       4  ??DataTable50_18
       4  ??DataTable50_19
       4  ??DataTable50_2
       4  ??DataTable50_20
       4  ??DataTable50_21
       4  ??DataTable50_22
       4  ??DataTable50_23
       4  ??DataTable50_24
       4  ??DataTable50_25
       4  ??DataTable50_26
       4  ??DataTable50_27
       4  ??DataTable50_28
       4  ??DataTable50_29
       4  ??DataTable50_3
       4  ??DataTable50_30
       4  ??DataTable50_31
       4  ??DataTable50_32
       4  ??DataTable50_33
       4  ??DataTable50_34
       4  ??DataTable50_35
       4  ??DataTable50_36
       4  ??DataTable50_37
       4  ??DataTable50_38
       4  ??DataTable50_39
       4  ??DataTable50_4
       4  ??DataTable50_40
       4  ??DataTable50_41
       4  ??DataTable50_42
       4  ??DataTable50_43
       4  ??DataTable50_44
       4  ??DataTable50_5
       4  ??DataTable50_6
       4  ??DataTable50_7
       4  ??DataTable50_8
       4  ??DataTable50_9
      16  APBAHBPrescTable
      30  RCC_AHB1PeriphClockCmd
      30  RCC_AHB1PeriphClockLPModeCmd
      30  RCC_AHB1PeriphResetCmd
      30  RCC_AHB2PeriphClockCmd
      30  RCC_AHB2PeriphClockLPModeCmd
      30  RCC_AHB2PeriphResetCmd
      30  RCC_AHB3PeriphClockCmd
      30  RCC_AHB3PeriphClockLPModeCmd
      30  RCC_AHB3PeriphResetCmd
      30  RCC_APB1PeriphClockCmd
      30  RCC_APB1PeriphClockLPModeCmd
      30  RCC_APB1PeriphResetCmd
      30  RCC_APB2PeriphClockCmd
      30  RCC_APB2PeriphClockLPModeCmd
      30  RCC_APB2PeriphResetCmd
      28  RCC_AdjustHSICalibrationValue
      10  RCC_BackupResetCmd
      14  RCC_ClearFlag
       6  RCC_ClearITPendingBit
      10  RCC_ClockSecuritySystemCmd
     106  RCC_DeInit
     276  RCC_GetClocksFreq
      80  RCC_GetFlagStatus
      28  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      24  RCC_HCLKConfig
      16  RCC_HSEConfig
      10  RCC_HSICmd
       8  RCC_I2SCLKConfig
      30  RCC_ITConfig
      52  RCC_LSEConfig
      10  RCC_LSICmd
      20  RCC_LTDCCLKDivConfig
      28  RCC_MCO1Config
      28  RCC_MCO2Config
      24  RCC_PCLK1Config
      26  RCC_PCLK2Config
      10  RCC_PLLCmd
      34  RCC_PLLConfig
      10  RCC_PLLI2SCmd
      14  RCC_PLLI2SConfig
      10  RCC_PLLSAICmd
      22  RCC_PLLSAIConfig
      10  RCC_RTCCLKCmd
      58  RCC_RTCCLKConfig
      20  RCC_SAIBlockACLKConfig
      20  RCC_SAIBlockBCLKConfig
      26  RCC_SAIPLLI2SClkDivConfig
      26  RCC_SAIPLLSAIClkDivConfig
      24  RCC_SYSCLKConfig
       6  RCC_TIMCLKPresConfig
      64  RCC_WaitForHSEStartUp

 
    16 bytes in section .data
 1 830 bytes in section .text
 
 1 830 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
